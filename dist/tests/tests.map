{"version":3,"sources":["lib/router/core.js","lib/router/index.js","lib/router/route-info.js","lib/router/router.js","lib/router/transition-aborted-error.js","lib/router/transition-intent.js","lib/router/transition-intent/named-transition-intent.js","lib/router/transition-intent/url-transition-intent.js","lib/router/transition-state.js","lib/router/transition.js","lib/router/unrecognized-url-error.js","lib/router/utils.js","tests/async_get_handler_test.js","tests/index.js","tests/query_params_test.js","tests/router_test.js","tests/test_helpers.js","tests/transition-aborted-error_test.js","tests/transition_intent_test.js","tests/transition_state_test.js","tests/unrecognized-url-error_test.js","tests/utils_test.js"],"sourcesContent":["//# sourceMappingURL=core.js.map\ndefine(\"lib/router/core\", [], function () {\n  \"use strict\";\n});","define('lib/router/index', ['exports', 'lib/router/router', 'lib/router/transition', 'lib/router/transition-state', 'lib/router/route-info'], function (exports, _router, _transition, _transitionState, _routeInfo) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  Object.defineProperty(exports, 'default', {\n    enumerable: true,\n    get: function () {\n      return _interopRequireDefault(_router).default;\n    }\n  });\n  Object.defineProperty(exports, 'InternalTransition', {\n    enumerable: true,\n    get: function () {\n      return _interopRequireDefault(_transition).default;\n    }\n  });\n  Object.defineProperty(exports, 'logAbort', {\n    enumerable: true,\n    get: function () {\n      return _transition.logAbort;\n    }\n  });\n  Object.defineProperty(exports, 'STATE_SYMBOL', {\n    enumerable: true,\n    get: function () {\n      return _transition.STATE_SYMBOL;\n    }\n  });\n  Object.defineProperty(exports, 'PARAMS_SYMBOL', {\n    enumerable: true,\n    get: function () {\n      return _transition.PARAMS_SYMBOL;\n    }\n  });\n  Object.defineProperty(exports, 'QUERY_PARAMS_SYMBOL', {\n    enumerable: true,\n    get: function () {\n      return _transition.QUERY_PARAMS_SYMBOL;\n    }\n  });\n  Object.defineProperty(exports, 'TransitionState', {\n    enumerable: true,\n    get: function () {\n      return _interopRequireDefault(_transitionState).default;\n    }\n  });\n  Object.defineProperty(exports, 'TransitionError', {\n    enumerable: true,\n    get: function () {\n      return _transitionState.TransitionError;\n    }\n  });\n  Object.defineProperty(exports, 'InternalRouteInfo', {\n    enumerable: true,\n    get: function () {\n      return _interopRequireDefault(_routeInfo).default;\n    }\n  });\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n});","define('lib/router/route-info', ['exports', 'rsvp', 'lib/router/transition', 'lib/router/utils'], function (exports, _rsvp, _transition2, _utils) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.UnresolvedRouteInfoByObject = exports.UnresolvedRouteInfoByParam = exports.ResolvedRouteInfo = undefined;\n    exports.toReadOnlyRouteInfo = toReadOnlyRouteInfo;\n\n    var _get = function get(object, property, receiver) {\n        if (object === null) object = Function.prototype;\n        var desc = Object.getOwnPropertyDescriptor(object, property);\n\n        if (desc === undefined) {\n            var parent = Object.getPrototypeOf(object);\n\n            if (parent === null) {\n                return undefined;\n            } else {\n                return get(parent, property, receiver);\n            }\n        } else if (\"value\" in desc) {\n            return desc.value;\n        } else {\n            var getter = desc.get;\n\n            if (getter === undefined) {\n                return undefined;\n            }\n\n            return getter.call(receiver);\n        }\n    };\n\n    function _possibleConstructorReturn(self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    var ROUTE_INFOS = new WeakMap();\n    function toReadOnlyRouteInfo(routeInfos) {\n        var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var includeAttributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        return routeInfos.map(function (info, i) {\n            var name = info.name,\n                params = info.params,\n                paramNames = info.paramNames,\n                context = info.context,\n                route = info.route;\n\n            if (ROUTE_INFOS.has(info) && includeAttributes) {\n                var _routeInfo = ROUTE_INFOS.get(info);\n                _routeInfo = attachMetadata(route, _routeInfo);\n                var routeInfoWithAttribute = createRouteInfoWithAttributes(_routeInfo, context);\n                ROUTE_INFOS.set(info, routeInfoWithAttribute);\n                return routeInfoWithAttribute;\n            }\n            var routeInfo = {\n                find: function find(predicate, thisArg) {\n                    var publicInfo = void 0;\n                    var arr = [];\n                    if (predicate.length === 3) {\n                        arr = routeInfos.map(function (info) {\n                            return ROUTE_INFOS.get(info);\n                        });\n                    }\n                    for (var _i = 0; routeInfos.length > _i; _i++) {\n                        publicInfo = ROUTE_INFOS.get(routeInfos[_i]);\n                        if (predicate.call(thisArg, publicInfo, _i, arr)) {\n                            return publicInfo;\n                        }\n                    }\n                    return undefined;\n                },\n\n                get name() {\n                    return name;\n                },\n                get paramNames() {\n                    return paramNames;\n                },\n                get metadata() {\n                    return buildRouteInfoMetadata(info.route);\n                },\n                get parent() {\n                    var parent = routeInfos[i - 1];\n                    if (parent === undefined) {\n                        return null;\n                    }\n                    return ROUTE_INFOS.get(parent);\n                },\n                get child() {\n                    var child = routeInfos[i + 1];\n                    if (child === undefined) {\n                        return null;\n                    }\n                    return ROUTE_INFOS.get(child);\n                },\n                get localName() {\n                    var parts = this.name.split('.');\n                    return parts[parts.length - 1];\n                },\n                get params() {\n                    return params;\n                },\n                get queryParams() {\n                    return queryParams;\n                }\n            };\n            if (includeAttributes) {\n                routeInfo = createRouteInfoWithAttributes(routeInfo, context);\n            }\n            ROUTE_INFOS.set(info, routeInfo);\n            return routeInfo;\n        });\n    }\n    function createRouteInfoWithAttributes(routeInfo, context) {\n        var attributes = {\n            get attributes() {\n                return context;\n            }\n        };\n        if (!Object.isExtensible(routeInfo) || routeInfo.hasOwnProperty('attributes')) {\n            return Object.freeze(Object.assign({}, routeInfo, attributes));\n        }\n        return Object.assign(routeInfo, attributes);\n    }\n    function buildRouteInfoMetadata(route) {\n        if (route !== undefined && route !== null && route.buildRouteInfoMetadata !== undefined) {\n            return route.buildRouteInfoMetadata();\n        }\n        return null;\n    }\n    function attachMetadata(route, routeInfo) {\n        var metadata = {\n            get metadata() {\n                return buildRouteInfoMetadata(route);\n            }\n        };\n        if (!Object.isExtensible(routeInfo) || routeInfo.hasOwnProperty('metadata')) {\n            return Object.freeze(Object.assign({}, routeInfo, metadata));\n        }\n        return Object.assign(routeInfo, metadata);\n    }\n\n    var InternalRouteInfo = function () {\n        function InternalRouteInfo(router, name, paramNames, route) {\n            _classCallCheck(this, InternalRouteInfo);\n\n            this._routePromise = undefined;\n            this._route = null;\n            this.params = {};\n            this.isResolved = false;\n            this.name = name;\n            this.paramNames = paramNames;\n            this.router = router;\n            if (route) {\n                this._processRoute(route);\n            }\n        }\n\n        _createClass(InternalRouteInfo, [{\n            key: 'getModel',\n            value: function getModel(_transition) {\n                return _rsvp.Promise.resolve(this.context);\n            }\n        }, {\n            key: 'serialize',\n            value: function serialize(_context) {\n                return this.params || {};\n            }\n        }, {\n            key: 'resolve',\n            value: function resolve(shouldContinue, transition) {\n                var _this = this;\n\n                return _rsvp.Promise.resolve(this.routePromise).then(function (route) {\n                    return _this.checkForAbort(shouldContinue, route);\n                }).then(function () {\n                    return _this.runBeforeModelHook(transition);\n                }).then(function () {\n                    return _this.checkForAbort(shouldContinue, null);\n                }).then(function () {\n                    return _this.getModel(transition);\n                }).then(function (resolvedModel) {\n                    return _this.checkForAbort(shouldContinue, resolvedModel);\n                }).then(function (resolvedModel) {\n                    return _this.runAfterModelHook(transition, resolvedModel);\n                }).then(function (resolvedModel) {\n                    return _this.becomeResolved(transition, resolvedModel);\n                });\n            }\n        }, {\n            key: 'becomeResolved',\n            value: function becomeResolved(transition, resolvedContext) {\n                var params = this.serialize(resolvedContext);\n                if (transition) {\n                    this.stashResolvedModel(transition, resolvedContext);\n                    transition[_transition2.PARAMS_SYMBOL] = transition[_transition2.PARAMS_SYMBOL] || {};\n                    transition[_transition2.PARAMS_SYMBOL][this.name] = params;\n                }\n                var context = void 0;\n                var contextsMatch = resolvedContext === this.context;\n                if ('context' in this || !contextsMatch) {\n                    context = resolvedContext;\n                }\n                var cached = ROUTE_INFOS.get(this);\n                var resolved = new ResolvedRouteInfo(this.router, this.name, this.paramNames, params, this.route, context);\n                if (cached !== undefined) {\n                    ROUTE_INFOS.set(resolved, cached);\n                }\n                return resolved;\n            }\n        }, {\n            key: 'shouldSupercede',\n            value: function shouldSupercede(routeInfo) {\n                // Prefer this newer routeInfo over `other` if:\n                // 1) The other one doesn't exist\n                // 2) The names don't match\n                // 3) This route has a context that doesn't match\n                //    the other one (or the other one doesn't have one).\n                // 4) This route has parameters that don't match the other.\n                if (!routeInfo) {\n                    return true;\n                }\n                var contextsMatch = routeInfo.context === this.context;\n                return routeInfo.name !== this.name || 'context' in this && !contextsMatch || this.hasOwnProperty('params') && !paramsMatch(this.params, routeInfo.params);\n            }\n        }, {\n            key: 'log',\n            value: function log(transition, message) {\n                if (transition.log) {\n                    transition.log(this.name + ': ' + message);\n                }\n            }\n        }, {\n            key: 'updateRoute',\n            value: function updateRoute(route) {\n                route._internalName = this.name;\n                return this.route = route;\n            }\n        }, {\n            key: 'runBeforeModelHook',\n            value: function runBeforeModelHook(transition) {\n                if (transition.trigger) {\n                    transition.trigger(true, 'willResolveModel', transition, this.route);\n                }\n                var result = void 0;\n                if (this.route) {\n                    if (this.route.beforeModel !== undefined) {\n                        result = this.route.beforeModel(transition);\n                    }\n                }\n                if ((0, _transition2.isTransition)(result)) {\n                    result = null;\n                }\n                return _rsvp.Promise.resolve(result);\n            }\n        }, {\n            key: 'runAfterModelHook',\n            value: function runAfterModelHook(transition, resolvedModel) {\n                // Stash the resolved model on the payload.\n                // This makes it possible for users to swap out\n                // the resolved model in afterModel.\n                var name = this.name;\n                this.stashResolvedModel(transition, resolvedModel);\n                var result = void 0;\n                if (this.route !== undefined) {\n                    if (this.route.afterModel !== undefined) {\n                        result = this.route.afterModel(resolvedModel, transition);\n                    }\n                }\n                result = (0, _transition2.prepareResult)(result);\n                return _rsvp.Promise.resolve(result).then(function () {\n                    // Ignore the fulfilled value returned from afterModel.\n                    // Return the value stashed in resolvedModels, which\n                    // might have been swapped out in afterModel.\n                    return transition.resolvedModels[name];\n                });\n            }\n        }, {\n            key: 'checkForAbort',\n            value: function checkForAbort(shouldContinue, value) {\n                return _rsvp.Promise.resolve(shouldContinue()).then(function () {\n                    // We don't care about shouldContinue's resolve value;\n                    // pass along the original value passed to this fn.\n                    return value;\n                }, null);\n            }\n        }, {\n            key: 'stashResolvedModel',\n            value: function stashResolvedModel(transition, resolvedModel) {\n                transition.resolvedModels = transition.resolvedModels || {};\n                transition.resolvedModels[this.name] = resolvedModel;\n            }\n        }, {\n            key: 'fetchRoute',\n            value: function fetchRoute() {\n                var route = this.router.getRoute(this.name);\n                return this._processRoute(route);\n            }\n        }, {\n            key: '_processRoute',\n            value: function _processRoute(route) {\n                var _this2 = this;\n\n                // Setup a routePromise so that we can wait for asynchronously loaded routes\n                this.routePromise = _rsvp.Promise.resolve(route);\n                // Wait until the 'route' property has been updated when chaining to a route\n                // that is a promise\n                if ((0, _utils.isPromise)(route)) {\n                    this.routePromise = this.routePromise.then(function (r) {\n                        return _this2.updateRoute(r);\n                    });\n                    // set to undefined to avoid recursive loop in the route getter\n                    return this.route = undefined;\n                } else if (route) {\n                    return this.updateRoute(route);\n                }\n                return undefined;\n            }\n        }, {\n            key: 'route',\n            get: function get() {\n                // _route could be set to either a route object or undefined, so we\n                // compare against null to know when it's been set\n                if (this._route !== null) {\n                    return this._route;\n                }\n                return this.fetchRoute();\n            },\n            set: function set(route) {\n                this._route = route;\n            }\n        }, {\n            key: 'routePromise',\n            get: function get() {\n                if (this._routePromise) {\n                    return this._routePromise;\n                }\n                this.fetchRoute();\n                return this._routePromise;\n            },\n            set: function set(routePromise) {\n                this._routePromise = routePromise;\n            }\n        }]);\n\n        return InternalRouteInfo;\n    }();\n\n    exports.default = InternalRouteInfo;\n\n    var ResolvedRouteInfo = exports.ResolvedRouteInfo = function (_InternalRouteInfo) {\n        _inherits(ResolvedRouteInfo, _InternalRouteInfo);\n\n        function ResolvedRouteInfo(router, name, paramNames, params, route, context) {\n            _classCallCheck(this, ResolvedRouteInfo);\n\n            var _this3 = _possibleConstructorReturn(this, (ResolvedRouteInfo.__proto__ || Object.getPrototypeOf(ResolvedRouteInfo)).call(this, router, name, paramNames, route));\n\n            _this3.params = params;\n            _this3.isResolved = true;\n            _this3.context = context;\n            return _this3;\n        }\n\n        _createClass(ResolvedRouteInfo, [{\n            key: 'resolve',\n            value: function resolve(_shouldContinue, transition) {\n                // A ResolvedRouteInfo just resolved with itself.\n                if (transition && transition.resolvedModels) {\n                    transition.resolvedModels[this.name] = this.context;\n                }\n                return _rsvp.Promise.resolve(this);\n            }\n        }]);\n\n        return ResolvedRouteInfo;\n    }(InternalRouteInfo);\n\n    var UnresolvedRouteInfoByParam = exports.UnresolvedRouteInfoByParam = function (_InternalRouteInfo2) {\n        _inherits(UnresolvedRouteInfoByParam, _InternalRouteInfo2);\n\n        function UnresolvedRouteInfoByParam(router, name, paramNames, params, route) {\n            _classCallCheck(this, UnresolvedRouteInfoByParam);\n\n            var _this4 = _possibleConstructorReturn(this, (UnresolvedRouteInfoByParam.__proto__ || Object.getPrototypeOf(UnresolvedRouteInfoByParam)).call(this, router, name, paramNames, route));\n\n            _this4.params = {};\n            _this4.params = params;\n            return _this4;\n        }\n\n        _createClass(UnresolvedRouteInfoByParam, [{\n            key: 'getModel',\n            value: function getModel(transition) {\n                var fullParams = this.params;\n                if (transition && transition[_transition2.QUERY_PARAMS_SYMBOL]) {\n                    fullParams = {};\n                    (0, _utils.merge)(fullParams, this.params);\n                    fullParams.queryParams = transition[_transition2.QUERY_PARAMS_SYMBOL];\n                }\n                var route = this.route;\n                var result = undefined;\n                if (route.deserialize) {\n                    result = route.deserialize(fullParams, transition);\n                } else if (route.model) {\n                    result = route.model(fullParams, transition);\n                }\n                if (result && (0, _transition2.isTransition)(result)) {\n                    result = undefined;\n                }\n                return _rsvp.Promise.resolve(result);\n            }\n        }]);\n\n        return UnresolvedRouteInfoByParam;\n    }(InternalRouteInfo);\n\n    var UnresolvedRouteInfoByObject = exports.UnresolvedRouteInfoByObject = function (_InternalRouteInfo3) {\n        _inherits(UnresolvedRouteInfoByObject, _InternalRouteInfo3);\n\n        function UnresolvedRouteInfoByObject(router, name, paramNames, context) {\n            _classCallCheck(this, UnresolvedRouteInfoByObject);\n\n            var _this5 = _possibleConstructorReturn(this, (UnresolvedRouteInfoByObject.__proto__ || Object.getPrototypeOf(UnresolvedRouteInfoByObject)).call(this, router, name, paramNames));\n\n            _this5.context = context;\n            _this5.serializer = _this5.router.getSerializer(name);\n            return _this5;\n        }\n\n        _createClass(UnresolvedRouteInfoByObject, [{\n            key: 'getModel',\n            value: function getModel(transition) {\n                if (this.router.log !== undefined) {\n                    this.router.log(this.name + ': resolving provided model');\n                }\n                return _get(UnresolvedRouteInfoByObject.prototype.__proto__ || Object.getPrototypeOf(UnresolvedRouteInfoByObject.prototype), 'getModel', this).call(this, transition);\n            }\n            /**\n              @private\n                 Serializes a route using its custom `serialize` method or\n              by a default that looks up the expected property name from\n              the dynamic segment.\n                 @param {Object} model the model to be serialized for this route\n            */\n\n        }, {\n            key: 'serialize',\n            value: function serialize(model) {\n                var paramNames = this.paramNames,\n                    context = this.context;\n\n                if (!model) {\n                    model = context;\n                }\n                var object = {};\n                if ((0, _utils.isParam)(model)) {\n                    object[paramNames[0]] = model;\n                    return object;\n                }\n                // Use custom serialize if it exists.\n                if (this.serializer) {\n                    // invoke this.serializer unbound (getSerializer returns a stateless function)\n                    return this.serializer.call(null, model, paramNames);\n                } else if (this.route !== undefined) {\n                    if (this.route.serialize) {\n                        return this.route.serialize(model, paramNames);\n                    }\n                }\n                if (paramNames.length !== 1) {\n                    return;\n                }\n                var name = paramNames[0];\n                if (/_id$/.test(name)) {\n                    object[name] = model.id;\n                } else {\n                    object[name] = model;\n                }\n                return object;\n            }\n        }]);\n\n        return UnresolvedRouteInfoByObject;\n    }(InternalRouteInfo);\n\n    function paramsMatch(a, b) {\n        if (!a !== !b) {\n            // Only one is null.\n            return false;\n        }\n        if (!a) {\n            // Both must be null.\n            return true;\n        }\n        // Note: this assumes that both params have the same\n        // number of keys, but since we're comparing the\n        // same routes, they should.\n        for (var k in a) {\n            if (a.hasOwnProperty(k) && a[k] !== b[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //# sourceMappingURL=route-info.js.map\n});","define('lib/router/router', ['exports', 'route-recognizer', 'rsvp', 'lib/router/route-info', 'lib/router/transition', 'lib/router/transition-aborted-error', 'lib/router/transition-intent/named-transition-intent', 'lib/router/transition-intent/url-transition-intent', 'lib/router/transition-state', 'lib/router/utils'], function (exports, _routeRecognizer, _rsvp, _routeInfo, _transition, _transitionAbortedError, _namedTransitionIntent, _urlTransitionIntent, _transitionState, _utils) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n\n    var _routeRecognizer2 = _interopRequireDefault(_routeRecognizer);\n\n    var _transition2 = _interopRequireDefault(_transition);\n\n    var _transitionAbortedError2 = _interopRequireDefault(_transitionAbortedError);\n\n    var _namedTransitionIntent2 = _interopRequireDefault(_namedTransitionIntent);\n\n    var _urlTransitionIntent2 = _interopRequireDefault(_urlTransitionIntent);\n\n    var _transitionState2 = _interopRequireDefault(_transitionState);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n    } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    var Router = function () {\n        function Router(logger) {\n            _classCallCheck(this, Router);\n\n            this._lastQueryParams = {};\n            this.state = undefined;\n            this.oldState = undefined;\n            this.activeTransition = undefined;\n            this.currentRouteInfos = undefined;\n            this._changedQueryParams = undefined;\n            this.currentSequence = 0;\n            this.log = logger;\n            this.recognizer = new _routeRecognizer2.default();\n            this.reset();\n        }\n        /**\n          The main entry point into the router. The API is essentially\n          the same as the `map` method in `route-recognizer`.\n             This method extracts the String handler at the last `.to()`\n          call and uses it as the name of the whole route.\n             @param {Function} callback\n        */\n\n\n        _createClass(Router, [{\n            key: 'map',\n            value: function map(callback) {\n                this.recognizer.map(callback, function (recognizer, routes) {\n                    for (var i = routes.length - 1, proceed = true; i >= 0 && proceed; --i) {\n                        var route = routes[i];\n                        var handler = route.handler;\n                        recognizer.add(routes, { as: handler });\n                        proceed = route.path === '/' || route.path === '' || handler.slice(-6) === '.index';\n                    }\n                });\n            }\n        }, {\n            key: 'hasRoute',\n            value: function hasRoute(route) {\n                return this.recognizer.hasRoute(route);\n            }\n        }, {\n            key: 'queryParamsTransition',\n            value: function queryParamsTransition(changelist, wasTransitioning, oldState, newState) {\n                var _this = this;\n\n                this.fireQueryParamDidChange(newState, changelist);\n                if (!wasTransitioning && this.activeTransition) {\n                    // One of the routes in queryParamsDidChange\n                    // caused a transition. Just return that transition.\n                    return this.activeTransition;\n                } else {\n                    // Running queryParamsDidChange didn't change anything.\n                    // Just update query params and be on our way.\n                    // We have to return a noop transition that will\n                    // perform a URL update at the end. This gives\n                    // the user the ability to set the url update\n                    // method (default is replaceState).\n                    var newTransition = new _transition2.default(this, undefined, newState);\n                    newTransition.queryParamsOnly = true;\n                    this.setupContexts(newState, newTransition);\n                    oldState.queryParams = this.finalizeQueryParamChange(newState.routeInfos, newState.queryParams, newTransition);\n                    newTransition[_transition.QUERY_PARAMS_SYMBOL] = newState.queryParams;\n                    this.toReadOnlyInfos(newTransition, newState);\n                    this.routeWillChange(newTransition);\n                    newTransition.promise = newTransition.promise.then(function (result) {\n                        if (!newTransition.isAborted) {\n                            _this._updateURL(newTransition, oldState);\n                            _this.didTransition(_this.currentRouteInfos);\n                            _this.toInfos(newTransition, newState.routeInfos, true);\n                            _this.routeDidChange(newTransition);\n                        }\n                        return result;\n                    }, null, (0, _utils.promiseLabel)('Transition complete'));\n                    return newTransition;\n                }\n            }\n        }, {\n            key: 'transitionByIntent',\n            value: function transitionByIntent(intent, isIntermediate) {\n                try {\n                    return this.getTransitionByIntent(intent, isIntermediate);\n                } catch (e) {\n                    return new _transition2.default(this, intent, undefined, e, undefined);\n                }\n            }\n        }, {\n            key: 'recognize',\n            value: function recognize(url) {\n                var intent = new _urlTransitionIntent2.default(this, url);\n                var newState = this.generateNewState(intent);\n                if (newState === null) {\n                    return newState;\n                }\n                var readonlyInfos = (0, _routeInfo.toReadOnlyRouteInfo)(newState.routeInfos, newState.queryParams);\n                return readonlyInfos[readonlyInfos.length - 1];\n            }\n        }, {\n            key: 'recognizeAndLoad',\n            value: function recognizeAndLoad(url) {\n                var intent = new _urlTransitionIntent2.default(this, url);\n                var newState = this.generateNewState(intent);\n                if (newState === null) {\n                    return _rsvp.Promise.reject('URL ' + url + ' was not recognized');\n                }\n                var newTransition = new _transition2.default(this, intent, newState, undefined);\n                return newTransition.then(function () {\n                    var routeInfosWithAttributes = (0, _routeInfo.toReadOnlyRouteInfo)(newState.routeInfos, newTransition[_transition.QUERY_PARAMS_SYMBOL], true);\n                    return routeInfosWithAttributes[routeInfosWithAttributes.length - 1];\n                });\n            }\n        }, {\n            key: 'generateNewState',\n            value: function generateNewState(intent) {\n                try {\n                    return intent.applyToState(this.state, false);\n                } catch (e) {\n                    return null;\n                }\n            }\n        }, {\n            key: 'getTransitionByIntent',\n            value: function getTransitionByIntent(intent, isIntermediate) {\n                var _this2 = this;\n\n                var wasTransitioning = !!this.activeTransition;\n                var oldState = wasTransitioning ? this.activeTransition[_transition.STATE_SYMBOL] : this.state;\n                var newTransition = void 0;\n                var newState = intent.applyToState(oldState, isIntermediate);\n                var queryParamChangelist = (0, _utils.getChangelist)(oldState.queryParams, newState.queryParams);\n                if (routeInfosEqual(newState.routeInfos, oldState.routeInfos)) {\n                    // This is a no-op transition. See if query params changed.\n                    if (queryParamChangelist) {\n                        var _newTransition = this.queryParamsTransition(queryParamChangelist, wasTransitioning, oldState, newState);\n                        _newTransition.queryParamsOnly = true;\n                        return _newTransition;\n                    }\n                    // No-op. No need to create a new transition.\n                    return this.activeTransition || new _transition2.default(this, undefined, undefined);\n                }\n                if (isIntermediate) {\n                    newState.queryParams = oldState.queryParams;\n                    var transition = new _transition2.default(this, undefined, newState);\n                    this.toReadOnlyInfos(transition, newState);\n                    this.setupContexts(newState, transition);\n                    this.routeWillChange(transition);\n                    return this.activeTransition;\n                }\n                // Create a new transition to the destination route.\n                newTransition = new _transition2.default(this, intent, newState, undefined, this.activeTransition);\n                // transition is to same route with same params, only query params differ.\n                // not caught above probably because refresh() has been used\n                if (routeInfosSameExceptQueryParams(newState.routeInfos, oldState.routeInfos)) {\n                    newTransition.queryParamsOnly = true;\n                }\n                this.toReadOnlyInfos(newTransition, newState);\n                // Abort and usurp any previously active transition.\n                if (this.activeTransition) {\n                    this.activeTransition.redirect(newTransition);\n                }\n                this.activeTransition = newTransition;\n                // Transition promises by default resolve with resolved state.\n                // For our purposes, swap out the promise to resolve\n                // after the transition has been finalized.\n                newTransition.promise = newTransition.promise.then(function (result) {\n                    return _this2.finalizeTransition(newTransition, result);\n                }, null, (0, _utils.promiseLabel)('Settle transition promise when transition is finalized'));\n                if (!wasTransitioning) {\n                    this.notifyExistingHandlers(newState, newTransition);\n                }\n                this.fireQueryParamDidChange(newState, queryParamChangelist);\n                return newTransition;\n            }\n        }, {\n            key: 'doTransition',\n            value: function doTransition(name) {\n                var modelsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n                var isIntermediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n                var lastArg = modelsArray[modelsArray.length - 1];\n                var queryParams = {};\n                if (lastArg !== undefined && lastArg.hasOwnProperty('queryParams')) {\n                    queryParams = modelsArray.pop().queryParams;\n                }\n                var intent = void 0;\n                if (name === undefined) {\n                    (0, _utils.log)(this, 'Updating query params');\n                    // A query param update is really just a transition\n                    // into the route you're already on.\n                    var routeInfos = this.state.routeInfos;\n\n                    intent = new _namedTransitionIntent2.default(this, routeInfos[routeInfos.length - 1].name, undefined, [], queryParams);\n                } else if (name.charAt(0) === '/') {\n                    (0, _utils.log)(this, 'Attempting URL transition to ' + name);\n                    intent = new _urlTransitionIntent2.default(this, name);\n                } else {\n                    (0, _utils.log)(this, 'Attempting transition to ' + name);\n                    intent = new _namedTransitionIntent2.default(this, name, undefined, modelsArray, queryParams);\n                }\n                return this.transitionByIntent(intent, isIntermediate);\n            }\n        }, {\n            key: 'finalizeTransition',\n            value: function finalizeTransition(transition, newState) {\n                try {\n                    (0, _utils.log)(transition.router, transition.sequence, 'Resolved all models on destination route; finalizing transition.');\n                    var routeInfos = newState.routeInfos;\n                    // Run all the necessary enter/setup/exit hooks\n                    this.setupContexts(newState, transition);\n                    // Check if a redirect occurred in enter/setup\n                    if (transition.isAborted) {\n                        // TODO: cleaner way? distinguish b/w targetRouteInfos?\n                        this.state.routeInfos = this.currentRouteInfos;\n                        return _rsvp.Promise.reject((0, _transition.logAbort)(transition));\n                    }\n                    this._updateURL(transition, newState);\n                    transition.isActive = false;\n                    this.activeTransition = undefined;\n                    this.triggerEvent(this.currentRouteInfos, true, 'didTransition', []);\n                    this.didTransition(this.currentRouteInfos);\n                    this.toInfos(transition, newState.routeInfos, true);\n                    this.routeDidChange(transition);\n                    (0, _utils.log)(this, transition.sequence, 'TRANSITION COMPLETE.');\n                    // Resolve with the final route.\n                    return routeInfos[routeInfos.length - 1].route;\n                } catch (e) {\n                    if (!(e instanceof _transitionAbortedError2.default)) {\n                        var infos = transition[_transition.STATE_SYMBOL].routeInfos;\n                        transition.trigger(true, 'error', e, transition, infos[infos.length - 1].route);\n                        transition.abort();\n                    }\n                    throw e;\n                }\n            }\n        }, {\n            key: 'setupContexts',\n            value: function setupContexts(newState, transition) {\n                var partition = this.partitionRoutes(this.state, newState);\n                var i = void 0,\n                    l = void 0,\n                    route = void 0;\n                for (i = 0, l = partition.exited.length; i < l; i++) {\n                    route = partition.exited[i].route;\n                    delete route.context;\n                    if (route !== undefined) {\n                        if (route._internalReset !== undefined) {\n                            route._internalReset(true, transition);\n                        }\n                        if (route.exit !== undefined) {\n                            route.exit(transition);\n                        }\n                    }\n                }\n                var oldState = this.oldState = this.state;\n                this.state = newState;\n                var currentRouteInfos = this.currentRouteInfos = partition.unchanged.slice();\n                try {\n                    for (i = 0, l = partition.reset.length; i < l; i++) {\n                        route = partition.reset[i].route;\n                        if (route !== undefined) {\n                            if (route._internalReset !== undefined) {\n                                route._internalReset(false, transition);\n                            }\n                        }\n                    }\n                    for (i = 0, l = partition.updatedContext.length; i < l; i++) {\n                        this.routeEnteredOrUpdated(currentRouteInfos, partition.updatedContext[i], false, transition);\n                    }\n                    for (i = 0, l = partition.entered.length; i < l; i++) {\n                        this.routeEnteredOrUpdated(currentRouteInfos, partition.entered[i], true, transition);\n                    }\n                } catch (e) {\n                    this.state = oldState;\n                    this.currentRouteInfos = oldState.routeInfos;\n                    throw e;\n                }\n                this.state.queryParams = this.finalizeQueryParamChange(currentRouteInfos, newState.queryParams, transition);\n            }\n        }, {\n            key: 'fireQueryParamDidChange',\n            value: function fireQueryParamDidChange(newState, queryParamChangelist) {\n                // If queryParams changed trigger event\n                if (queryParamChangelist) {\n                    // This is a little hacky but we need some way of storing\n                    // changed query params given that no activeTransition\n                    // is guaranteed to have occurred.\n                    this._changedQueryParams = queryParamChangelist.all;\n                    this.triggerEvent(newState.routeInfos, true, 'queryParamsDidChange', [queryParamChangelist.changed, queryParamChangelist.all, queryParamChangelist.removed]);\n                    this._changedQueryParams = undefined;\n                }\n            }\n        }, {\n            key: 'routeEnteredOrUpdated',\n            value: function routeEnteredOrUpdated(currentRouteInfos, routeInfo, enter, transition) {\n                var route = routeInfo.route,\n                    context = routeInfo.context;\n                function _routeEnteredOrUpdated(route) {\n                    if (enter) {\n                        if (route.enter !== undefined) {\n                            route.enter(transition);\n                        }\n                    }\n                    if (transition && transition.isAborted) {\n                        throw new _transitionAbortedError2.default();\n                    }\n                    route.context = context;\n                    if (route.contextDidChange !== undefined) {\n                        route.contextDidChange();\n                    }\n                    if (route.setup !== undefined) {\n                        route.setup(context, transition);\n                    }\n                    if (transition && transition.isAborted) {\n                        throw new _transitionAbortedError2.default();\n                    }\n                    currentRouteInfos.push(routeInfo);\n                    return route;\n                }\n                // If the route doesn't exist, it means we haven't resolved the route promise yet\n                if (route === undefined) {\n                    routeInfo.routePromise = routeInfo.routePromise.then(_routeEnteredOrUpdated);\n                } else {\n                    _routeEnteredOrUpdated(route);\n                }\n                return true;\n            }\n        }, {\n            key: 'partitionRoutes',\n            value: function partitionRoutes(oldState, newState) {\n                var oldRouteInfos = oldState.routeInfos;\n                var newRouteInfos = newState.routeInfos;\n                var routes = {\n                    updatedContext: [],\n                    exited: [],\n                    entered: [],\n                    unchanged: [],\n                    reset: []\n                };\n                var routeChanged = void 0,\n                    contextChanged = false,\n                    i = void 0,\n                    l = void 0;\n                for (i = 0, l = newRouteInfos.length; i < l; i++) {\n                    var oldRouteInfo = oldRouteInfos[i],\n                        newRouteInfo = newRouteInfos[i];\n                    if (!oldRouteInfo || oldRouteInfo.route !== newRouteInfo.route) {\n                        routeChanged = true;\n                    }\n                    if (routeChanged) {\n                        routes.entered.push(newRouteInfo);\n                        if (oldRouteInfo) {\n                            routes.exited.unshift(oldRouteInfo);\n                        }\n                    } else if (contextChanged || oldRouteInfo.context !== newRouteInfo.context) {\n                        contextChanged = true;\n                        routes.updatedContext.push(newRouteInfo);\n                    } else {\n                        routes.unchanged.push(oldRouteInfo);\n                    }\n                }\n                for (i = newRouteInfos.length, l = oldRouteInfos.length; i < l; i++) {\n                    routes.exited.unshift(oldRouteInfos[i]);\n                }\n                routes.reset = routes.updatedContext.slice();\n                routes.reset.reverse();\n                return routes;\n            }\n        }, {\n            key: '_updateURL',\n            value: function _updateURL(transition, state) {\n                var urlMethod = transition.urlMethod;\n                if (!urlMethod) {\n                    return;\n                }\n                var routeInfos = state.routeInfos;\n                var routeName = routeInfos[routeInfos.length - 1].name;\n\n                var params = {};\n                for (var i = routeInfos.length - 1; i >= 0; --i) {\n                    var routeInfo = routeInfos[i];\n                    (0, _utils.merge)(params, routeInfo.params);\n                    if (routeInfo.route.inaccessibleByURL) {\n                        urlMethod = null;\n                    }\n                }\n                if (urlMethod) {\n                    params.queryParams = transition._visibleQueryParams || state.queryParams;\n                    var url = this.recognizer.generate(routeName, params);\n                    // transitions during the initial transition must always use replaceURL.\n                    // When the app boots, you are at a url, e.g. /foo. If some route\n                    // redirects to bar as part of the initial transition, you don't want to\n                    // add a history entry for /foo. If you do, pressing back will immediately\n                    // hit the redirect again and take you back to /bar, thus killing the back\n                    // button\n                    var initial = transition.isCausedByInitialTransition;\n                    // say you are at / and you click a link to route /foo. In /foo's\n                    // route, the transition is aborted using replacewith('/bar').\n                    // Because the current url is still /, the history entry for / is\n                    // removed from the history. Clicking back will take you to the page\n                    // you were on before /, which is often not even the app, thus killing\n                    // the back button. That's why updateURL is always correct for an\n                    // aborting transition that's not the initial transition\n                    var replaceAndNotAborting = urlMethod === 'replace' && !transition.isCausedByAbortingTransition;\n                    // because calling refresh causes an aborted transition, this needs to be\n                    // special cased - if the initial transition is a replace transition, the\n                    // urlMethod should be honored here.\n                    var isQueryParamsRefreshTransition = transition.queryParamsOnly && urlMethod === 'replace';\n                    // say you are at / and you a `replaceWith(/foo)` is called. Then, that\n                    // transition is aborted with `replaceWith(/bar)`. At the end, we should\n                    // end up with /bar replacing /. We are replacing the replace. We only\n                    // will replace the initial route if all subsequent aborts are also\n                    // replaces. However, there is some ambiguity around the correct behavior\n                    // here.\n                    var replacingReplace = urlMethod === 'replace' && transition.isCausedByAbortingReplaceTransition;\n                    if (initial || replaceAndNotAborting || isQueryParamsRefreshTransition || replacingReplace) {\n                        this.replaceURL(url);\n                    } else {\n                        this.updateURL(url);\n                    }\n                }\n            }\n        }, {\n            key: 'finalizeQueryParamChange',\n            value: function finalizeQueryParamChange(resolvedHandlers, newQueryParams, transition) {\n                // We fire a finalizeQueryParamChange event which\n                // gives the new route hierarchy a chance to tell\n                // us which query params it's consuming and what\n                // their final values are. If a query param is\n                // no longer consumed in the final route hierarchy,\n                // its serialized segment will be removed\n                // from the URL.\n                for (var k in newQueryParams) {\n                    if (newQueryParams.hasOwnProperty(k) && newQueryParams[k] === null) {\n                        delete newQueryParams[k];\n                    }\n                }\n                var finalQueryParamsArray = [];\n                this.triggerEvent(resolvedHandlers, true, 'finalizeQueryParamChange', [newQueryParams, finalQueryParamsArray, transition]);\n                if (transition) {\n                    transition._visibleQueryParams = {};\n                }\n                var finalQueryParams = {};\n                for (var i = 0, len = finalQueryParamsArray.length; i < len; ++i) {\n                    var qp = finalQueryParamsArray[i];\n                    finalQueryParams[qp.key] = qp.value;\n                    if (transition && qp.visible !== false) {\n                        transition._visibleQueryParams[qp.key] = qp.value;\n                    }\n                }\n                return finalQueryParams;\n            }\n        }, {\n            key: 'toReadOnlyInfos',\n            value: function toReadOnlyInfos(newTransition, newState) {\n                var oldRouteInfos = this.state.routeInfos;\n                this.fromInfos(newTransition, oldRouteInfos);\n                this.toInfos(newTransition, newState.routeInfos);\n                this._lastQueryParams = newState.queryParams;\n            }\n        }, {\n            key: 'fromInfos',\n            value: function fromInfos(newTransition, oldRouteInfos) {\n                if (newTransition !== undefined && oldRouteInfos.length > 0) {\n                    var fromInfos = (0, _routeInfo.toReadOnlyRouteInfo)(oldRouteInfos, Object.assign({}, this._lastQueryParams), true);\n                    newTransition.from = fromInfos[fromInfos.length - 1] || null;\n                }\n            }\n        }, {\n            key: 'toInfos',\n            value: function toInfos(newTransition, newRouteInfos) {\n                var includeAttributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n                if (newTransition !== undefined && newRouteInfos.length > 0) {\n                    var toInfos = (0, _routeInfo.toReadOnlyRouteInfo)(newRouteInfos, Object.assign({}, newTransition[_transition.QUERY_PARAMS_SYMBOL]), includeAttributes);\n                    newTransition.to = toInfos[toInfos.length - 1] || null;\n                }\n            }\n        }, {\n            key: 'notifyExistingHandlers',\n            value: function notifyExistingHandlers(newState, newTransition) {\n                var oldRouteInfos = this.state.routeInfos,\n                    changing = [],\n                    i = void 0,\n                    oldRouteInfoLen = void 0,\n                    oldHandler = void 0,\n                    newRouteInfo = void 0;\n                oldRouteInfoLen = oldRouteInfos.length;\n                for (i = 0; i < oldRouteInfoLen; i++) {\n                    oldHandler = oldRouteInfos[i];\n                    newRouteInfo = newState.routeInfos[i];\n                    if (!newRouteInfo || oldHandler.name !== newRouteInfo.name) {\n                        break;\n                    }\n                    if (!newRouteInfo.isResolved) {\n                        changing.push(oldHandler);\n                    }\n                }\n                this.triggerEvent(oldRouteInfos, true, 'willTransition', [newTransition]);\n                this.routeWillChange(newTransition);\n                this.willTransition(oldRouteInfos, newState.routeInfos, newTransition);\n            }\n        }, {\n            key: 'reset',\n            value: function reset() {\n                if (this.state) {\n                    (0, _utils.forEach)(this.state.routeInfos.slice().reverse(), function (routeInfo) {\n                        var route = routeInfo.route;\n                        if (route !== undefined) {\n                            if (route.exit !== undefined) {\n                                route.exit();\n                            }\n                        }\n                        return true;\n                    });\n                }\n                this.oldState = undefined;\n                this.state = new _transitionState2.default();\n                this.currentRouteInfos = undefined;\n            }\n        }, {\n            key: 'handleURL',\n            value: function handleURL(url) {\n                // Perform a URL-based transition, but don't change\n                // the URL afterward, since it already happened.\n                if (url.charAt(0) !== '/') {\n                    url = '/' + url;\n                }\n                return this.doTransition(url).method(null);\n            }\n        }, {\n            key: 'transitionTo',\n            value: function transitionTo(name) {\n                for (var _len = arguments.length, contexts = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                    contexts[_key - 1] = arguments[_key];\n                }\n\n                if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n                    contexts.push(name);\n                    return this.doTransition(undefined, contexts, false);\n                }\n                return this.doTransition(name, contexts);\n            }\n        }, {\n            key: 'intermediateTransitionTo',\n            value: function intermediateTransitionTo(name) {\n                for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                    args[_key2 - 1] = arguments[_key2];\n                }\n\n                return this.doTransition(name, args, true);\n            }\n        }, {\n            key: 'refresh',\n            value: function refresh(pivotRoute) {\n                var previousTransition = this.activeTransition;\n                var state = previousTransition ? previousTransition[_transition.STATE_SYMBOL] : this.state;\n                var routeInfos = state.routeInfos;\n                if (pivotRoute === undefined) {\n                    pivotRoute = routeInfos[0].route;\n                }\n                (0, _utils.log)(this, 'Starting a refresh transition');\n                var name = routeInfos[routeInfos.length - 1].name;\n                var intent = new _namedTransitionIntent2.default(this, name, pivotRoute, [], this._changedQueryParams || state.queryParams);\n                var newTransition = this.transitionByIntent(intent, false);\n                // if the previous transition is a replace transition, that needs to be preserved\n                if (previousTransition && previousTransition.urlMethod === 'replace') {\n                    newTransition.method(previousTransition.urlMethod);\n                }\n                return newTransition;\n            }\n        }, {\n            key: 'replaceWith',\n            value: function replaceWith(name) {\n                return this.doTransition(name).method('replace');\n            }\n        }, {\n            key: 'generate',\n            value: function generate(routeName) {\n                for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                    args[_key3 - 1] = arguments[_key3];\n                }\n\n                var partitionedArgs = (0, _utils.extractQueryParams)(args),\n                    suppliedParams = partitionedArgs[0],\n                    queryParams = partitionedArgs[1];\n                // Construct a TransitionIntent with the provided params\n                // and apply it to the present state of the router.\n                var intent = new _namedTransitionIntent2.default(this, routeName, undefined, suppliedParams);\n                var state = intent.applyToState(this.state, false);\n                var params = {};\n                for (var i = 0, len = state.routeInfos.length; i < len; ++i) {\n                    var routeInfo = state.routeInfos[i];\n                    var routeParams = routeInfo.serialize();\n                    (0, _utils.merge)(params, routeParams);\n                }\n                params.queryParams = queryParams;\n                return this.recognizer.generate(routeName, params);\n            }\n        }, {\n            key: 'applyIntent',\n            value: function applyIntent(routeName, contexts) {\n                var intent = new _namedTransitionIntent2.default(this, routeName, undefined, contexts);\n                var state = this.activeTransition && this.activeTransition[_transition.STATE_SYMBOL] || this.state;\n                return intent.applyToState(state, false);\n            }\n        }, {\n            key: 'isActiveIntent',\n            value: function isActiveIntent(routeName, contexts, queryParams, _state) {\n                var state = _state || this.state,\n                    targetRouteInfos = state.routeInfos,\n                    routeInfo = void 0,\n                    len = void 0;\n                if (!targetRouteInfos.length) {\n                    return false;\n                }\n                var targetHandler = targetRouteInfos[targetRouteInfos.length - 1].name;\n                var recogHandlers = this.recognizer.handlersFor(targetHandler);\n                var index = 0;\n                for (len = recogHandlers.length; index < len; ++index) {\n                    routeInfo = targetRouteInfos[index];\n                    if (routeInfo.name === routeName) {\n                        break;\n                    }\n                }\n                if (index === recogHandlers.length) {\n                    // The provided route name isn't even in the route hierarchy.\n                    return false;\n                }\n                var testState = new _transitionState2.default();\n                testState.routeInfos = targetRouteInfos.slice(0, index + 1);\n                recogHandlers = recogHandlers.slice(0, index + 1);\n                var intent = new _namedTransitionIntent2.default(this, targetHandler, undefined, contexts);\n                var newState = intent.applyToHandlers(testState, recogHandlers, targetHandler, true, true);\n                var routesEqual = routeInfosEqual(newState.routeInfos, testState.routeInfos);\n                if (!queryParams || !routesEqual) {\n                    return routesEqual;\n                }\n                // Get a hash of QPs that will still be active on new route\n                var activeQPsOnNewHandler = {};\n                (0, _utils.merge)(activeQPsOnNewHandler, queryParams);\n                var activeQueryParams = state.queryParams;\n                for (var key in activeQueryParams) {\n                    if (activeQueryParams.hasOwnProperty(key) && activeQPsOnNewHandler.hasOwnProperty(key)) {\n                        activeQPsOnNewHandler[key] = activeQueryParams[key];\n                    }\n                }\n                return routesEqual && !(0, _utils.getChangelist)(activeQPsOnNewHandler, queryParams);\n            }\n        }, {\n            key: 'isActive',\n            value: function isActive(routeName) {\n                for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n                    args[_key4 - 1] = arguments[_key4];\n                }\n\n                var partitionedArgs = (0, _utils.extractQueryParams)(args);\n                return this.isActiveIntent(routeName, partitionedArgs[0], partitionedArgs[1]);\n            }\n        }, {\n            key: 'trigger',\n            value: function trigger(name) {\n                for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                    args[_key5 - 1] = arguments[_key5];\n                }\n\n                this.triggerEvent(this.currentRouteInfos, false, name, args);\n            }\n        }]);\n\n        return Router;\n    }();\n\n    exports.default = Router;\n\n    function routeInfosEqual(routeInfos, otherRouteInfos) {\n        if (routeInfos.length !== otherRouteInfos.length) {\n            return false;\n        }\n        for (var i = 0, len = routeInfos.length; i < len; ++i) {\n            if (routeInfos[i] !== otherRouteInfos[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function routeInfosSameExceptQueryParams(routeInfos, otherRouteInfos) {\n        if (routeInfos.length !== otherRouteInfos.length) {\n            return false;\n        }\n        for (var i = 0, len = routeInfos.length; i < len; ++i) {\n            if (routeInfos[i].name !== otherRouteInfos[i].name) {\n                return false;\n            }\n            if (!paramsEqual(routeInfos[i].params, otherRouteInfos[i].params)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function paramsEqual(params, otherParams) {\n        if (!params && !otherParams) {\n            return true;\n        } else if (!params && !!otherParams || !!params && !otherParams) {\n            // one is falsy but other is not;\n            return false;\n        }\n        var keys = Object.keys(params);\n        var otherKeys = Object.keys(otherParams);\n        if (keys.length !== otherKeys.length) {\n            return false;\n        }\n        for (var i = 0, len = keys.length; i < len; ++i) {\n            var key = keys[i];\n            if (params[key] !== otherParams[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //# sourceMappingURL=router.js.map\n});","define('lib/router/transition-aborted-error', ['exports'], function (exports) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    var TransitionAbortedError = function () {\n        TransitionAbortedError.prototype = Object.create(Error.prototype);\n        TransitionAbortedError.prototype.constructor = TransitionAbortedError;\n        function TransitionAbortedError(message) {\n            var error = Error.call(this, message);\n            this.name = 'TransitionAborted';\n            this.message = message || 'TransitionAborted';\n            if (Error.captureStackTrace) {\n                Error.captureStackTrace(this, TransitionAbortedError);\n            } else {\n                this.stack = error.stack;\n            }\n        }\n        return TransitionAbortedError;\n    }();\n    exports.default = TransitionAbortedError;\n});","define(\"lib/router/transition-intent\", [\"exports\"], function (exports) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var TransitionIntent = exports.TransitionIntent = function TransitionIntent(router) {\n        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, TransitionIntent);\n\n        this.router = router;\n        this.data = data;\n    };\n});","define('lib/router/transition-intent/named-transition-intent', ['exports', 'lib/router/route-info', 'lib/router/transition-intent', 'lib/router/transition-state', 'lib/router/utils'], function (exports, _routeInfo, _transitionIntent, _transitionState, _utils) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n\n    var _transitionState2 = _interopRequireDefault(_transitionState);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    function _possibleConstructorReturn(self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    var NamedTransitionIntent = function (_TransitionIntent) {\n        _inherits(NamedTransitionIntent, _TransitionIntent);\n\n        function NamedTransitionIntent(router, name, pivotHandler) {\n            var contexts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n            var queryParams = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n            var data = arguments[5];\n\n            _classCallCheck(this, NamedTransitionIntent);\n\n            var _this = _possibleConstructorReturn(this, (NamedTransitionIntent.__proto__ || Object.getPrototypeOf(NamedTransitionIntent)).call(this, router, data));\n\n            _this.preTransitionState = undefined;\n            _this.name = name;\n            _this.pivotHandler = pivotHandler;\n            _this.contexts = contexts;\n            _this.queryParams = queryParams;\n            return _this;\n        }\n\n        _createClass(NamedTransitionIntent, [{\n            key: 'applyToState',\n            value: function applyToState(oldState, isIntermediate) {\n                // TODO: WTF fix me\n                var partitionedArgs = (0, _utils.extractQueryParams)([this.name].concat(this.contexts)),\n                    pureArgs = partitionedArgs[0],\n                    handlers = this.router.recognizer.handlersFor(pureArgs[0]);\n                var targetRouteName = handlers[handlers.length - 1].handler;\n                return this.applyToHandlers(oldState, handlers, targetRouteName, isIntermediate, false);\n            }\n        }, {\n            key: 'applyToHandlers',\n            value: function applyToHandlers(oldState, parsedHandlers, targetRouteName, isIntermediate, checkingIfActive) {\n                var i = void 0,\n                    len = void 0;\n                var newState = new _transitionState2.default();\n                var objects = this.contexts.slice(0);\n                var invalidateIndex = parsedHandlers.length;\n                // Pivot handlers are provided for refresh transitions\n                if (this.pivotHandler) {\n                    for (i = 0, len = parsedHandlers.length; i < len; ++i) {\n                        if (parsedHandlers[i].handler === this.pivotHandler._internalName) {\n                            invalidateIndex = i;\n                            break;\n                        }\n                    }\n                }\n                for (i = parsedHandlers.length - 1; i >= 0; --i) {\n                    var result = parsedHandlers[i];\n                    var name = result.handler;\n                    var oldHandlerInfo = oldState.routeInfos[i];\n                    var newHandlerInfo = null;\n                    if (result.names.length > 0) {\n                        if (i >= invalidateIndex) {\n                            newHandlerInfo = this.createParamHandlerInfo(name, result.names, objects, oldHandlerInfo);\n                        } else {\n                            newHandlerInfo = this.getHandlerInfoForDynamicSegment(name, result.names, objects, oldHandlerInfo, targetRouteName, i);\n                        }\n                    } else {\n                        // This route has no dynamic segment.\n                        // Therefore treat as a param-based handlerInfo\n                        // with empty params. This will cause the `model`\n                        // hook to be called with empty params, which is desirable.\n                        newHandlerInfo = this.createParamHandlerInfo(name, result.names, objects, oldHandlerInfo);\n                    }\n                    if (checkingIfActive) {\n                        // If we're performing an isActive check, we want to\n                        // serialize URL params with the provided context, but\n                        // ignore mismatches between old and new context.\n                        newHandlerInfo = newHandlerInfo.becomeResolved(null, newHandlerInfo.context);\n                        var oldContext = oldHandlerInfo && oldHandlerInfo.context;\n                        if (result.names.length > 0 && oldHandlerInfo.context !== undefined && newHandlerInfo.context === oldContext) {\n                            // If contexts match in isActive test, assume params also match.\n                            // This allows for flexibility in not requiring that every last\n                            // handler provide a `serialize` method\n                            newHandlerInfo.params = oldHandlerInfo && oldHandlerInfo.params;\n                        }\n                        newHandlerInfo.context = oldContext;\n                    }\n                    var handlerToUse = oldHandlerInfo;\n                    if (i >= invalidateIndex || newHandlerInfo.shouldSupercede(oldHandlerInfo)) {\n                        invalidateIndex = Math.min(i, invalidateIndex);\n                        handlerToUse = newHandlerInfo;\n                    }\n                    if (isIntermediate && !checkingIfActive) {\n                        handlerToUse = handlerToUse.becomeResolved(null, handlerToUse.context);\n                    }\n                    newState.routeInfos.unshift(handlerToUse);\n                }\n                if (objects.length > 0) {\n                    throw new Error('More context objects were passed than there are dynamic segments for the route: ' + targetRouteName);\n                }\n                if (!isIntermediate) {\n                    this.invalidateChildren(newState.routeInfos, invalidateIndex);\n                }\n                (0, _utils.merge)(newState.queryParams, this.queryParams || {});\n                return newState;\n            }\n        }, {\n            key: 'invalidateChildren',\n            value: function invalidateChildren(handlerInfos, invalidateIndex) {\n                for (var i = invalidateIndex, l = handlerInfos.length; i < l; ++i) {\n                    var handlerInfo = handlerInfos[i];\n                    if (handlerInfo.isResolved) {\n                        var _handlerInfos$i = handlerInfos[i],\n                            name = _handlerInfos$i.name,\n                            params = _handlerInfos$i.params,\n                            route = _handlerInfos$i.route,\n                            paramNames = _handlerInfos$i.paramNames;\n\n                        handlerInfos[i] = new _routeInfo.UnresolvedRouteInfoByParam(this.router, name, paramNames, params, route);\n                    }\n                }\n            }\n        }, {\n            key: 'getHandlerInfoForDynamicSegment',\n            value: function getHandlerInfoForDynamicSegment(name, names, objects, oldHandlerInfo, _targetRouteName, i) {\n                var objectToUse = void 0;\n                if (objects.length > 0) {\n                    // Use the objects provided for this transition.\n                    objectToUse = objects[objects.length - 1];\n                    if ((0, _utils.isParam)(objectToUse)) {\n                        return this.createParamHandlerInfo(name, names, objects, oldHandlerInfo);\n                    } else {\n                        objects.pop();\n                    }\n                } else if (oldHandlerInfo && oldHandlerInfo.name === name) {\n                    // Reuse the matching oldHandlerInfo\n                    return oldHandlerInfo;\n                } else {\n                    if (this.preTransitionState) {\n                        var preTransitionHandlerInfo = this.preTransitionState.routeInfos[i];\n                        objectToUse = preTransitionHandlerInfo && preTransitionHandlerInfo.context;\n                    } else {\n                        // Ideally we should throw this error to provide maximal\n                        // information to the user that not enough context objects\n                        // were provided, but this proves too cumbersome in Ember\n                        // in cases where inner template helpers are evaluated\n                        // before parent helpers un-render, in which cases this\n                        // error somewhat prematurely fires.\n                        //throw new Error(\"Not enough context objects were provided to complete a transition to \" + targetRouteName + \". Specifically, the \" + name + \" route needs an object that can be serialized into its dynamic URL segments [\" + names.join(', ') + \"]\");\n                        return oldHandlerInfo;\n                    }\n                }\n                return new _routeInfo.UnresolvedRouteInfoByObject(this.router, name, names, objectToUse);\n            }\n        }, {\n            key: 'createParamHandlerInfo',\n            value: function createParamHandlerInfo(name, names, objects, oldHandlerInfo) {\n                var params = {};\n                // Soak up all the provided string/numbers\n                var numNames = names.length;\n                var missingParams = [];\n                while (numNames--) {\n                    // Only use old params if the names match with the new handler\n                    var oldParams = oldHandlerInfo && name === oldHandlerInfo.name && oldHandlerInfo.params || {};\n                    var peek = objects[objects.length - 1];\n                    var paramName = names[numNames];\n                    if ((0, _utils.isParam)(peek)) {\n                        params[paramName] = '' + objects.pop();\n                    } else {\n                        // If we're here, this means only some of the params\n                        // were string/number params, so try and use a param\n                        // value from a previous handler.\n                        if (oldParams.hasOwnProperty(paramName)) {\n                            params[paramName] = oldParams[paramName];\n                        } else {\n                            missingParams.push(paramName);\n                        }\n                    }\n                }\n                if (missingParams.length > 0) {\n                    throw new Error('You didn\\'t provide enough string/numeric parameters to satisfy all of the dynamic segments for route ' + name + '.' + (' Missing params: ' + missingParams));\n                }\n                return new _routeInfo.UnresolvedRouteInfoByParam(this.router, name, names, params);\n            }\n        }]);\n\n        return NamedTransitionIntent;\n    }(_transitionIntent.TransitionIntent);\n\n    exports.default = NamedTransitionIntent;\n});","define('lib/router/transition-intent/url-transition-intent', ['exports', 'lib/router/route-info', 'lib/router/transition-intent', 'lib/router/transition-state', 'lib/router/unrecognized-url-error', 'lib/router/utils'], function (exports, _routeInfo, _transitionIntent, _transitionState, _unrecognizedUrlError, _utils) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n\n    var _transitionState2 = _interopRequireDefault(_transitionState);\n\n    var _unrecognizedUrlError2 = _interopRequireDefault(_unrecognizedUrlError);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    function _possibleConstructorReturn(self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    var URLTransitionIntent = function (_TransitionIntent) {\n        _inherits(URLTransitionIntent, _TransitionIntent);\n\n        function URLTransitionIntent(router, url, data) {\n            _classCallCheck(this, URLTransitionIntent);\n\n            var _this = _possibleConstructorReturn(this, (URLTransitionIntent.__proto__ || Object.getPrototypeOf(URLTransitionIntent)).call(this, router, data));\n\n            _this.url = url;\n            _this.preTransitionState = undefined;\n            return _this;\n        }\n\n        _createClass(URLTransitionIntent, [{\n            key: 'applyToState',\n            value: function applyToState(oldState) {\n                var newState = new _transitionState2.default();\n                var results = this.router.recognizer.recognize(this.url),\n                    i = void 0,\n                    len = void 0;\n                if (!results) {\n                    throw new _unrecognizedUrlError2.default(this.url);\n                }\n                var statesDiffer = false;\n                var _url = this.url;\n                // Checks if a handler is accessible by URL. If it is not, an error is thrown.\n                // For the case where the handler is loaded asynchronously, the error will be\n                // thrown once it is loaded.\n                function checkHandlerAccessibility(handler) {\n                    if (handler && handler.inaccessibleByURL) {\n                        throw new _unrecognizedUrlError2.default(_url);\n                    }\n                    return handler;\n                }\n                for (i = 0, len = results.length; i < len; ++i) {\n                    var result = results[i];\n                    var name = result.handler;\n                    var paramNames = [];\n                    if (this.router.recognizer.hasRoute(name)) {\n                        paramNames = this.router.recognizer.handlersFor(name)[i].names;\n                    }\n                    var newRouteInfo = new _routeInfo.UnresolvedRouteInfoByParam(this.router, name, paramNames, result.params);\n                    var route = newRouteInfo.route;\n                    if (route) {\n                        checkHandlerAccessibility(route);\n                    } else {\n                        // If the hanlder is being loaded asynchronously, check if we can\n                        // access it after it has resolved\n                        newRouteInfo.routePromise = newRouteInfo.routePromise.then(checkHandlerAccessibility);\n                    }\n                    var oldRouteInfo = oldState.routeInfos[i];\n                    if (statesDiffer || newRouteInfo.shouldSupercede(oldRouteInfo)) {\n                        statesDiffer = true;\n                        newState.routeInfos[i] = newRouteInfo;\n                    } else {\n                        newState.routeInfos[i] = oldRouteInfo;\n                    }\n                }\n                (0, _utils.merge)(newState.queryParams, results.queryParams);\n                return newState;\n            }\n        }]);\n\n        return URLTransitionIntent;\n    }(_transitionIntent.TransitionIntent);\n\n    exports.default = URLTransitionIntent;\n});","define('lib/router/transition-state', ['exports', 'rsvp', 'lib/router/utils'], function (exports, _rsvp, _utils) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.TransitionError = undefined;\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    var TransitionState = function () {\n        function TransitionState() {\n            _classCallCheck(this, TransitionState);\n\n            this.routeInfos = [];\n            this.queryParams = {};\n            this.params = {};\n        }\n\n        _createClass(TransitionState, [{\n            key: 'promiseLabel',\n            value: function promiseLabel(label) {\n                var targetName = '';\n                (0, _utils.forEach)(this.routeInfos, function (routeInfo) {\n                    if (targetName !== '') {\n                        targetName += '.';\n                    }\n                    targetName += routeInfo.name;\n                    return true;\n                });\n                return (0, _utils.promiseLabel)(\"'\" + targetName + \"': \" + label);\n            }\n        }, {\n            key: 'resolve',\n            value: function resolve(shouldContinue, transition) {\n                // First, calculate params for this state. This is useful\n                // information to provide to the various route hooks.\n                var params = this.params;\n                (0, _utils.forEach)(this.routeInfos, function (routeInfo) {\n                    params[routeInfo.name] = routeInfo.params || {};\n                    return true;\n                });\n                transition.resolveIndex = 0;\n                var currentState = this;\n                var wasAborted = false;\n                // The prelude RSVP.resolve() asyncs us into the promise land.\n                return _rsvp.Promise.resolve(null, this.promiseLabel('Start transition')).then(resolveOneRouteInfo, null, this.promiseLabel('Resolve route')).catch(handleError, this.promiseLabel('Handle error'));\n                function innerShouldContinue() {\n                    return _rsvp.Promise.resolve(shouldContinue(), currentState.promiseLabel('Check if should continue')).catch(function (reason) {\n                        // We distinguish between errors that occurred\n                        // during resolution (e.g. before\"Model/model/afterModel),\n                        // and aborts due to a rejecting promise from shouldContinue().\n                        wasAborted = true;\n                        return _rsvp.Promise.reject(reason);\n                    }, currentState.promiseLabel('Handle abort'));\n                }\n                function handleError(error) {\n                    // This is the only possible\n                    // reject value of TransitionState#resolve\n                    var routeInfos = currentState.routeInfos;\n                    var errorHandlerIndex = transition.resolveIndex >= routeInfos.length ? routeInfos.length - 1 : transition.resolveIndex;\n                    return _rsvp.Promise.reject(new TransitionError(error, currentState.routeInfos[errorHandlerIndex].route, wasAborted, currentState));\n                }\n                function proceed(resolvedRouteInfo) {\n                    var wasAlreadyResolved = currentState.routeInfos[transition.resolveIndex].isResolved;\n                    // Swap the previously unresolved routeInfo with\n                    // the resolved routeInfo\n                    currentState.routeInfos[transition.resolveIndex++] = resolvedRouteInfo;\n                    if (!wasAlreadyResolved) {\n                        var route = resolvedRouteInfo.route;\n\n                        if (route !== undefined) {\n                            if (route.redirect) {\n                                route.redirect(resolvedRouteInfo.context, transition);\n                            }\n                        }\n                    }\n                    // Proceed after ensuring that the redirect hook\n                    // didn't abort this transition by transitioning elsewhere.\n                    return innerShouldContinue().then(resolveOneRouteInfo, null, currentState.promiseLabel('Resolve route'));\n                }\n                function resolveOneRouteInfo() {\n                    if (transition.resolveIndex === currentState.routeInfos.length) {\n                        // This is is the only possible\n                        // fulfill value of TransitionState#resolve\n                        return currentState;\n                    }\n                    var routeInfo = currentState.routeInfos[transition.resolveIndex];\n                    return routeInfo.resolve(innerShouldContinue, transition).then(proceed, null, currentState.promiseLabel('Proceed'));\n                }\n            }\n        }]);\n\n        return TransitionState;\n    }();\n\n    exports.default = TransitionState;\n\n    var TransitionError = exports.TransitionError = function TransitionError(error, route, wasAborted, state) {\n        _classCallCheck(this, TransitionError);\n\n        this.error = error;\n        this.route = route;\n        this.wasAborted = wasAborted;\n        this.state = state;\n    };\n});","define('lib/router/transition', ['exports', 'rsvp', 'lib/router/transition-aborted-error', 'lib/router/utils'], function (exports, _rsvp, _transitionAbortedError, _utils) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.QUERY_PARAMS_SYMBOL = exports.PARAMS_SYMBOL = exports.STATE_SYMBOL = undefined;\n    exports.logAbort = logAbort;\n    exports.isTransition = isTransition;\n    exports.prepareResult = prepareResult;\n\n    var _transitionAbortedError2 = _interopRequireDefault(_transitionAbortedError);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n    } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    var STATE_SYMBOL = exports.STATE_SYMBOL = '__STATE__-2619860001345920-3322w3';\n    var PARAMS_SYMBOL = exports.PARAMS_SYMBOL = '__PARAMS__-261986232992830203-23323';\n    var QUERY_PARAMS_SYMBOL = exports.QUERY_PARAMS_SYMBOL = '__QPS__-2619863929824844-32323';\n    /**\n      A Transition is a thennable (a promise-like object) that represents\n      an attempt to transition to another route. It can be aborted, either\n      explicitly via `abort` or by attempting another transition while a\n      previous one is still underway. An aborted transition can also\n      be `retry()`d later.\n    \n      @class Transition\n      @constructor\n      @param {Object} router\n      @param {Object} intent\n      @param {Object} state\n      @param {Object} error\n      @private\n     */\n\n    var Transition = function () {\n        function Transition(router, intent, state) {\n            var _this = this;\n\n            var error = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n            var previousTransition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n\n            _classCallCheck(this, Transition);\n\n            this.from = null;\n            this.to = undefined;\n            this.isAborted = false;\n            this.isActive = true;\n            this.urlMethod = 'update';\n            this.resolveIndex = 0;\n            this.queryParamsOnly = false;\n            this.isTransition = true;\n            this.isCausedByAbortingTransition = false;\n            this.isCausedByInitialTransition = false;\n            this.isCausedByAbortingReplaceTransition = false;\n            this._visibleQueryParams = {};\n            this[STATE_SYMBOL] = state || router.state;\n            this.intent = intent;\n            this.router = router;\n            this.data = intent && intent.data || {};\n            this.resolvedModels = {};\n            this[QUERY_PARAMS_SYMBOL] = {};\n            this.promise = undefined;\n            this.error = undefined;\n            this[PARAMS_SYMBOL] = {};\n            this.routeInfos = [];\n            this.targetName = undefined;\n            this.pivotHandler = undefined;\n            this.sequence = -1;\n            if (error) {\n                this.promise = _rsvp.Promise.reject(error);\n                this.error = error;\n                return;\n            }\n            // if you're doing multiple redirects, need the new transition to know if it\n            // is actually part of the first transition or not. Any further redirects\n            // in the initial transition also need to know if they are part of the\n            // initial transition\n            this.isCausedByAbortingTransition = !!previousTransition;\n            this.isCausedByInitialTransition = !!previousTransition && (previousTransition.isCausedByInitialTransition || previousTransition.sequence === 0);\n            // Every transition in the chain is a replace\n            this.isCausedByAbortingReplaceTransition = !!previousTransition && previousTransition.urlMethod === 'replace' && (!previousTransition.isCausedByAbortingTransition || previousTransition.isCausedByAbortingReplaceTransition);\n            if (state) {\n                this[PARAMS_SYMBOL] = state.params;\n                this[QUERY_PARAMS_SYMBOL] = state.queryParams;\n                this.routeInfos = state.routeInfos;\n                var len = state.routeInfos.length;\n                if (len) {\n                    this.targetName = state.routeInfos[len - 1].name;\n                }\n                for (var i = 0; i < len; ++i) {\n                    var handlerInfo = state.routeInfos[i];\n                    // TODO: this all seems hacky\n                    if (!handlerInfo.isResolved) {\n                        break;\n                    }\n                    this.pivotHandler = handlerInfo.route;\n                }\n                this.sequence = router.currentSequence++;\n                this.promise = state.resolve(function () {\n                    if (_this.isAborted) {\n                        return _rsvp.Promise.reject(false, (0, _utils.promiseLabel)('Transition aborted - reject'));\n                    }\n                    return _rsvp.Promise.resolve(true);\n                }, this).catch(function (result) {\n                    return _rsvp.Promise.reject(_this.router.transitionDidError(result, _this));\n                }, (0, _utils.promiseLabel)('Handle Abort'));\n            } else {\n                this.promise = _rsvp.Promise.resolve(this[STATE_SYMBOL]);\n                this[PARAMS_SYMBOL] = {};\n            }\n        }\n        /**\n          The Transition's internal promise. Calling `.then` on this property\n          is that same as calling `.then` on the Transition object itself, but\n          this property is exposed for when you want to pass around a\n          Transition's promise, but not the Transition object itself, since\n          Transition object can be externally `abort`ed, while the promise\n          cannot.\n             @property promise\n          @type {Object}\n          @public\n         */\n        /**\n          Custom state can be stored on a Transition's `data` object.\n          This can be useful for decorating a Transition within an earlier\n          hook and shared with a later hook. Properties set on `data` will\n          be copied to new transitions generated by calling `retry` on this\n          transition.\n             @property data\n          @type {Object}\n          @public\n         */\n        /**\n          A standard promise hook that resolves if the transition\n          succeeds and rejects if it fails/redirects/aborts.\n             Forwards to the internal `promise` property which you can\n          use in situations where you want to pass around a thennable,\n          but not the Transition itself.\n             @method then\n          @param {Function} onFulfilled\n          @param {Function} onRejected\n          @param {String} label optional string for labeling the promise.\n          Useful for tooling.\n          @return {Promise}\n          @public\n         */\n\n\n        _createClass(Transition, [{\n            key: 'then',\n            value: function then(onFulfilled, onRejected, label) {\n                return this.promise.then(onFulfilled, onRejected, label);\n            }\n        }, {\n            key: 'catch',\n            value: function _catch(onRejection, label) {\n                return this.promise.catch(onRejection, label);\n            }\n        }, {\n            key: 'finally',\n            value: function _finally(callback, label) {\n                return this.promise.finally(callback, label);\n            }\n        }, {\n            key: 'abort',\n            value: function abort() {\n                this.rollback();\n                var transition = new Transition(this.router, undefined, undefined, undefined);\n                transition.to = this.from;\n                transition.from = this.from;\n                transition.isAborted = true;\n                this.router.routeWillChange(transition);\n                this.router.routeDidChange(transition);\n                return this;\n            }\n        }, {\n            key: 'rollback',\n            value: function rollback() {\n                if (!this.isAborted) {\n                    (0, _utils.log)(this.router, this.sequence, this.targetName + ': transition was aborted');\n                    if (this.intent !== undefined && this.intent !== null) {\n                        this.intent.preTransitionState = this.router.state;\n                    }\n                    this.isAborted = true;\n                    this.isActive = false;\n                    this.router.activeTransition = undefined;\n                }\n            }\n        }, {\n            key: 'redirect',\n            value: function redirect(newTransition) {\n                this.rollback();\n                this.router.routeWillChange(newTransition);\n            }\n        }, {\n            key: 'retry',\n            value: function retry() {\n                // TODO: add tests for merged state retry()s\n                this.abort();\n                var newTransition = this.router.transitionByIntent(this.intent, false);\n                // inheriting a `null` urlMethod is not valid\n                // the urlMethod is only set to `null` when\n                // the transition is initiated *after* the url\n                // has been updated (i.e. `router.handleURL`)\n                //\n                // in that scenario, the url method cannot be\n                // inherited for a new transition because then\n                // the url would not update even though it should\n                if (this.urlMethod !== null) {\n                    newTransition.method(this.urlMethod);\n                }\n                return newTransition;\n            }\n        }, {\n            key: 'method',\n            value: function method(_method) {\n                this.urlMethod = _method;\n                return this;\n            }\n        }, {\n            key: 'send',\n            value: function send() {\n                var ignoreFailure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n                var _name = arguments[1];\n                var err = arguments[2];\n                var transition = arguments[3];\n                var handler = arguments[4];\n\n                this.trigger(ignoreFailure, _name, err, transition, handler);\n            }\n        }, {\n            key: 'trigger',\n            value: function trigger() {\n                var ignoreFailure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n                var name = arguments[1];\n\n                // TODO: Deprecate the current signature\n                if (typeof ignoreFailure === 'string') {\n                    name = ignoreFailure;\n                    ignoreFailure = false;\n                }\n\n                for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n                    args[_key - 2] = arguments[_key];\n                }\n\n                this.router.triggerEvent(this[STATE_SYMBOL].routeInfos.slice(0, this.resolveIndex + 1), ignoreFailure, name, args);\n            }\n        }, {\n            key: 'followRedirects',\n            value: function followRedirects() {\n                var router = this.router;\n                return this.promise.catch(function (reason) {\n                    if (router.activeTransition) {\n                        return router.activeTransition.followRedirects();\n                    }\n                    return _rsvp.Promise.reject(reason);\n                });\n            }\n        }, {\n            key: 'toString',\n            value: function toString() {\n                return 'Transition (sequence ' + this.sequence + ')';\n            }\n        }, {\n            key: 'log',\n            value: function log(message) {\n                (0, _utils.log)(this.router, this.sequence, message);\n            }\n        }]);\n\n        return Transition;\n    }();\n\n    exports.default = Transition;\n\n    /**\n      @private\n    \n      Logs and returns an instance of TransitionAborted.\n     */\n    function logAbort(transition) {\n        (0, _utils.log)(transition.router, transition.sequence, 'detected abort.');\n        return new _transitionAbortedError2.default();\n    }\n    function isTransition(obj) {\n        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj instanceof Transition && obj.isTransition;\n    }\n    function prepareResult(obj) {\n        if (isTransition(obj)) {\n            return null;\n        }\n        return obj;\n    }\n    //# sourceMappingURL=transition.js.map\n});","define('lib/router/unrecognized-url-error', ['exports'], function (exports) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    var UnrecognizedURLError = function () {\n        UnrecognizedURLError.prototype = Object.create(Error.prototype);\n        UnrecognizedURLError.prototype.constructor = UnrecognizedURLError;\n        function UnrecognizedURLError(message) {\n            var error = Error.call(this, message);\n            this.name = 'UnrecognizedURLError';\n            this.message = message || 'UnrecognizedURL';\n            if (Error.captureStackTrace) {\n                Error.captureStackTrace(this, UnrecognizedURLError);\n            } else {\n                this.stack = error.stack;\n            }\n        }\n        return UnrecognizedURLError;\n    }();\n    exports.default = UnrecognizedURLError;\n});","define('lib/router/utils', ['exports'], function (exports) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.isPromise = isPromise;\n    exports.merge = merge;\n    exports.extractQueryParams = extractQueryParams;\n    exports.coerceQueryParamsToString = coerceQueryParamsToString;\n    exports.log = log;\n    exports.isParam = isParam;\n    exports.forEach = forEach;\n    exports.getChangelist = getChangelist;\n    exports.promiseLabel = promiseLabel;\n\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n    } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    var slice = exports.slice = Array.prototype.slice;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    /**\n      Determines if an object is Promise by checking if it is \"thenable\".\n    **/\n    function isPromise(p) {\n        return p !== null && (typeof p === 'undefined' ? 'undefined' : _typeof(p)) === 'object' && typeof p.then === 'function';\n    }\n    function merge(hash, other) {\n        for (var prop in other) {\n            if (hasOwnProperty.call(other, prop)) {\n                hash[prop] = other[prop];\n            }\n        }\n    }\n    /**\n      @private\n    \n      Extracts query params from the end of an array\n    **/\n    function extractQueryParams(array) {\n        var len = array && array.length,\n            head = void 0,\n            queryParams = void 0;\n        if (len && len > 0) {\n            var obj = array[len - 1];\n            if (isQueryParams(obj)) {\n                queryParams = obj.queryParams;\n                head = slice.call(array, 0, len - 1);\n                return [head, queryParams];\n            }\n        }\n        return [array, null];\n    }\n    function isQueryParams(obj) {\n        return obj && hasOwnProperty.call(obj, 'queryParams');\n    }\n    /**\n      @private\n    \n      Coerces query param properties and array elements into strings.\n    **/\n    function coerceQueryParamsToString(queryParams) {\n        for (var key in queryParams) {\n            var val = queryParams[key];\n            if (typeof val === 'number') {\n                queryParams[key] = '' + val;\n            } else if (Array.isArray(val)) {\n                for (var i = 0, l = val.length; i < l; i++) {\n                    val[i] = '' + val[i];\n                }\n            }\n        }\n    }\n    /**\n      @private\n     */\n    function log(router) {\n        if (!router.log) {\n            return;\n        }\n\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n        }\n\n        if (args.length === 2) {\n            var sequence = args[0],\n                msg = args[1];\n\n            router.log('Transition #' + sequence + ': ' + msg);\n        } else {\n            var _msg = args[0];\n\n            router.log(_msg);\n        }\n    }\n    function isParam(object) {\n        return typeof object === 'string' || object instanceof String || typeof object === 'number' || object instanceof Number;\n    }\n    function forEach(array, callback) {\n        for (var i = 0, l = array.length; i < l && callback(array[i]) !== false; i++) {\n            // empty intentionally\n        }\n    }\n    function getChangelist(oldObject, newObject) {\n        var key = void 0;\n        var results = {\n            all: {},\n            changed: {},\n            removed: {}\n        };\n        merge(results.all, newObject);\n        var didChange = false;\n        coerceQueryParamsToString(oldObject);\n        coerceQueryParamsToString(newObject);\n        // Calculate removals\n        for (key in oldObject) {\n            if (hasOwnProperty.call(oldObject, key)) {\n                if (!hasOwnProperty.call(newObject, key)) {\n                    didChange = true;\n                    results.removed[key] = oldObject[key];\n                }\n            }\n        }\n        // Calculate changes\n        for (key in newObject) {\n            if (hasOwnProperty.call(newObject, key)) {\n                var oldElement = oldObject[key];\n                var newElement = newObject[key];\n                if (isArray(oldElement) && isArray(newElement)) {\n                    if (oldElement.length !== newElement.length) {\n                        results.changed[key] = newObject[key];\n                        didChange = true;\n                    } else {\n                        for (var i = 0, l = oldElement.length; i < l; i++) {\n                            if (oldElement[i] !== newElement[i]) {\n                                results.changed[key] = newObject[key];\n                                didChange = true;\n                            }\n                        }\n                    }\n                } else if (oldObject[key] !== newObject[key]) {\n                    results.changed[key] = newObject[key];\n                    didChange = true;\n                }\n            }\n        }\n        return didChange ? results : undefined;\n    }\n    function isArray(obj) {\n        return Array.isArray(obj);\n    }\n    function promiseLabel(label) {\n        return 'Router: ' + label;\n    }\n    //# sourceMappingURL=utils.js.map\n});","define('tests/async_get_handler_test', ['rsvp', 'tests/test_helpers'], function (_rsvp, _test_helpers) {\n    'use strict';\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    function _possibleConstructorReturn(self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    function map(router) {\n        router.map(function (match) {\n            match('/index').to('index');\n            match('/foo').to('foo', function (match) {\n                match('/').to('fooIndex');\n                match('/bar').to('fooBar');\n            });\n        });\n    }\n    // Intentionally use QUnit.module instead of module from test_helpers\n    // so that we avoid using Backburner to handle the async portions of\n    // the test suite\n    var routes = void 0;\n    var router = void 0;\n    QUnit.module('Async Get Handler', {\n        beforeEach: function beforeEach() {\n            QUnit.config.testTimeout = 60000;\n            routes = {};\n        },\n        afterEach: function afterEach() {\n            QUnit.config.testTimeout = 1000;\n        }\n    });\n    QUnit.test('can transition to lazily-resolved routes', function (assert) {\n        var done = assert.async();\n\n        var LazyRouter = function (_TestRouter) {\n            _inherits(LazyRouter, _TestRouter);\n\n            function LazyRouter() {\n                _classCallCheck(this, LazyRouter);\n\n                return _possibleConstructorReturn(this, (LazyRouter.__proto__ || Object.getPrototypeOf(LazyRouter)).apply(this, arguments));\n            }\n\n            _createClass(LazyRouter, [{\n                key: 'getRoute',\n                value: function getRoute(name) {\n                    return new _rsvp.Promise(function (resolve) {\n                        setTimeout(function () {\n                            resolve(routes[name] || (routes[name] = (0, _test_helpers.createHandler)('empty')));\n                        }, 1);\n                    });\n                }\n            }]);\n\n            return LazyRouter;\n        }(_test_helpers.TestRouter);\n\n        router = new LazyRouter();\n        map(router);\n        var fooCalled = false;\n        var fooBarCalled = false;\n        routes.foo = (0, _test_helpers.createHandler)('foo', {\n            model: function model() {\n                fooCalled = true;\n            }\n        });\n        routes.fooBar = (0, _test_helpers.createHandler)('fooBar', {\n            model: function model() {\n                fooBarCalled = true;\n            }\n        });\n        router.transitionTo('/foo/bar').then(function () {\n            assert.ok(fooCalled, 'foo is called before transition ends');\n            assert.ok(fooBarCalled, 'fooBar is called before transition ends');\n            done();\n        });\n        assert.ok(!fooCalled, 'foo is not called synchronously');\n        assert.ok(!fooBarCalled, 'fooBar is not called synchronously');\n    });\n    QUnit.test('calls hooks of lazily-resolved routes in order', function (assert) {\n        var done = assert.async();\n        var operations = [];\n\n        var LazyRouter = function (_TestRouter2) {\n            _inherits(LazyRouter, _TestRouter2);\n\n            function LazyRouter() {\n                _classCallCheck(this, LazyRouter);\n\n                return _possibleConstructorReturn(this, (LazyRouter.__proto__ || Object.getPrototypeOf(LazyRouter)).apply(this, arguments));\n            }\n\n            _createClass(LazyRouter, [{\n                key: 'getRoute',\n                value: function getRoute(name) {\n                    operations.push('get handler ' + name);\n                    return new _rsvp.Promise(function (resolve) {\n                        var timeoutLength = name === 'foo' ? 100 : 1;\n                        setTimeout(function () {\n                            operations.push('resolved ' + name);\n                            resolve(routes[name] || (routes[name] = (0, _test_helpers.createHandler)('empty')));\n                        }, timeoutLength);\n                    });\n                }\n            }]);\n\n            return LazyRouter;\n        }(_test_helpers.TestRouter);\n\n        router = new LazyRouter();\n        map(router);\n        routes.foo = (0, _test_helpers.createHandler)('foo', {\n            model: function model() {\n                operations.push('model foo');\n            }\n        });\n        routes.fooBar = (0, _test_helpers.createHandler)('fooBar', {\n            model: function model() {\n                operations.push('model fooBar');\n            }\n        });\n        router.transitionTo('/foo/bar').then(function () {\n            assert.deepEqual(operations, ['get handler foo', 'get handler fooBar', 'resolved fooBar', 'resolved foo', 'model foo', 'model fooBar'], 'order of operations is correct');\n            done();\n        }, null);\n    });\n    //# sourceMappingURL=async_get_handler_test.js.map\n});","define('tests/index', ['tests/async_get_handler_test', 'tests/handler_info_test', 'tests/query_params_test', 'tests/router_test', 'tests/transition-aborted-error_test', 'tests/transition_intent_test', 'tests/transition_state_test', 'tests/unrecognized-url-error_test', 'tests/utils_test'], function () {\n  'use strict';\n});","define('tests/query_params_test', ['rsvp', 'tests/test_helpers'], function (_rsvp, _test_helpers) {\n    'use strict';\n\n    function _toConsumableArray(arr) {\n        if (Array.isArray(arr)) {\n            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n                arr2[i] = arr[i];\n            }\n\n            return arr2;\n        } else {\n            return Array.from(arr);\n        }\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    function _possibleConstructorReturn(self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    var router = void 0,\n        handlers = void 0,\n        expectedUrl = void 0;\n    var scenarios = [{\n        name: 'Sync Get Handler',\n        getHandler: function getHandler(name) {\n            return handlers[name] || (handlers[name] = (0, _test_helpers.createHandler)('empty'));\n        }\n    }, {\n        name: 'Async Get Handler',\n        getHandler: function getHandler(name) {\n            return _rsvp.Promise.resolve(handlers[name] || (handlers[name] = (0, _test_helpers.createHandler)('empty')));\n        }\n    }];\n    scenarios.forEach(function (scenario) {\n        (0, _test_helpers.module)('Query Params (' + scenario.name + ')', {\n            setup: function setup(assert) {\n                handlers = {};\n                expectedUrl = undefined;\n                map(assert, function (match) {\n                    match('/index').to('index');\n                    match('/parent').to('parent', function (match) {\n                        match('/').to('parentIndex');\n                        match('/child').to('parentChild');\n                    });\n                });\n            }\n        });\n        function map(assert, fn) {\n            var QPRouter = function (_TestRouter) {\n                _inherits(QPRouter, _TestRouter);\n\n                function QPRouter() {\n                    _classCallCheck(this, QPRouter);\n\n                    return _possibleConstructorReturn(this, (QPRouter.__proto__ || Object.getPrototypeOf(QPRouter)).apply(this, arguments));\n                }\n\n                _createClass(QPRouter, [{\n                    key: 'routeDidChange',\n                    value: function routeDidChange() {}\n                }, {\n                    key: 'routeWillChange',\n                    value: function routeWillChange() {}\n                }, {\n                    key: 'didTransition',\n                    value: function didTransition() {}\n                }, {\n                    key: 'willTransition',\n                    value: function willTransition() {}\n                }, {\n                    key: 'triggerEvent',\n                    value: function triggerEvent(handlerInfos, ignoreFailure, name, args) {\n                        _test_helpers.trigger.apply(undefined, [handlerInfos, ignoreFailure, name].concat(_toConsumableArray(args)));\n                    }\n                }, {\n                    key: 'replaceURL',\n                    value: function replaceURL(name) {\n                        this.updateURL(name);\n                    }\n                }, {\n                    key: 'getRoute',\n                    value: function getRoute(name) {\n                        return scenario.getHandler(name);\n                    }\n                }, {\n                    key: 'getSerializer',\n                    value: function getSerializer() {\n                        throw new Error('never');\n                    }\n                }, {\n                    key: 'updateURL',\n                    value: function updateURL(newUrl) {\n                        if (expectedUrl) {\n                            assert.equal(newUrl, expectedUrl, 'The url is ' + newUrl + ' as expected');\n                        }\n                    }\n                }]);\n\n                return QPRouter;\n            }(_test_helpers.TestRouter);\n\n            router = new QPRouter();\n            router.map(fn);\n        }\n        function consumeAllFinalQueryParams(params, finalParams) {\n            for (var key in params) {\n                var value = params[key];\n                delete params[key];\n                finalParams.push({ key: key, value: value });\n            }\n            return true;\n        }\n        (0, _test_helpers.test)('a change in query params fires a queryParamsDidChange event', function (assert) {\n            assert.expect(7);\n            var count = 0;\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                setup: function setup() {\n                    assert.equal(count, 0, \"setup should be called exactly once since we're only changing query params after the first transition\");\n                },\n                events: {\n                    finalizeQueryParamChange: consumeAllFinalQueryParams,\n                    queryParamsDidChange: function queryParamsDidChange(changed, all) {\n                        switch (count) {\n                            case 0:\n                                assert.ok(false, \"shouldn't fire on first trans\");\n                                break;\n                            case 1:\n                                assert.deepEqual(changed, { foo: '5' });\n                                assert.deepEqual(all, { foo: '5' });\n                                break;\n                            case 2:\n                                assert.deepEqual(changed, { bar: '6' });\n                                assert.deepEqual(all, { foo: '5', bar: '6' });\n                                break;\n                            case 3:\n                                assert.deepEqual(changed, { foo: '8', bar: '9' });\n                                assert.deepEqual(all, { foo: '8', bar: '9' });\n                                break;\n                        }\n                    }\n                }\n            });\n            (0, _test_helpers.transitionTo)(router, '/index');\n            count = 1;\n            (0, _test_helpers.transitionTo)(router, '/index?foo=5');\n            count = 2;\n            (0, _test_helpers.transitionTo)(router, '/index?foo=5&bar=6');\n            count = 3;\n            (0, _test_helpers.transitionTo)(router, '/index?foo=8&bar=9');\n        });\n        (0, _test_helpers.test)('transitioning between routes fires a queryParamsDidChange event', function (assert) {\n            assert.expect(8);\n            var count = 0;\n            handlers.parent = (0, _test_helpers.createHandler)('parent', {\n                events: {\n                    finalizeQueryParamChange: consumeAllFinalQueryParams,\n                    queryParamsDidChange: function queryParamsDidChange(changed, all) {\n                        switch (count) {\n                            case 0:\n                                assert.ok(false, \"shouldn't fire on first trans\");\n                                break;\n                            case 1:\n                                assert.deepEqual(changed, { foo: '5' });\n                                assert.deepEqual(all, { foo: '5' });\n                                break;\n                            case 2:\n                                assert.deepEqual(changed, { bar: '6' });\n                                assert.deepEqual(all, { foo: '5', bar: '6' });\n                                break;\n                            case 3:\n                                assert.deepEqual(changed, { foo: '8', bar: '9' });\n                                assert.deepEqual(all, { foo: '8', bar: '9' });\n                                break;\n                            case 4:\n                                assert.deepEqual(changed, { foo: '10', bar: '11' });\n                                assert.deepEqual(all, { foo: '10', bar: '11' });\n                        }\n                    }\n                }\n            });\n            handlers.parentChild = (0, _test_helpers.createHandler)('parentChild', {\n                events: {\n                    finalizeQueryParamChange: function finalizeQueryParamChange() {\n                        // Do nothing since this handler isn't consuming the QPs\n                        return true;\n                    },\n                    queryParamsDidChange: function queryParamsDidChange() {\n                        return true;\n                    }\n                }\n            });\n            (0, _test_helpers.transitionTo)(router, '/parent/child');\n            count = 1;\n            (0, _test_helpers.transitionTo)(router, '/parent/child?foo=5');\n            count = 2;\n            (0, _test_helpers.transitionTo)(router, '/parent/child?foo=5&bar=6');\n            count = 3;\n            (0, _test_helpers.transitionTo)(router, '/parent/child?foo=8&bar=9');\n            count = 4;\n            (0, _test_helpers.transitionTo)(router, '/parent?foo=10&bar=11');\n        });\n        (0, _test_helpers.test)('Refreshing the route when changing only query params should correctly set queryParamsOnly', function (assert) {\n            assert.expect(16);\n            var initialTransition = true;\n            var expectReplace = void 0;\n            router.updateURL = function () {\n                assert.notOk(expectReplace, 'Expected replace but update was called');\n            };\n            router.replaceURL = function () {\n                assert.ok(expectReplace, 'Replace was called but update was expected');\n            };\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                events: {\n                    finalizeQueryParamChange: function finalizeQueryParamChange(_params, _finalParams, transition) {\n                        if (initialTransition) {\n                            assert.notOk(transition.queryParamsOnly, 'should not be query params only transition');\n                            initialTransition = false;\n                        } else {\n                            assert.ok(transition.queryParamsOnly, 'should be query params only transition');\n                        }\n                    },\n                    queryParamsDidChange: function queryParamsDidChange() {\n                        router.refresh();\n                    }\n                }\n            });\n            handlers.child = (0, _test_helpers.createHandler)('child', {\n                events: {\n                    finalizeQueryParamChange: function finalizeQueryParamChange(_params, _finalParams, transition) {\n                        assert.notOk(transition.queryParamsOnly, 'should be normal transition');\n                        return true;\n                    }\n                }\n            });\n            expectReplace = false;\n            var transition = (0, _test_helpers.transitionTo)(router, '/index');\n            assert.notOk(transition.queryParamsOnly, 'Initial transition is not query params only transition');\n            transition = (0, _test_helpers.transitionTo)(router, '/index?foo=123');\n            assert.ok(transition.queryParamsOnly, 'Second transition with updateURL intent is query params only');\n            expectReplace = true;\n            transition = router.replaceWith('/index?foo=456');\n            (0, _test_helpers.flushBackburner)();\n            assert.ok(transition.queryParamsOnly, 'Third transition with replaceURL intent is query params only');\n            expectReplace = false;\n            transition = (0, _test_helpers.transitionTo)(router, '/parent/child?foo=789');\n            assert.notOk(transition.queryParamsOnly, 'Fourth transition with transtionTo intent is not query params only');\n            transition = (0, _test_helpers.transitionTo)(router, '/parent/child?foo=901');\n            assert.ok(transition.queryParamsOnly, 'Firth transition with transtionTo intent is query params only');\n            transition = (0, _test_helpers.transitionTo)(router, '/index?foo=123');\n            assert.notOk(transition.queryParamsOnly, 'Firth transition with transtionTo intent is not query params only');\n        });\n        (0, _test_helpers.test)('a handler can opt into a full-on transition by calling refresh', function (assert) {\n            assert.expect(3);\n            var count = 0;\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                model: function model() {\n                    switch (count) {\n                        case 0:\n                            assert.ok(true, 'model called in initial transition');\n                            break;\n                        case 1:\n                            assert.ok(true, 'model called during refresh');\n                            break;\n                        case 2:\n                            assert.ok(true, 'model called during refresh w 2 QPs');\n                            break;\n                        default:\n                            assert.ok(false, \"shouldn't have been called for \" + count);\n                    }\n                },\n                events: {\n                    queryParamsDidChange: function queryParamsDidChange() {\n                        if (count === 0) {\n                            assert.ok(false, \"shouldn't fire on first trans\");\n                        } else {\n                            router.refresh(this);\n                        }\n                    },\n                    finalizeQueryParamChange: consumeAllFinalQueryParams\n                }\n            });\n            (0, _test_helpers.transitionTo)(router, '/index');\n            count = 1;\n            (0, _test_helpers.transitionTo)(router, '/index?foo=5');\n            count = 2;\n            (0, _test_helpers.transitionTo)(router, '/index?foo=5&wat=lol');\n        });\n        (0, _test_helpers.test)('at the end of a query param change a finalizeQueryParamChange event is fired', function (assert) {\n            assert.expect(5);\n            var eventHandled = false;\n            var count = 0;\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                setup: function setup() {\n                    assert.notOk(eventHandled, 'setup should happen before eventHandled');\n                },\n                events: {\n                    finalizeQueryParamChange: function finalizeQueryParamChange(all) {\n                        eventHandled = true;\n                        switch (count) {\n                            case 0:\n                                assert.deepEqual(all, {});\n                                break;\n                            case 1:\n                                assert.deepEqual(all, { foo: '5' });\n                                break;\n                            case 2:\n                                assert.deepEqual(all, { foo: '5', bar: '6' });\n                                break;\n                            case 3:\n                                assert.deepEqual(all, { foo: '8', bar: '9' });\n                                break;\n                        }\n                    }\n                }\n            });\n            (0, _test_helpers.transitionTo)(router, '/index');\n            count = 1;\n            (0, _test_helpers.transitionTo)(router, '/index?foo=5');\n            count = 2;\n            (0, _test_helpers.transitionTo)(router, '/index?foo=5&bar=6');\n            count = 3;\n            (0, _test_helpers.transitionTo)(router, '/index?foo=8&bar=9');\n        });\n        (0, _test_helpers.test)('failing to consume QPs in finalize event tells the router it no longer has those params', function (assert) {\n            assert.expect(2);\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                setup: function setup() {\n                    assert.ok(true, 'setup was entered');\n                }\n            });\n            (0, _test_helpers.transitionTo)(router, '/index?foo=8&bar=9');\n            assert.deepEqual(router.state.queryParams, {});\n        });\n        (0, _test_helpers.test)('consuming QPs in finalize event tells the router those params are active', function (assert) {\n            assert.expect(1);\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                events: {\n                    finalizeQueryParamChange: function finalizeQueryParamChange(params, finalParams) {\n                        finalParams.push({ key: 'foo', value: params.foo });\n                    }\n                }\n            });\n            (0, _test_helpers.transitionTo)(router, '/index?foo=8&bar=9');\n            assert.deepEqual(router.state.queryParams, { foo: '8' });\n        });\n        (0, _test_helpers.test)(\"can hide query params from URL if they're marked as visible=false in finalizeQueryParamChange\", function (assert) {\n            assert.expect(2);\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                events: {\n                    finalizeQueryParamChange: function finalizeQueryParamChange(params, finalParams) {\n                        finalParams.push({ key: 'foo', value: params.foo, visible: false });\n                        finalParams.push({ key: 'bar', value: params.bar });\n                    }\n                }\n            });\n            expectedUrl = '/index?bar=9';\n            (0, _test_helpers.transitionTo)(router, '/index?foo=8&bar=9');\n            assert.deepEqual(router.state.queryParams, { foo: '8', bar: '9' });\n        });\n        (0, _test_helpers.test)('transitionTo() works with single query param arg', function (assert) {\n            assert.expect(2);\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                events: {\n                    finalizeQueryParamChange: function finalizeQueryParamChange(params, finalParams) {\n                        finalParams.push({ key: 'foo', value: params.foo });\n                        finalParams.push({ key: 'bar', value: params.bar });\n                    }\n                }\n            });\n            (0, _test_helpers.transitionTo)(router, '/index?bar=9&foo=8');\n            assert.deepEqual(router.state.queryParams, { foo: '8', bar: '9' });\n            expectedUrl = '/index?foo=123';\n            (0, _test_helpers.transitionTo)(router, { queryParams: { foo: '123' } });\n        });\n        (0, _test_helpers.test)('handleURL will NOT follow up with a replace URL if query params are already in sync', function (assert) {\n            assert.expect(0);\n            router.replaceURL = function (url) {\n                assert.ok(false, \"query params are in sync, this replaceURL shouldn't happen: \" + url);\n            };\n            router.handleURL('/index');\n        });\n        (0, _test_helpers.test)('model hook receives queryParams', function (assert) {\n            assert.expect(1);\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                model: function model(params) {\n                    assert.deepEqual(params, { queryParams: { foo: '5' } });\n                }\n            });\n            (0, _test_helpers.transitionTo)(router, '/index?foo=5');\n        });\n        (0, _test_helpers.test)('can cause full transition by calling refresh within queryParamsDidChange', function (assert) {\n            assert.expect(5);\n            var modelCount = 0;\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                model: function model(params) {\n                    ++modelCount;\n                    if (modelCount === 1) {\n                        assert.deepEqual(params, { queryParams: { foo: '5' } });\n                    } else if (modelCount === 2) {\n                        assert.deepEqual(params, { queryParams: { foo: '6' } });\n                    }\n                },\n                events: {\n                    queryParamsDidChange: function queryParamsDidChange() {\n                        router.refresh(this);\n                    }\n                }\n            });\n            assert.equal(modelCount, 0);\n            (0, _test_helpers.transitionTo)(router, '/index?foo=5');\n            assert.equal(modelCount, 1);\n            (0, _test_helpers.transitionTo)(router, '/index?foo=6');\n            assert.equal(modelCount, 2);\n        });\n        (0, _test_helpers.test)('can retry a query-params refresh', function (assert) {\n            var causeRedirect = false;\n            map(assert, function (match) {\n                match('/index').to('index');\n                match('/login').to('login');\n            });\n            assert.expect(11);\n            var redirect = false;\n            var indexTransition = void 0;\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                model: function model(_params, transition) {\n                    if (redirect) {\n                        indexTransition = transition;\n                        router.transitionTo('login');\n                    }\n                },\n                setup: function setup() {\n                    assert.ok(true, 'index#setup');\n                },\n                events: {\n                    queryParamsDidChange: function queryParamsDidChange() {\n                        assert.ok(true, 'index#queryParamsDidChange');\n                        redirect = causeRedirect;\n                        router.refresh(this);\n                    },\n                    finalizeQueryParamChange: function finalizeQueryParamChange(params, finalParams) {\n                        finalParams.foo = params.foo; // TODO wat\n                        finalParams.push({ key: 'foo', value: params.foo });\n                    }\n                }\n            });\n            handlers.login = (0, _test_helpers.createHandler)('login', {\n                setup: function setup() {\n                    assert.ok(true, 'login#setup');\n                }\n            });\n            expectedUrl = '/index?foo=abc';\n            (0, _test_helpers.transitionTo)(router, '/index?foo=abc');\n            causeRedirect = true;\n            expectedUrl = '/login';\n            (0, _test_helpers.transitionTo)(router, '/index?foo=def');\n            (0, _test_helpers.flushBackburner)();\n            causeRedirect = false;\n            redirect = false;\n            assert.ok(indexTransition, 'index transition was saved');\n            indexTransition.retry();\n            expectedUrl = '/index?foo=def';\n        });\n        (0, _test_helpers.test)('tests whether query params to transitionTo are considered active', function (assert) {\n            assert.expect(6);\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                events: {\n                    finalizeQueryParamChange: function finalizeQueryParamChange(params, finalParams) {\n                        finalParams.push({ key: 'foo', value: params.foo });\n                        finalParams.push({ key: 'bar', value: params.bar });\n                    }\n                }\n            });\n            (0, _test_helpers.transitionTo)(router, '/index?foo=8&bar=9');\n            assert.deepEqual(router.state.queryParams, { foo: '8', bar: '9' });\n            assert.ok(router.isActive('index', { queryParams: { foo: '8', bar: '9' } }), 'The index handler is active');\n            assert.ok(router.isActive('index', { queryParams: { foo: 8, bar: 9 } }), 'Works when property is number');\n            assert.notOk(router.isActive('index', { queryParams: { foo: '9' } }), 'Only supply one changed query param');\n            assert.notOk(router.isActive('index', {\n                queryParams: { foo: '8', bar: '10', baz: '11' }\n            }), 'A new query param was added');\n            assert.notOk(router.isActive('index', { queryParams: { foo: '8', bar: '11' } }), 'A query param changed');\n        });\n        (0, _test_helpers.test)('tests whether array query params to transitionTo are considered active', function (assert) {\n            assert.expect(7);\n            handlers.index = (0, _test_helpers.createHandler)('index', {\n                events: {\n                    finalizeQueryParamChange: function finalizeQueryParamChange(params, finalParams) {\n                        finalParams.push({ key: 'foo', value: params.foo });\n                    }\n                }\n            });\n            (0, _test_helpers.transitionTo)(router, '/index?foo[]=1&foo[]=2');\n            assert.deepEqual(router.state.queryParams, { foo: ['1', '2'] });\n            assert.ok(router.isActive('index', { queryParams: { foo: ['1', '2'] } }), 'The index handler is active');\n            assert.ok(router.isActive('index', { queryParams: { foo: [1, 2] } }), 'Works when array has numeric elements');\n            assert.notOk(router.isActive('index', { queryParams: { foo: ['2', '1'] } }), 'Change order');\n            assert.notOk(router.isActive('index', { queryParams: { foo: ['1', '2', '3'] } }), 'Change Length');\n            assert.notOk(router.isActive('index', { queryParams: { foo: ['3', '4'] } }), 'Change Content');\n            assert.notOk(router.isActive('index', { queryParams: { foo: [] } }), 'Empty Array');\n        });\n    });\n    //# sourceMappingURL=query_params_test.js.map\n});","define('tests/router_test', ['router/transition', 'rsvp', 'tests/test_helpers'], function (_transition2, _rsvp, _test_helpers) {\n    'use strict';\n\n    function _toConsumableArray(arr) {\n        if (Array.isArray(arr)) {\n            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n                arr2[i] = arr[i];\n            }\n\n            return arr2;\n        } else {\n            return Array.from(arr);\n        }\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    function _possibleConstructorReturn(self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    var router = void 0;\n    var url = void 0;\n    var routes = void 0;\n    function isPresent(maybe) {\n        return maybe !== undefined && maybe !== null;\n    }\n    var serializers = void 0,\n        expectedUrl = void 0;\n    var scenarios = [{\n        name: 'Sync Get Handler',\n        async: false,\n        getRoute: function getRoute(name) {\n            return routes[name] || (routes[name] = (0, _test_helpers.createHandler)('empty'));\n        },\n        getSerializer: function getSerializer(_name) {\n            return undefined;\n        }\n    }, {\n        name: 'Async Get Handler',\n        async: true,\n        getRoute: function getRoute(name) {\n            // Treat 'loading' route transitions are synchronous\n            var handler = routes[name] || (routes[name] = (0, _test_helpers.createHandler)('empty'));\n            return name === 'loading' ? handler : _rsvp.Promise.resolve(handler);\n        },\n        getSerializer: function getSerializer(name) {\n            return serializers && serializers[name];\n        }\n    }];\n    scenarios.forEach(function (scenario) {\n        (0, _test_helpers.module)('The router (' + scenario.name + ')', {\n            setup: function setup(assert) {\n                routes = {};\n                expectedUrl = undefined;\n                url = undefined;\n                map(assert, function (match) {\n                    match('/index').to('index');\n                    match('/about').to('about');\n                    match('/faq').to('faq');\n                    match('/nested').to('nestedParent', function (match) {\n                        match('/').to('nestedChild');\n                    });\n                    match('/posts', function (match) {\n                        match('/:id').to('showPost');\n                        match('/:postId/:commentId').to('showComment');\n                        match('/on/:date').to('showPostsForDate');\n                        match('/admin/:id').to('admin', function (match) {\n                            match('/posts').to('adminPosts');\n                            match('/posts/:post_id').to('adminPost');\n                        });\n                        match('/').to('postIndex', function (match) {\n                            match('/all').to('showAllPosts');\n                            // TODO: Support canonical: true\n                            match('/').to('showAllPosts');\n                            match('/popular').to('showPopularPosts');\n                            match('/filter/:filter_id').to('showFilteredPosts');\n                        });\n                    });\n                });\n            }\n        });\n        function map(assert, fn) {\n            var Router = function (_TestRouter) {\n                _inherits(Router, _TestRouter);\n\n                function Router() {\n                    _classCallCheck(this, Router);\n\n                    return _possibleConstructorReturn(this, (Router.__proto__ || Object.getPrototypeOf(Router)).apply(this, arguments));\n                }\n\n                _createClass(Router, [{\n                    key: 'routeDidChange',\n                    value: function routeDidChange() {}\n                }, {\n                    key: 'routeWillChange',\n                    value: function routeWillChange() {}\n                }, {\n                    key: 'didTransition',\n                    value: function didTransition() {}\n                }, {\n                    key: 'willTransition',\n                    value: function willTransition() {}\n                }, {\n                    key: 'replaceURL',\n                    value: function replaceURL(name) {\n                        this.updateURL(name);\n                    }\n                }, {\n                    key: 'triggerEvent',\n                    value: function triggerEvent(handlerInfos, ignoreFailure, name, args) {\n                        _test_helpers.trigger.apply(undefined, [handlerInfos, ignoreFailure, name].concat(_toConsumableArray(args)));\n                    }\n                }, {\n                    key: 'getRoute',\n                    value: function getRoute(name) {\n                        return scenario.getRoute(name);\n                    }\n                }, {\n                    key: 'getSerializer',\n                    value: function getSerializer(name) {\n                        return scenario.getSerializer(name);\n                    }\n                }, {\n                    key: 'updateURL',\n                    value: function updateURL(newUrl) {\n                        if (expectedUrl) {\n                            assert.equal(newUrl, expectedUrl, 'The url is ' + newUrl + ' as expected');\n                        }\n                        url = newUrl;\n                    }\n                }]);\n\n                return Router;\n            }(_test_helpers.TestRouter);\n\n            router = new Router();\n            router.map(fn);\n        }\n        (0, _test_helpers.test)('Mapping adds named routes to the end', function (assert) {\n            url = router.recognizer.generate('showPost', { id: 1 });\n            assert.equal(url, '/posts/1');\n            url = router.recognizer.generate('showAllPosts');\n            assert.equal(url, '/posts');\n            url = router.recognizer.generate('showComment', {\n                postId: 1,\n                commentId: 2\n            });\n            assert.equal(url, '/posts/1/2');\n            url = router.generate('showComment', 1, 2);\n            assert.equal(url, '/posts/1/2');\n        });\n        (0, _test_helpers.test)('Handling an invalid URL returns a rejecting promise', function (assert) {\n            router.handleURL('/unknown').then((0, _test_helpers.shouldNotHappen)(assert), function (e) {\n                assert.equal(e.name, 'UnrecognizedURLError', 'error.name is UnrecognizedURLError');\n            });\n        });\n        function routePath(infos) {\n            var path = [];\n            for (var i = 0, l = infos.length; i < l; i++) {\n                path.push(infos[i].name);\n            }\n            return path.join('.');\n        }\n        (0, _test_helpers.test)('Handling a URL triggers model on the handler and passes the result into the setup method', function (assert) {\n            assert.expect(4);\n            var post = { post: true };\n            routes = {\n                showPost: (0, _test_helpers.createHandler)('showPost', {\n                    model: function model(params) {\n                        assert.deepEqual(params, { id: '1', queryParams: {} }, 'showPost#model called with id 1');\n                        return post;\n                    },\n                    setup: function setup(object) {\n                        assert.strictEqual(object, post, 'setup was called with expected model');\n                        assert.equal(routes.showPost.context, post, 'context was properly set on showPost handler');\n                    }\n                })\n            };\n            router.didTransition = function (infos) {\n                assert.equal(routePath(infos), 'showPost');\n            };\n            router.handleURL('/posts/1');\n        });\n        (0, _test_helpers.test)('isActive should not break on initial intermediate route', function (assert) {\n            assert.expect(1);\n            router.intermediateTransitionTo('/posts/admin/1/posts');\n            assert.ok(router.isActive('admin', '1'));\n        });\n        (0, _test_helpers.test)('Handling a URL passes in query params', function (assert) {\n            assert.expect(3);\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    model: function model(_params, transition) {\n                        assert.deepEqual(transition[_transition2.QUERY_PARAMS_SYMBOL], {\n                            sort: 'date',\n                            filter: 'true'\n                        });\n                    },\n                    events: {\n                        finalizeQueryParamChange: function finalizeQueryParamChange(params, finalParams) {\n                            assert.ok(true, 'finalizeQueryParamChange');\n                            // need to consume the params so that the router\n                            // knows that they're active\n                            finalParams.push({ key: 'sort', value: params.sort });\n                            finalParams.push({ key: 'filter', value: params.filter });\n                        }\n                    }\n                })\n            };\n            router.handleURL('/index?sort=date&filter');\n            (0, _test_helpers.flushBackburner)();\n            assert.deepEqual(router.state.queryParams, {\n                sort: 'date',\n                filter: 'true'\n            });\n        });\n        (0, _test_helpers.test)('handleURL accepts slash-less URLs', function (assert) {\n            assert.expect(1);\n            routes = {\n                showAllPosts: (0, _test_helpers.createHandler)('showAllPosts', {\n                    setup: function setup() {\n                        assert.ok(true, \"showAllPosts' setup called\");\n                    }\n                })\n            };\n            router.handleURL('posts/all');\n        });\n        (0, _test_helpers.test)('handleURL accepts query params', function (assert) {\n            assert.expect(1);\n            routes = {\n                showAllPosts: (0, _test_helpers.createHandler)('showAllPosts', {\n                    setup: function setup() {\n                        assert.ok(true, \"showAllPosts' setup called\");\n                    }\n                })\n            };\n            router.handleURL('/posts/all?sort=name&sortDirection=descending');\n        });\n        (0, _test_helpers.test)(\"redirect hook shouldn't get called on parent routes\", function (assert) {\n            map(assert, function (match) {\n                match('/').to('app', function (match) {\n                    match('/').to('index');\n                    match('/other').to('other');\n                });\n            });\n            var appRedirects = 0;\n            routes = {\n                app: (0, _test_helpers.createHandler)('app', {\n                    redirect: function redirect() {\n                        appRedirects++;\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, '/');\n            assert.equal(appRedirects, 1);\n            (0, _test_helpers.transitionTo)(router, 'other');\n            assert.equal(appRedirects, 1);\n        });\n        (0, _test_helpers.test)('when transitioning with the same context, setup should only be called once', function (assert) {\n            var parentSetupCount = 0,\n                childSetupCount = 0;\n            var context = { id: 1 };\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts/:id').to('post', function (match) {\n                    match('/details').to('postDetails');\n                });\n            });\n            routes = {\n                post: (0, _test_helpers.createHandler)('post', {\n                    setup: function setup() {\n                        parentSetupCount++;\n                    }\n                }),\n                postDetails: (0, _test_helpers.createHandler)('postDetails', {\n                    setup: function setup() {\n                        childSetupCount++;\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, '/');\n            assert.equal(parentSetupCount, 0, 'precondition - parent not setup');\n            assert.equal(childSetupCount, 0, 'precondition - child not setup');\n            (0, _test_helpers.transitionTo)(router, 'postDetails', context);\n            assert.equal(parentSetupCount, 1, 'after initial transition parent is setup once');\n            assert.equal(childSetupCount, 1, 'after initial transition child is setup once');\n            (0, _test_helpers.transitionTo)(router, 'postDetails', context);\n            assert.equal(parentSetupCount, 1, 'after duplicate transition, parent is still setup once');\n            assert.equal(childSetupCount, 1, 'after duplicate transition, child is still setup once');\n        });\n        (0, _test_helpers.test)('basic route change events', function (assert) {\n            assert.expect(11);\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts/:id').to('post', function (match) {\n                    match('/details').to('postDetails');\n                });\n            });\n            var enteredWillChange = 0;\n            var enteredDidChange = 0;\n            routes = {\n                post: (0, _test_helpers.createHandler)('post', {\n                    model: function model() {\n                        return { title: 'The Title' };\n                    }\n                }),\n                postDetails: (0, _test_helpers.createHandler)('postDetails', {\n                    model: function model() {\n                        return { body: 'The Content' };\n                    }\n                })\n            };\n            router.routeWillChange = function (transition) {\n                enteredWillChange++;\n                if (isPresent(transition.to)) {\n                    assert.equal(transition.to.localName, 'postDetails');\n                    assert.equal(transition.from, null);\n                    assert.equal(transition.to.parent.localName, 'post');\n                    assert.equal(transition.to.attributes, undefined);\n                }\n            };\n            router.routeDidChange = function (transition) {\n                enteredDidChange++;\n                var to = transition.to;\n                if (isPresent(transition.to)) {\n                    assert.equal(to.localName, 'postDetails');\n                    assert.equal(transition.from, null);\n                    assert.equal(to.parent.localName, 'post');\n                    assert.deepEqual(to.attributes, { body: 'The Content' });\n                    assert.deepEqual(to.parent.attributes, {\n                        title: 'The Title'\n                    });\n                }\n            };\n            router.transitionTo('/posts/1/details').then(function () {\n                assert.equal(enteredWillChange, 1);\n                assert.equal(enteredDidChange, 1);\n            });\n        });\n        (0, _test_helpers.test)('basic events with route metadata', function (assert) {\n            assert.expect(10);\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/profile').to('profile');\n                match('/posts/:id').to('post', function (match) {\n                    match('/details').to('postDetails');\n                });\n            });\n            routes = {\n                post: (0, _test_helpers.createHandler)('post', {\n                    buildRouteInfoMetadata: function buildRouteInfoMetadata() {\n                        return 'post-page';\n                    },\n                    model: function model() {\n                        return { title: 'The Title' };\n                    }\n                }),\n                profile: (0, _test_helpers.createHandler)('profile', {\n                    buildRouteInfoMetadata: function buildRouteInfoMetadata() {\n                        return 'profile-page';\n                    }\n                }),\n                postDetails: (0, _test_helpers.createHandler)('postDetails', {\n                    buildRouteInfoMetadata: function buildRouteInfoMetadata() {\n                        return 'post-details-page';\n                    },\n                    model: function model() {\n                        return { body: 'The Content' };\n                    }\n                })\n            };\n            router.routeWillChange = function (transition) {\n                if (!isPresent(transition.from) && isPresent(transition.to)) {\n                    if (scenario.async) {\n                        assert.equal(transition.to.metadata, null, 'initial to leaf');\n                        assert.equal(transition.to.parent.metadata, null, 'initial to leaf');\n                    } else {\n                        assert.equal(transition.to.metadata, 'post-details-page');\n                        assert.equal(transition.to.parent.metadata, 'post-page');\n                    }\n                }\n                if (isPresent(transition.from) && isPresent(transition.to)) {\n                    if (scenario.async) {\n                        assert.equal(transition.from.metadata, 'post-details-page', 'from leaf');\n                        assert.equal(transition.from.parent.metadata, 'post-page', 'from parent');\n                        assert.equal(transition.to.metadata, null, 'to leaf');\n                    } else {\n                        assert.equal(transition.from.metadata, 'post-details-page');\n                        assert.equal(transition.from.parent.metadata, 'post-page');\n                        assert.equal(transition.to.metadata, 'profile-page');\n                    }\n                }\n            };\n            router.routeDidChange = function (transition) {\n                if (!isPresent(transition.from) && isPresent(transition.to)) {\n                    assert.equal(transition.to.metadata, 'post-details-page', 'initial to leaf');\n                    assert.equal(transition.to.parent.metadata, 'post-page', 'initial to parent');\n                }\n                if (isPresent(transition.from) && isPresent(transition.to)) {\n                    assert.equal(transition.from.metadata, 'post-details-page', 'from: /profile visited');\n                    assert.equal(transition.from.parent.metadata, 'post-page', 'from: /profile visited parent');\n                    assert.equal(transition.to.metadata, 'profile-page', 'to: /profile');\n                }\n            };\n            router.transitionTo('/posts/1/details').then(function () {\n                return router.transitionTo('/profile');\n            });\n        });\n        (0, _test_helpers.test)('basic route change events with replacement', function (assert) {\n            assert.expect(14);\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts/:id').to('post', function (match) {\n                    match('/details').to('postDetails');\n                });\n                match('/post-details/:id').to('canonicalPostDetails');\n            });\n            var enteredWillChange = 0;\n            var enteredDidChange = 0;\n            routes = {\n                post: (0, _test_helpers.createHandler)('post'),\n                postDetails: (0, _test_helpers.createHandler)('postDetails'),\n                canonicalPostDetails: (0, _test_helpers.createHandler)('canonicalPostDetails')\n            };\n            var replacement = false;\n            router.routeWillChange = function (transition) {\n                enteredWillChange++;\n                if (isPresent(transition.to)) {\n                    if (replacement) {\n                        assert.equal(transition.to.localName, 'canonicalPostDetails');\n                        assert.equal(isPresent(transition.from) && transition.from.localName, 'postDetails');\n                        assert.equal(transition.to.parent, null);\n                    } else {\n                        assert.equal(transition.to.localName, 'postDetails');\n                        assert.equal(transition.from, null);\n                        assert.equal(transition.to.parent.localName, 'post');\n                    }\n                }\n            };\n            router.routeDidChange = function (transition) {\n                enteredDidChange++;\n                if (isPresent(transition.to)) {\n                    if (replacement) {\n                        assert.equal(transition.to.localName, 'canonicalPostDetails');\n                        assert.equal(isPresent(transition.from) && transition.from.localName, 'postDetails');\n                        assert.equal(transition.to.parent, null);\n                    } else {\n                        assert.equal(transition.to.localName, 'postDetails');\n                        assert.equal(transition.from, null);\n                        assert.equal(transition.to.parent.localName, 'post');\n                    }\n                }\n            };\n            router.transitionTo('/posts/1/details').then(function () {\n                replacement = true;\n                return router.replaceWith('/post-details/1');\n            }).then(function () {\n                assert.equal(enteredWillChange, 2);\n                assert.equal(enteredDidChange, 2);\n            });\n        });\n        (0, _test_helpers.test)('basic route change events with nested replacement', function (assert) {\n            assert.expect(12);\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts/:id').to('post', function (match) {\n                    match('/details').to('postDetails');\n                });\n                match('/post-details/:id').to('canonicalPostDetails');\n            });\n            var enteredWillChange = 0;\n            var enteredDidChange = 0;\n            routes = {\n                post: (0, _test_helpers.createHandler)('post'),\n                postDetails: (0, _test_helpers.createHandler)('postDetails', {\n                    model: function model() {\n                        router.replaceWith('/post-details/1');\n                        replacement = true;\n                    }\n                }),\n                canonicalPostDetails: (0, _test_helpers.createHandler)('canonicalPostDetails')\n            };\n            var replacement = false;\n            router.routeWillChange = function (transition) {\n                enteredWillChange++;\n                if (isPresent(transition.to)) {\n                    if (replacement) {\n                        assert.equal(transition.to.localName, 'canonicalPostDetails');\n                        assert.equal(transition.from, null);\n                        assert.equal(transition.to.parent, null);\n                    } else {\n                        assert.equal(transition.to.localName, 'postDetails');\n                        assert.equal(transition.from, null);\n                        assert.equal(transition.to.parent.localName, 'post');\n                        replacement = true;\n                    }\n                }\n            };\n            router.routeDidChange = function (transition) {\n                enteredDidChange++;\n                assert.equal(transition.to.localName, 'canonicalPostDetails');\n                assert.equal(transition.from, null);\n                assert.equal(transition.to.parent, null);\n            };\n            router.transitionTo('/posts/1/details').catch(function (err) {\n                assert.equal(err.name, 'TransitionAborted');\n                return router.activeTransition;\n            }).then(function () {\n                assert.equal(enteredWillChange, 2);\n                assert.equal(enteredDidChange, 1);\n            });\n        });\n        (0, _test_helpers.test)('basic route change events with params', function (assert) {\n            assert.expect(26);\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts/:id').to('post');\n            });\n            var enteredWillChange = 0;\n            var enteredDidChange = 0;\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    model: function model() {\n                        return _rsvp.Promise.resolve('Index');\n                    }\n                }),\n                post: (0, _test_helpers.createHandler)('post', {\n                    model: function model(params) {\n                        return _rsvp.Promise.resolve(params.id);\n                    }\n                })\n            };\n            var newParam = false;\n            router.routeWillChange = function (transition) {\n                enteredWillChange++;\n                assert.deepEqual(transition.to.paramNames, ['id']);\n                if (newParam) {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'post');\n                    assert.deepEqual(isPresent(transition.from) && transition.from.attributes, '1');\n                    assert.deepEqual(transition.to.params, { id: '2' });\n                    assert.equal(url, '/posts/1');\n                } else {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(transition.from, null);\n                    assert.notOk(url);\n                    assert.deepEqual(transition.to.params, { id: '1' });\n                }\n            };\n            router.routeDidChange = function (transition) {\n                enteredDidChange++;\n                var to = transition.to;\n                assert.deepEqual(transition.to.paramNames, ['id']);\n                if (newParam) {\n                    assert.equal(to.localName, 'post');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'post');\n                    assert.deepEqual(to.params, { id: '2' });\n                    assert.deepEqual(to.attributes, '2');\n                    assert.deepEqual(isPresent(transition.from) && transition.from.attributes, '1');\n                    assert.equal(url, '/posts/2');\n                } else {\n                    assert.equal(to.localName, 'post');\n                    assert.equal(transition.from, null);\n                    assert.equal(url, '/posts/1');\n                    assert.deepEqual(to.params, { id: '1' });\n                    assert.deepEqual(to.attributes, '1');\n                }\n            };\n            router.transitionTo('/posts/1').then(function () {\n                newParam = true;\n                return router.transitionTo('/posts/2');\n            }).then(function () {\n                assert.equal(enteredWillChange, 2);\n                assert.equal(enteredDidChange, 2);\n            });\n        });\n        (0, _test_helpers.test)('top-level recognizeAndLoad url', function (assert) {\n            map(assert, function (match) {\n                match('/').to('index');\n            });\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    model: function model() {\n                        return { name: 'index', data: 1 };\n                    }\n                })\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            router.recognizeAndLoad('/').then(function (routeInfoWithAttributes) {\n                assert.notOk(router.activeTransition, 'Does not create an active transition');\n                if (routeInfoWithAttributes === null) {\n                    assert.ok(false);\n                    return;\n                }\n                assert.equal(routeInfoWithAttributes.name, 'index');\n                assert.equal(routeInfoWithAttributes.localName, 'index');\n                assert.equal(routeInfoWithAttributes.parent, null);\n                assert.equal(routeInfoWithAttributes.child, null);\n                assert.deepEqual(routeInfoWithAttributes.attributes, { name: 'index', data: 1 });\n                assert.deepEqual(routeInfoWithAttributes.queryParams, {});\n                assert.deepEqual(routeInfoWithAttributes.params, {});\n                assert.deepEqual(routeInfoWithAttributes.paramNames, []);\n            });\n        });\n        (0, _test_helpers.test)('top-level parameterized recognizeAndLoad', function (assert) {\n            map(assert, function (match) {\n                match('/posts/:id').to('posts');\n            });\n            routes = {\n                posts: (0, _test_helpers.createHandler)('posts', {\n                    model: function model(params) {\n                        return { name: 'posts', data: params.id };\n                    }\n                })\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            router.recognizeAndLoad('/posts/123').then(function (routeInfoWithAttributes) {\n                assert.notOk(router.activeTransition, 'Does not create an active transition');\n                if (routeInfoWithAttributes === null) {\n                    assert.ok(false);\n                    return;\n                }\n                assert.equal(routeInfoWithAttributes.name, 'posts');\n                assert.equal(routeInfoWithAttributes.localName, 'posts');\n                assert.equal(routeInfoWithAttributes.parent, null);\n                assert.equal(routeInfoWithAttributes.child, null);\n                assert.deepEqual(routeInfoWithAttributes.attributes, { name: 'posts', data: '123' });\n                assert.deepEqual(routeInfoWithAttributes.queryParams, {});\n                assert.deepEqual(routeInfoWithAttributes.params, { id: '123' });\n                assert.deepEqual(routeInfoWithAttributes.paramNames, ['id']);\n            });\n        });\n        (0, _test_helpers.test)('nested recognizeAndLoad', function (assert) {\n            routes = {\n                postIndex: (0, _test_helpers.createHandler)('postIndex'),\n                showPopularPosts: (0, _test_helpers.createHandler)('showPopularPosts', {\n                    model: function model() {\n                        return { name: 'showPopularPosts', data: 123 };\n                    }\n                })\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            router.recognizeAndLoad('/posts/popular').then(function (routeInfoWithAttributes) {\n                assert.notOk(router.activeTransition, 'Does not create an active transition');\n                if (routeInfoWithAttributes === null) {\n                    assert.ok(false);\n                    return;\n                }\n                assert.equal(routeInfoWithAttributes.name, 'showPopularPosts');\n                assert.equal(routeInfoWithAttributes.localName, 'showPopularPosts');\n                assert.equal(routeInfoWithAttributes.parent.name, 'postIndex');\n                assert.equal(routeInfoWithAttributes.child, null);\n                assert.deepEqual(routeInfoWithAttributes.attributes, {\n                    name: 'showPopularPosts',\n                    data: 123\n                });\n                assert.deepEqual(routeInfoWithAttributes.queryParams, {});\n                assert.deepEqual(routeInfoWithAttributes.params, {});\n                assert.deepEqual(routeInfoWithAttributes.paramNames, []);\n            });\n        });\n        (0, _test_helpers.test)('nested params recognizeAndLoad', function (assert) {\n            routes = {\n                postIndex: (0, _test_helpers.createHandler)('postIndex'),\n                showFilteredPosts: (0, _test_helpers.createHandler)('showFilteredPosts', {\n                    model: function model(params) {\n                        return { name: 'showFilteredPosts', data: params.filter_id };\n                    }\n                })\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            router.recognizeAndLoad('/posts/filter/1').then(function (routeInfoWithAttributes) {\n                assert.notOk(router.activeTransition, 'Does not create an active transition');\n                if (routeInfoWithAttributes === null) {\n                    assert.ok(false);\n                    return;\n                }\n                assert.equal(routeInfoWithAttributes.name, 'showFilteredPosts');\n                assert.equal(routeInfoWithAttributes.localName, 'showFilteredPosts');\n                assert.equal(routeInfoWithAttributes.parent.name, 'postIndex');\n                assert.equal(routeInfoWithAttributes.child, null);\n                assert.deepEqual(routeInfoWithAttributes.attributes, {\n                    name: 'showFilteredPosts',\n                    data: '1'\n                });\n                assert.deepEqual(routeInfoWithAttributes.queryParams, {});\n                assert.deepEqual(routeInfoWithAttributes.params, { filter_id: '1' });\n                assert.deepEqual(routeInfoWithAttributes.paramNames, ['filter_id']);\n            });\n        });\n        (0, _test_helpers.test)('top-level QPs recognizeAndLoad', function (assert) {\n            routes = {\n                showAllPosts: (0, _test_helpers.createHandler)('showAllPosts', {\n                    model: function model() {\n                        return { name: 'showAllPosts', data: 'qp' };\n                    }\n                })\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            router.recognizeAndLoad('/posts/?a=b').then(function (routeInfoWithAttributes) {\n                assert.notOk(router.activeTransition, 'Does not create an active transition');\n                if (routeInfoWithAttributes === null) {\n                    assert.ok(false);\n                    return;\n                }\n                assert.equal(routeInfoWithAttributes.name, 'showAllPosts');\n                assert.equal(routeInfoWithAttributes.localName, 'showAllPosts');\n                assert.equal(routeInfoWithAttributes.parent.name, 'postIndex');\n                assert.equal(routeInfoWithAttributes.child, null);\n                assert.deepEqual(routeInfoWithAttributes.attributes, {\n                    name: 'showAllPosts',\n                    data: 'qp'\n                });\n                assert.deepEqual(routeInfoWithAttributes.queryParams, { a: 'b' });\n                assert.deepEqual(routeInfoWithAttributes.params, {});\n                assert.deepEqual(routeInfoWithAttributes.paramNames, []);\n            });\n        });\n        (0, _test_helpers.test)('top-level params and QPs recognizeAndLoad', function (assert) {\n            routes = {\n                postsIndex: (0, _test_helpers.createHandler)('postsIndex'),\n                showFilteredPosts: (0, _test_helpers.createHandler)('showFilteredPosts', {\n                    model: function model(params) {\n                        return { name: 'showFilteredPosts', data: params.filter_id };\n                    }\n                })\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            router.recognizeAndLoad('/posts/filter/123?a=b').then(function (routeInfoWithAttributes) {\n                assert.notOk(router.activeTransition, 'Does not create an active transition');\n                if (routeInfoWithAttributes === null) {\n                    assert.ok(false);\n                    return;\n                }\n                assert.equal(routeInfoWithAttributes.name, 'showFilteredPosts');\n                assert.equal(routeInfoWithAttributes.localName, 'showFilteredPosts');\n                assert.equal(routeInfoWithAttributes.parent.name, 'postIndex');\n                assert.equal(routeInfoWithAttributes.child, null);\n                assert.deepEqual(routeInfoWithAttributes.attributes, {\n                    name: 'showFilteredPosts',\n                    data: '123'\n                });\n                assert.deepEqual(routeInfoWithAttributes.queryParams, { a: 'b' });\n                assert.deepEqual(routeInfoWithAttributes.params, { filter_id: '123' });\n                assert.deepEqual(routeInfoWithAttributes.paramNames, ['filter_id']);\n            });\n        });\n        (0, _test_helpers.test)('unrecognized url rejects', function (assert) {\n            router.recognizeAndLoad('/fixzzz').then(function () {\n                assert.ok(false, 'never here');\n            }, function (reason) {\n                assert.equal(reason, 'URL /fixzzz was not recognized');\n            });\n        });\n        (0, _test_helpers.test)('top-level recognize url', function (assert) {\n            map(assert, function (match) {\n                match('/').to('index');\n            });\n            routes = {\n                post: (0, _test_helpers.createHandler)('post')\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            var routeInfo = router.recognize('/');\n            assert.notOk(router.activeTransition, 'Does not create an active transition');\n            if (routeInfo === null) {\n                assert.ok(false);\n                return;\n            }\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            assert.equal(routeInfo.name, 'index');\n            assert.equal(routeInfo.localName, 'index');\n            assert.equal(routeInfo.parent, null);\n            assert.equal(routeInfo.child, null);\n            assert.deepEqual(routeInfo.queryParams, {});\n            assert.deepEqual(routeInfo.params, {});\n            assert.deepEqual(routeInfo.paramNames, []);\n        });\n        (0, _test_helpers.test)('top-level recognize url with params', function (assert) {\n            map(assert, function (match) {\n                match('/posts/:id').to('post');\n            });\n            routes = {\n                post: (0, _test_helpers.createHandler)('post')\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            var routeInfo = router.recognize('/posts/123');\n            assert.notOk(router.activeTransition, 'Does not create an active transition');\n            if (routeInfo === null) {\n                assert.ok(false);\n                return;\n            }\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            assert.equal(routeInfo.name, 'post');\n            assert.equal(routeInfo.localName, 'post');\n            assert.equal(routeInfo.parent, null);\n            assert.equal(routeInfo.child, null);\n            assert.deepEqual(routeInfo.queryParams, {});\n            assert.deepEqual(routeInfo.params, { id: '123' });\n            assert.deepEqual(routeInfo.paramNames, ['id']);\n        });\n        (0, _test_helpers.test)('nested recognize url', function (assert) {\n            routes = {\n                postIndex: (0, _test_helpers.createHandler)('postIndex'),\n                showPopularPosts: (0, _test_helpers.createHandler)('showPopularPosts')\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            var routeInfo = router.recognize('/posts/popular');\n            assert.notOk(router.activeTransition, 'Does not create an active transition');\n            if (routeInfo === null) {\n                assert.ok(false);\n                return;\n            }\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            assert.equal(routeInfo.name, 'showPopularPosts');\n            assert.equal(routeInfo.localName, 'showPopularPosts');\n            assert.equal(routeInfo.parent.name, 'postIndex');\n            assert.equal(routeInfo.child, null);\n            assert.deepEqual(routeInfo.queryParams, {});\n            assert.deepEqual(routeInfo.params, {});\n            assert.deepEqual(routeInfo.paramNames, []);\n        });\n        (0, _test_helpers.test)('nested recognize url with params', function (assert) {\n            routes = {\n                postIndex: (0, _test_helpers.createHandler)('postIndex'),\n                showFilteredPosts: (0, _test_helpers.createHandler)('showFilteredPosts')\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            var routeInfo = router.recognize('/posts/filter/123');\n            assert.notOk(router.activeTransition, 'Does not create an active transition');\n            if (routeInfo === null) {\n                assert.ok(false);\n                return;\n            }\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            assert.equal(routeInfo.name, 'showFilteredPosts');\n            assert.equal(routeInfo.localName, 'showFilteredPosts');\n            assert.equal(routeInfo.parent.name, 'postIndex');\n            assert.equal(routeInfo.child, null);\n            assert.deepEqual(routeInfo.queryParams, {});\n            assert.deepEqual(routeInfo.params, { filter_id: '123' });\n            assert.deepEqual(routeInfo.paramNames, ['filter_id']);\n        });\n        (0, _test_helpers.test)('top-level recognize url with QPs', function (assert) {\n            map(assert, function (match) {\n                match('/').to('index');\n            });\n            routes = {\n                index: (0, _test_helpers.createHandler)('index')\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            var routeInfo = router.recognize('/?a=123');\n            assert.notOk(router.activeTransition, 'Does not create an active transition');\n            if (routeInfo === null) {\n                assert.ok(false);\n                return;\n            }\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            assert.equal(routeInfo.name, 'index');\n            assert.equal(routeInfo.localName, 'index');\n            assert.equal(routeInfo.parent, null);\n            assert.equal(routeInfo.child, null);\n            assert.deepEqual(routeInfo.queryParams, { a: '123' });\n            assert.deepEqual(routeInfo.params, {});\n            assert.deepEqual(routeInfo.paramNames, []);\n        });\n        (0, _test_helpers.test)('nested recognize url with QPs', function (assert) {\n            routes = {\n                postIndex: (0, _test_helpers.createHandler)('postIndex'),\n                showPopularPosts: (0, _test_helpers.createHandler)('showPopularPosts')\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            var routeInfo = router.recognize('/posts/popular?fizz=bar');\n            assert.notOk(router.activeTransition, 'Does not create an active transition');\n            if (routeInfo === null) {\n                assert.ok(false);\n                return;\n            }\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            assert.equal(routeInfo.name, 'showPopularPosts');\n            assert.equal(routeInfo.localName, 'showPopularPosts');\n            assert.equal(routeInfo.parent.name, 'postIndex');\n            assert.equal(routeInfo.child, null);\n            assert.deepEqual(routeInfo.queryParams, { fizz: 'bar' });\n            assert.deepEqual(routeInfo.params, {});\n            assert.deepEqual(routeInfo.paramNames, []);\n        });\n        (0, _test_helpers.test)('nested recognize url with QPs and params', function (assert) {\n            routes = {\n                postIndex: (0, _test_helpers.createHandler)('postIndex'),\n                showFilteredPosts: (0, _test_helpers.createHandler)('showFilteredPosts')\n            };\n            assert.notOk(router.activeTransition, 'Does not start with an active transition');\n            var routeInfo = router.recognize('/posts/filter/123?fizz=bar');\n            assert.notOk(router.activeTransition, 'Does not create an active transition');\n            if (routeInfo === null) {\n                assert.ok(false);\n                return;\n            }\n            router.replaceURL = function () {\n                assert.ok(false, 'Should not replace the URL');\n            };\n            router.updateURL = function () {\n                assert.ok(false, 'Should not update the URL');\n            };\n            assert.equal(routeInfo.name, 'showFilteredPosts');\n            assert.equal(routeInfo.localName, 'showFilteredPosts');\n            assert.equal(routeInfo.parent.name, 'postIndex');\n            assert.equal(routeInfo.child, null);\n            assert.deepEqual(routeInfo.queryParams, { fizz: 'bar' });\n            assert.deepEqual(routeInfo.params, { filter_id: '123' });\n            assert.deepEqual(routeInfo.paramNames, ['filter_id']);\n        });\n        (0, _test_helpers.test)('unrecognized url returns null', function (assert) {\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts/:id').to('post');\n            });\n            routes = {\n                post: (0, _test_helpers.createHandler)('post')\n            };\n            var routeInfo = router.recognize('/fixzzz');\n            assert.equal(routeInfo, null, 'Unrecognized url');\n        });\n        (0, _test_helpers.test)('basic route change events with nested params', function (assert) {\n            assert.expect(14);\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts/:id/foo').to('post');\n            });\n            var enteredWillChange = 0;\n            var enteredDidChange = 0;\n            routes = {\n                post: (0, _test_helpers.createHandler)('post')\n            };\n            var newParam = false;\n            router.routeWillChange = function (transition) {\n                enteredWillChange++;\n                if (newParam) {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'post');\n                    assert.deepEqual(transition.to.params, { id: '2' });\n                } else {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(transition.from, null);\n                    assert.deepEqual(transition.to.params, { id: '1' });\n                }\n            };\n            router.routeDidChange = function (transition) {\n                enteredDidChange++;\n                if (newParam) {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'post');\n                    assert.deepEqual(transition.to.params, { id: '2' });\n                } else {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(transition.from, null);\n                    assert.deepEqual(transition.to.params, { id: '1' });\n                }\n            };\n            router.transitionTo('/posts/1/foo').then(function () {\n                newParam = true;\n                return router.transitionTo('/posts/2/foo');\n            }).then(function () {\n                assert.equal(enteredWillChange, 2);\n                assert.equal(enteredDidChange, 2);\n            });\n        });\n        (0, _test_helpers.test)('basic route change events with query params', function (assert) {\n            assert.expect(20);\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts/:id').to('post');\n            });\n            var enteredWillChange = 0;\n            var enteredDidChange = 0;\n            routes = {\n                post: (0, _test_helpers.createHandler)('post')\n            };\n            var newParam = false;\n            router.routeWillChange = function (transition) {\n                enteredWillChange++;\n                if (newParam) {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'post');\n                    assert.deepEqual(transition.to.queryParams, { trk: 'b' });\n                    assert.deepEqual(isPresent(transition.from) && transition.from.queryParams, { trk: 'a' });\n                } else {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(transition.from, null);\n                    assert.deepEqual(transition.to.queryParams, { trk: 'a' });\n                }\n                assert.deepEqual(transition.to.params, { id: '1' });\n            };\n            router.routeDidChange = function (transition) {\n                enteredDidChange++;\n                if (newParam) {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'post');\n                    assert.deepEqual(transition.to.queryParams, { trk: 'b' });\n                    assert.deepEqual(isPresent(transition.from) && transition.from.queryParams, { trk: 'a' });\n                } else {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(transition.from, null);\n                    assert.deepEqual(transition.to.queryParams, { trk: 'a' });\n                }\n                assert.deepEqual(transition.to.params, { id: '1' });\n            };\n            router.transitionTo('/posts/1?trk=a').then(function () {\n                newParam = true;\n                return router.transitionTo('/posts/1?trk=b');\n            }).then(function () {\n                assert.equal(enteredWillChange, 2);\n                assert.equal(enteredDidChange, 2);\n            });\n        });\n        (0, _test_helpers.test)('basic route to one with query params', function (assert) {\n            assert.expect(8);\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/search').to('search');\n            });\n            routes = {\n                search: (0, _test_helpers.createHandler)('search')\n            };\n            var newParam = false;\n            router.routeWillChange = function (transition) {\n                if (newParam) {\n                    assert.deepEqual(transition.to.queryParams, { term: 'b' }, 'going to page with qps');\n                    assert.deepEqual(isPresent(transition.from) && transition.from.queryParams, {}, 'from never has qps');\n                } else {\n                    assert.equal(transition.from, null);\n                    assert.deepEqual(transition.to.queryParams, {});\n                }\n            };\n            router.routeDidChange = function (transition) {\n                if (newParam) {\n                    assert.deepEqual(transition.to.queryParams, { term: 'b' });\n                    assert.deepEqual(isPresent(transition.from) && transition.from.queryParams, {});\n                } else {\n                    assert.equal(transition.from, null);\n                    assert.deepEqual(transition.to.queryParams, {});\n                }\n            };\n            router.transitionTo('/').then(function () {\n                newParam = true;\n                return router.transitionTo('search', { queryParams: { term: 'b' } });\n            });\n        });\n        (0, _test_helpers.test)('redirects route events', function (assert) {\n            assert.expect(19);\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts', function (match) {\n                    match('/:id').to('post');\n                    match('/details').to('postDetails');\n                });\n                match('/foo', function (match) {\n                    match('/').to('foo', function (match) {\n                        match('/bar').to('bar');\n                    });\n                });\n                match('/ok').to('ok');\n            });\n            var redirected1 = false;\n            var redirected2 = false;\n            var initial = true;\n            var enteredWillChange = 0;\n            var enteredDidChange = 0;\n            routes = {\n                post: (0, _test_helpers.createHandler)('post', {\n                    model: function model() {\n                        redirected1 = true;\n                        router.transitionTo('/foo/bar');\n                    }\n                }),\n                foo: (0, _test_helpers.createHandler)('foo', {\n                    model: function model() {\n                        redirected1 = false;\n                        redirected2 = true;\n                        router.transitionTo('/ok');\n                    }\n                }),\n                ok: (0, _test_helpers.createHandler)('ok'),\n                bar: (0, _test_helpers.createHandler)('bar'),\n                postDetails: (0, _test_helpers.createHandler)('postDetails')\n            };\n            router.routeWillChange = function (transition) {\n                enteredWillChange++;\n                if (initial) {\n                    assert.equal(transition.to.localName, 'index');\n                    assert.equal(transition.from, null);\n                    assert.equal(transition.to.parent, null);\n                } else if (redirected1) {\n                    assert.equal(transition.to.localName, 'bar');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index');\n                    assert.equal(transition.to.parent.localName, 'foo');\n                } else if (redirected2) {\n                    assert.equal(transition.to.localName, 'ok');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index');\n                    assert.equal(transition.to.parent, null);\n                } else {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index');\n                    assert.equal(transition.to.parent, null);\n                }\n            };\n            router.routeDidChange = function (transition) {\n                enteredDidChange++;\n                if (initial) {\n                    assert.equal(transition.to.localName, 'index');\n                    assert.equal(transition.from, null);\n                    initial = false;\n                } else {\n                    assert.equal(transition.to.localName, 'ok');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index');\n                }\n            };\n            router.transitionTo('/').then(function () {\n                return router.transitionTo('/posts/1');\n            }).catch(function (err) {\n                console.log(err);\n                assert.equal(err.name, 'TransitionAborted');\n                return router.activeTransition;\n            }).then(function () {\n                assert.equal(enteredWillChange, 4);\n                assert.equal(enteredDidChange, 2);\n            });\n        });\n        (0, _test_helpers.test)('abort route events', function (assert) {\n            assert.expect(19);\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts', function (match) {\n                    match('/:id').to('post');\n                    match('/details').to('postDetails');\n                });\n                match('/foo', function (match) {\n                    match('/').to('foo', function (match) {\n                        match('/bar').to('bar');\n                    });\n                });\n            });\n            var redirected = false;\n            var initial = true;\n            var aborted = false;\n            var enteredWillChange = 0;\n            var enteredDidChange = 0;\n            routes = {\n                post: (0, _test_helpers.createHandler)('post', {\n                    model: function model() {\n                        redirected = true;\n                        router.transitionTo('/foo/bar');\n                    }\n                }),\n                foo: (0, _test_helpers.createHandler)('foo', {\n                    model: function model(_model, transition) {\n                        aborted = true;\n                        redirected = false;\n                        transition.abort();\n                    }\n                }),\n                bar: (0, _test_helpers.createHandler)('bar'),\n                postDetails: (0, _test_helpers.createHandler)('postDetails')\n            };\n            router.routeWillChange = function (transition) {\n                enteredWillChange++;\n                if (initial) {\n                    assert.equal(transition.to.localName, 'index');\n                    assert.equal(transition.from, null);\n                    assert.equal(transition.to.parent, null);\n                } else if (redirected) {\n                    assert.equal(transition.to.localName, 'bar');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index');\n                    assert.equal(transition.to.parent.localName, 'foo');\n                } else if (aborted) {\n                    assert.equal(transition.isAborted, true);\n                    assert.equal(transition.to, transition.from);\n                    assert.equal(transition.to.localName, 'index');\n                } else {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index');\n                    assert.equal(transition.to.parent, null);\n                }\n            };\n            router.routeDidChange = function (transition) {\n                enteredDidChange++;\n                if (initial) {\n                    assert.equal(transition.to.localName, 'index');\n                    assert.equal(transition.from, null);\n                    initial = false;\n                } else {\n                    assert.equal(transition.to.localName, 'index');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index');\n                }\n            };\n            router.transitionTo('/').then(function () {\n                return router.transitionTo('/posts/1');\n            }).catch(function (err) {\n                assert.equal(err.name, 'TransitionAborted');\n                return router.activeTransition;\n            }).then(function () {\n                assert.equal(enteredWillChange, 4);\n                assert.equal(enteredDidChange, 2);\n            });\n        });\n        (0, _test_helpers.test)('abort query param only', function (assert) {\n            assert.expect(6);\n            map(assert, function (match) {\n                match('/').to('index');\n            });\n            routes = {\n                search: (0, _test_helpers.createHandler)('search')\n            };\n            var newParam = false;\n            var initial = true;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                if (!initial) {\n                    assert.ok(false, 'updateURL should not be called');\n                }\n            };\n            router.routeWillChange = function (transition) {\n                if (!transition.isAborted) {\n                    if (newParam) {\n                        assert.deepEqual(transition.to.queryParams, { term: 'b' }, 'going to page with qps');\n                        assert.deepEqual(isPresent(transition.from) && transition.from.queryParams, {}, 'from never has qps');\n                    } else {\n                        assert.strictEqual(transition.from, null, 'null transition from');\n                        assert.deepEqual(transition.to.queryParams, {}, 'empty transition queryParams');\n                    }\n                }\n                if (!initial) {\n                    if (!transition.isAborted) {\n                        newParam = false;\n                        transition.abort();\n                    }\n                }\n            };\n            router.routeDidChange = function (transition) {\n                if (!transition.isAborted) {\n                    assert.strictEqual(transition.from, null, 'routeDidChange null from transition');\n                    assert.deepEqual(transition.to.queryParams, {}, 'routeDidChange empty queryParams');\n                }\n            };\n            router.transitionTo('/').then(function () {\n                newParam = true;\n                initial = false;\n                return router.transitionTo({ queryParams: { term: 'b' } });\n            });\n        });\n        (0, _test_helpers.test)('always has a transition through the substates', function (assert) {\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts', function (match) {\n                    match('/:id').to('post');\n                    match('/details').to('postDetails');\n                });\n                match('/foo', function (match) {\n                    match('/').to('foo', function (match) {\n                        match('/bar').to('bar');\n                    });\n                });\n                match('/err').to('fooError');\n            });\n            var enterSubstate = false;\n            var initial = true;\n            var isAborted = false;\n            var errorHandled = false;\n            var enteredWillChange = 0;\n            var enteredDidChange = 0;\n            routes = {\n                post: (0, _test_helpers.createHandler)('post', {\n                    beforeModel: function beforeModel(transition) {\n                        isAborted = true;\n                        transition.abort();\n                        enterSubstate = true;\n                        router.intermediateTransitionTo('fooError');\n                    }\n                }),\n                foo: (0, _test_helpers.createHandler)('foo')\n            };\n            router.transitionDidError = function (error, transition) {\n                if (error.wasAborted || transition.isAborted) {\n                    return (0, _transition2.logAbort)(transition);\n                } else {\n                    transition.trigger(false, 'error', error.error, transition, error.route);\n                    if (errorHandled) {\n                        transition.rollback();\n                        router.routeDidChange(transition);\n                        return transition;\n                    } else {\n                        transition.abort();\n                        return error.error;\n                    }\n                }\n            };\n            router.routeWillChange = function (transition) {\n                enteredWillChange++;\n                if (initial) {\n                    assert.equal(transition.to.localName, 'index', 'initial');\n                    assert.equal(transition.from, null, 'initial');\n                    assert.equal(transition.to.parent, null, 'initial');\n                } else if (isAborted) {\n                    assert.equal(transition.to.localName, 'index', 'aborted');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index', 'aborted');\n                } else if (enterSubstate) {\n                    assert.equal(transition.to.localName, 'fooError', 'substate');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index', 'substate');\n                    assert.equal(transition.to.parent.localName, 'foo', 'substate');\n                } else {\n                    assert.equal(transition.to.localName, 'post', 'to post');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index', 'to post');\n                    assert.equal(transition.to.parent, null, 'to post');\n                }\n            };\n            router.routeDidChange = function (transition) {\n                enteredDidChange++;\n                if (initial) {\n                    assert.equal(transition.to.localName, 'index', 'initial');\n                    assert.equal(transition.from, null, 'initial');\n                    initial = false;\n                } else if (isAborted) {\n                    assert.equal(transition.to.localName, 'index', 'aborted');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index', 'aborted');\n                    isAborted = false;\n                } else {\n                    assert.equal(transition.to.localName, 'bar');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index');\n                }\n            };\n            router.transitionTo('/').then(function () {\n                return router.transitionTo('/posts/1');\n            }).catch(function (err) {\n                assert.equal(err.name, 'TransitionAborted');\n                return router.activeTransition;\n            }).finally(function () {\n                assert.equal(enteredWillChange, 4);\n                assert.equal(enteredDidChange, 2);\n            });\n        });\n        (0, _test_helpers.test)('error route events', function (assert) {\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts', function (match) {\n                    match('/:id').to('post');\n                    match('/details').to('postDetails');\n                });\n                match('/foo', function (match) {\n                    match('/').to('foo', function (match) {\n                        match('/bar').to('bar');\n                    });\n                });\n                match('/err').to('fooError');\n            });\n            var redirected = false;\n            var initial = true;\n            var errored = false;\n            var errorHandled = false;\n            var enteredWillChange = 0;\n            var enteredDidChange = 0;\n            routes = {\n                post: (0, _test_helpers.createHandler)('post', {\n                    model: function model() {\n                        redirected = true;\n                        router.transitionTo('/foo/bar');\n                    }\n                }),\n                foo: (0, _test_helpers.createHandler)('foo', {\n                    model: function model() {\n                        errored = true;\n                        redirected = false;\n                        throw new Error('boom');\n                    },\n\n                    events: {\n                        error: function error() {\n                            errorHandled = true;\n                            router.intermediateTransitionTo('fooError');\n                        }\n                    }\n                }),\n                fooError: (0, _test_helpers.createHandler)('fooError'),\n                bar: (0, _test_helpers.createHandler)('bar'),\n                postDetails: (0, _test_helpers.createHandler)('postDetails')\n            };\n            router.transitionDidError = function (error, transition) {\n                if (error.wasAborted || transition.isAborted) {\n                    return (0, _transition2.logAbort)(transition);\n                } else {\n                    transition.trigger(false, 'error', error.error, transition, error.route);\n                    if (errorHandled) {\n                        transition.rollback();\n                        router.toInfos(transition, router.state.routeInfos, true);\n                        router.routeDidChange(transition);\n                        return transition;\n                    } else {\n                        transition.abort();\n                        return error.error;\n                    }\n                }\n            };\n            router.routeWillChange = function (transition) {\n                enteredWillChange++;\n                if (initial) {\n                    assert.equal(transition.to.localName, 'index');\n                    assert.equal(transition.from, null);\n                    assert.equal(transition.to.parent, null);\n                } else if (redirected) {\n                    assert.equal(transition.to.localName, 'bar');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index');\n                    assert.equal(transition.to.parent.localName, 'foo');\n                } else if (errored) {\n                    assert.equal(transition.isAborted, false);\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index');\n                    assert.equal(transition.to.localName, 'fooError');\n                } else {\n                    assert.equal(transition.to.localName, 'post');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index');\n                    assert.equal(transition.to.parent, null);\n                }\n            };\n            router.routeDidChange = function (transition) {\n                enteredDidChange++;\n                if (initial) {\n                    assert.equal(transition.to.localName, 'index');\n                    assert.equal(transition.from, null);\n                    initial = false;\n                } else {\n                    assert.equal(transition.to.localName, 'fooError');\n                    assert.equal(isPresent(transition.from) && transition.from.localName, 'index');\n                }\n            };\n            router.transitionTo('/').then(function () {\n                return router.transitionTo('/posts/1');\n            }).catch(function (err) {\n                assert.equal(err.name, 'TransitionAborted');\n                return router.activeTransition;\n            }).finally(function () {\n                assert.equal(enteredWillChange, 4);\n                assert.equal(enteredDidChange, 2);\n            });\n        });\n        (0, _test_helpers.test)(\"when transitioning to a new parent and child state, the parent's context should be available to the child's model\", function (assert) {\n            assert.expect(1);\n            var contexts = [];\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/posts/:id').to('post', function (match) {\n                    match('/details').to('postDetails');\n                });\n            });\n            routes = {\n                post: (0, _test_helpers.createHandler)('post', {\n                    model: function model() {\n                        return contexts;\n                    }\n                }),\n                postDetails: (0, _test_helpers.createHandler)('postDetails', {\n                    name: 'postDetails',\n                    afterModel: function afterModel(_model, transition) {\n                        contexts.push(transition.resolvedModels.post);\n                    }\n                })\n            };\n            router.handleURL('/').then(function () {\n                // This is a crucial part of the test\n                // In some cases, calling `generate` was preventing `model` from being called\n                router.generate('postDetails', { id: 1 });\n                return router.transitionTo('postDetails', { id: 1 });\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then(function (value) {\n                assert.deepEqual(contexts, [{ id: 1 }], 'parent context is available');\n                return value;\n            }, (0, _test_helpers.shouldNotHappen)(assert));\n        });\n        (0, _test_helpers.test)('handleURL: Handling a nested URL triggers each handler', function (assert) {\n            assert.expect(37);\n            var posts = [];\n            var allPosts = { all: true };\n            var popularPosts = { popular: true };\n            var amazingPosts = { id: 'amazing' };\n            var sadPosts = { id: 'sad' };\n            var counter = 0;\n            var postIndexHandler = (0, _test_helpers.createHandler)('postIndex', {\n                model: function model(params, transition) {\n                    assert.equal(transition.from, null, 'initial transition');\n                    assert.equal(transition.to && transition.to.localName, 'showAllPosts', 'going to leaf');\n                    // this will always get called, since it's at the root\n                    // of all of the routes tested here\n                    assert.deepEqual(params, { queryParams: {} }, 'params should be empty in postIndexHandler#model');\n                    return posts;\n                },\n                setup: function setup(context) {\n                    if (counter === 0) {\n                        assert.equal(postIndexHandler.context, posts, 'postIndexHandler context should be set up in postIndexHandler#setup');\n                        assert.strictEqual(context, posts, 'The object passed in to postIndexHandler#setup should be posts');\n                    } else {\n                        assert.ok(false, 'Should not get here');\n                    }\n                }\n            });\n            var showAllPostsHandler = (0, _test_helpers.createHandler)('showAllPosts', {\n                model: function model(params, transition) {\n                    if (counter > 0 && counter < 4) {\n                        assert.equal(postIndexHandler.context, posts, 'postIndexHandler context should be set up in showAllPostsHandler#model');\n                    }\n                    if (counter < 4) {\n                        assert.equal(transition.from, null, 'initial transition');\n                        assert.equal(transition.to && transition.to.localName, 'showAllPosts', 'at leaf');\n                        assert.deepEqual(params, { queryParams: {} }, 'params should be empty in showAllPostsHandler#model');\n                        return allPosts;\n                    } else {\n                        assert.ok(false, 'Should not get here');\n                    }\n                    return;\n                },\n                setup: function setup(context) {\n                    if (counter === 0) {\n                        assert.equal(postIndexHandler.context, posts, 'postIndexHandler context should be set up in showAllPostsHandler#setup');\n                        assert.equal(showAllPostsHandler.context, allPosts, 'showAllPostsHandler context should be set up in showAllPostsHandler#setup');\n                        assert.strictEqual(context, allPosts, 'The object passed in should be allPosts in showAllPostsHandler#setup');\n                    } else {\n                        assert.ok(false, 'Should not get here');\n                    }\n                }\n            });\n            var showPopularPostsHandler = (0, _test_helpers.createHandler)('showPopularPosts', {\n                model: function model(params) {\n                    if (counter < 3) {\n                        assert.ok(false, 'Should not get here');\n                    } else if (counter === 3) {\n                        assert.equal(postIndexHandler.context, posts, 'postIndexHandler context should be set up in showPopularPostsHandler#model');\n                        assert.deepEqual(params, { queryParams: {} }, 'params should be empty in showPopularPostsHandler#serialize');\n                        return popularPosts;\n                    } else {\n                        assert.ok(false, 'Should not get here');\n                    }\n                    return;\n                },\n                setup: function setup(context) {\n                    if (counter === 3) {\n                        assert.equal(postIndexHandler.context, posts, 'postIndexHandler context should be set up in showPopularPostsHandler#setup');\n                        assert.equal(showPopularPostsHandler.context, popularPosts, 'showPopularPostsHandler context should be set up in showPopularPostsHandler#setup');\n                        assert.strictEqual(context, popularPosts, 'The object passed to showPopularPostsHandler#setup should be popular posts');\n                    } else {\n                        assert.ok(false, 'Should not get here');\n                    }\n                }\n            });\n            var showFilteredPostsHandler = (0, _test_helpers.createHandler)('showFilteredPosts', {\n                model: function model(params, transition) {\n                    if (counter < 4) {\n                        assert.ok(false, 'Should not get here');\n                    } else if (counter === 4) {\n                        assert.equal(transition.from && transition.from.localName, 'showPopularPosts');\n                        assert.equal(postIndexHandler.context, posts, 'postIndexHandler context should be set up in showFilteredPostsHandler#model');\n                        assert.deepEqual(params, { filter_id: 'amazing', queryParams: {} }, \"params should be { filter_id: 'amazing' } in showFilteredPostsHandler#model\");\n                        return amazingPosts;\n                    } else if (counter === 5) {\n                        assert.equal(transition.from && transition.from.localName, 'showFilteredPosts', 'came from same route');\n                        assert.equal(transition.to && transition.to.localName, 'showFilteredPosts', 'going to same route');\n                        assert.equal(transition.from && transition.from.params.filter_id, 'amazing', 'old params');\n                        assert.equal(transition.to && transition.to.params.filter_id, 'sad', 'new params');\n                        assert.equal(postIndexHandler.context, posts, 'postIndexHandler context should be posts in showFilteredPostsHandler#model');\n                        assert.deepEqual(params, { filter_id: 'sad', queryParams: {} }, \"params should be { filter_id: 'sad' } in showFilteredPostsHandler#model\");\n                        return sadPosts;\n                    } else {\n                        assert.ok(false, 'Should not get here');\n                    }\n                    return;\n                },\n                setup: function setup(context) {\n                    if (counter === 4) {\n                        assert.equal(postIndexHandler.context, posts);\n                        assert.equal(showFilteredPostsHandler.context, amazingPosts);\n                        assert.strictEqual(context, amazingPosts);\n                    } else if (counter === 5) {\n                        assert.equal(postIndexHandler.context, posts);\n                        assert.equal(showFilteredPostsHandler.context, sadPosts);\n                        assert.strictEqual(context, sadPosts);\n                    } else {\n                        assert.ok(false, 'Should not get here');\n                    }\n                }\n            });\n            routes = {\n                postIndex: postIndexHandler,\n                showAllPosts: showAllPostsHandler,\n                showPopularPosts: showPopularPostsHandler,\n                showFilteredPosts: showFilteredPostsHandler\n            };\n            router.transitionTo('/posts').then(function () {\n                assert.ok(true, '1: Finished, trying /posts/all');\n                counter++;\n                return router.transitionTo('/posts/all');\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then(function () {\n                assert.ok(true, '2: Finished, trying /posts');\n                counter++;\n                return router.transitionTo('/posts');\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then(function () {\n                assert.ok(true, '3: Finished, trying /posts/popular');\n                counter++;\n                return router.transitionTo('/posts/popular');\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then(function () {\n                assert.ok(true, '4: Finished, trying /posts/filter/amazing');\n                counter++;\n                return router.transitionTo('/posts/filter/amazing');\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then(function () {\n                assert.ok(true, '5: Finished, trying /posts/filter/sad');\n                counter++;\n                return router.transitionTo('/posts/filter/sad');\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then(function () {\n                assert.ok(true, '6: Finished!');\n            }, (0, _test_helpers.shouldNotHappen)(assert));\n        });\n        (0, _test_helpers.test)('it can handle direct transitions to named routes', function (assert) {\n            var allPosts = { all: true };\n            var popularPosts = { popular: true };\n            var amazingPosts = { filter: 'amazing' };\n            var sadPosts = { filter: 'sad' };\n            var postIndexHandler = (0, _test_helpers.createHandler)('postIndex', {\n                model: function model() {\n                    return allPosts;\n                },\n                serialize: function serialize() {\n                    return {};\n                }\n            });\n            var showAllPostsHandler = (0, _test_helpers.createHandler)('showAllPosts', {\n                model: function model() {\n                    //assert.ok(!params, 'params is falsy for non dynamic routes');\n                    return allPosts;\n                },\n                serialize: function serialize() {\n                    return {};\n                },\n                setup: function setup(context) {\n                    assert.strictEqual(context, allPosts, 'showAllPosts should get correct setup');\n                }\n            });\n            var showPopularPostsHandler = (0, _test_helpers.createHandler)('showPopularPosts', {\n                model: function model() {\n                    return popularPosts;\n                },\n                serialize: function serialize() {\n                    return {};\n                },\n                setup: function setup(context) {\n                    assert.strictEqual(context, popularPosts, 'showPopularPosts#setup should be called with the deserialized value');\n                }\n            });\n            var showFilteredPostsHandler = (0, _test_helpers.createHandler)('showFilteredPosts', {\n                model: function model(params) {\n                    if (!params) {\n                        return;\n                    }\n                    if (params.filter_id === 'amazing') {\n                        return amazingPosts;\n                    } else if (params.filter_id === 'sad') {\n                        return sadPosts;\n                    }\n                    return;\n                },\n                serialize: function serialize(context, params) {\n                    assert.deepEqual(params, ['filter_id'], 'showFilteredPosts should get correct serialize');\n                    return { filter_id: context.filter };\n                },\n                setup: function setup(context) {\n                    if (counter === 2) {\n                        assert.strictEqual(context, amazingPosts, 'showFilteredPosts should get setup with amazingPosts');\n                    } else if (counter === 3) {\n                        assert.strictEqual(context, sadPosts, 'showFilteredPosts should get setup setup with sadPosts');\n                    }\n                }\n            });\n            routes = {\n                postIndex: postIndexHandler,\n                showAllPosts: showAllPostsHandler,\n                showPopularPosts: showPopularPostsHandler,\n                showFilteredPosts: showFilteredPostsHandler\n            };\n            router.updateURL = function (url) {\n                var expected = {\n                    0: '/posts',\n                    1: '/posts/popular',\n                    2: '/posts/filter/amazing',\n                    3: '/posts/filter/sad',\n                    4: '/posts'\n                };\n                assert.equal(url, expected[counter], 'updateURL should be called with correct url');\n            };\n            var counter = 0;\n            router.handleURL('/posts').then(function () {\n                return router.transitionTo('showAllPosts');\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then(function () {\n                counter++;\n                return router.transitionTo('showPopularPosts');\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then(function () {\n                counter++;\n                return router.transitionTo('showFilteredPosts', amazingPosts);\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then(function () {\n                counter++;\n                return router.transitionTo('showFilteredPosts', sadPosts);\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then(function () {\n                counter++;\n                return router.transitionTo('showAllPosts');\n            }, (0, _test_helpers.shouldNotHappen)(assert));\n        });\n        (0, _test_helpers.test)('replaceWith calls replaceURL', function (assert) {\n            var updateCount = 0,\n                replaceCount = 0;\n            router.updateURL = function () {\n                updateCount++;\n            };\n            router.replaceURL = function () {\n                replaceCount++;\n            };\n            router.handleURL('/posts').then(function () {\n                return router.replaceWith('about');\n            }).then(function () {\n                assert.equal(updateCount, 0, 'should not call updateURL');\n                assert.equal(replaceCount, 1, 'should call replaceURL once');\n            });\n        });\n        (0, _test_helpers.test)('applyIntent returns a tentative state based on a named transition', function (assert) {\n            (0, _test_helpers.transitionTo)(router, '/posts');\n            var state = router.applyIntent('faq', []);\n            assert.ok(state.routeInfos.length);\n        });\n        (0, _test_helpers.test)('Moving to a new top-level route triggers exit callbacks', function (assert) {\n            assert.expect(6);\n            var allPosts = { posts: 'all' };\n            var postsStore = { 1: { id: 1 }, 2: { id: 2 } };\n            var currentId = void 0;\n            var currentPath = void 0;\n            routes = {\n                showAllPosts: (0, _test_helpers.createHandler)('showAllPosts', {\n                    model: function model() {\n                        return allPosts;\n                    },\n                    setup: function setup(posts, transition) {\n                        assert.ok(!(0, _test_helpers.isExiting)(this, transition.routeInfos));\n                        assert.equal(posts, allPosts, 'The correct context was passed into showAllPostsHandler#setup');\n                        currentPath = 'postIndex.showAllPosts';\n                    },\n                    exit: function exit(transition) {\n                        assert.ok((0, _test_helpers.isExiting)(this, transition.routeInfos));\n                    }\n                }),\n                showPost: (0, _test_helpers.createHandler)('showPost', {\n                    model: function model(params) {\n                        var id = parseInt(params.id, 10);\n                        return postsStore[id];\n                    },\n                    serialize: function serialize(post) {\n                        return { id: post.id };\n                    },\n                    setup: function setup(post) {\n                        currentPath = 'showPost';\n                        assert.equal(post.id, currentId, 'The post id is ' + currentId);\n                    }\n                })\n            };\n            router.handleURL('/posts').then(function () {\n                expectedUrl = '/posts/1';\n                currentId = 1;\n                return router.transitionTo('showPost', postsStore[1]);\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then(function () {\n                assert.equal(routePath(router.currentRouteInfos), currentPath);\n            }, (0, _test_helpers.shouldNotHappen)(assert));\n        });\n        (0, _test_helpers.test)('pivotHandler is exposed on Transition object', function (assert) {\n            assert.expect(3);\n            routes = {\n                showAllPosts: (0, _test_helpers.createHandler)('showAllPosts', {\n                    beforeModel: function beforeModel(transition) {\n                        assert.ok(!transition.pivotHandler, 'First route transition has no pivot route');\n                    }\n                }),\n                showPopularPosts: (0, _test_helpers.createHandler)('showPopularPosts', {\n                    beforeModel: function beforeModel(transition) {\n                        assert.equal(transition.pivotHandler, routes.postIndex, 'showAllPosts -> showPopularPosts pivotHandler is postIndex');\n                    }\n                }),\n                postIndex: (0, _test_helpers.createHandler)('postIndex'),\n                about: (0, _test_helpers.createHandler)('about', {\n                    beforeModel: function beforeModel(transition) {\n                        assert.ok(!transition.pivotHandler, 'top-level transition has no pivotHandler');\n                    }\n                })\n            };\n            router.handleURL('/posts').then(function () {\n                return router.transitionTo('showPopularPosts');\n            }).then(function () {\n                return router.transitionTo('about');\n            });\n        });\n        (0, _test_helpers.test)('transition.resolvedModels after redirects b/w routes', function (assert) {\n            assert.expect(3);\n            map(assert, function (match) {\n                match('/').to('application', function (match) {\n                    match('/peter').to('peter');\n                    match('/wagenet').to('wagenet');\n                });\n            });\n            var app = { app: true };\n            routes = {\n                application: (0, _test_helpers.createHandler)('application', {\n                    model: function model() {\n                        assert.ok(true, 'application#model');\n                        return app;\n                    }\n                }),\n                peter: (0, _test_helpers.createHandler)('peter', {\n                    model: function model(_params, transition) {\n                        assert.deepEqual(transition.resolvedModels.application, app, 'peter: resolvedModel correctly stored in resolvedModels for parent route');\n                        router.transitionTo('wagenet');\n                    }\n                }),\n                wagenet: (0, _test_helpers.createHandler)('wagenet', {\n                    model: function model(_params, transition) {\n                        assert.deepEqual(transition.resolvedModels.application, app, 'wagenet: resolvedModel correctly stored in resolvedModels for parent route');\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, '/peter');\n        });\n        (0, _test_helpers.test)('transition.resolvedModels after redirects within the same route', function (assert) {\n            var admin = { admin: true },\n                redirect = true;\n            routes = {\n                admin: (0, _test_helpers.createHandler)('admin', {\n                    model: function model() {\n                        assert.ok(true, 'admin#model');\n                        return admin;\n                    }\n                }),\n                adminPosts: (0, _test_helpers.createHandler)('adminPosts', {\n                    model: function model(_params, transition) {\n                        assert.deepEqual(transition.resolvedModels.admin, admin, 'resolvedModel correctly stored in resolvedModels for parent route');\n                        if (redirect) {\n                            redirect = false;\n                            router.transitionTo('adminPosts');\n                        }\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, '/posts/admin/1/posts');\n        });\n        (0, _test_helpers.test)('Moving to the same route with a different parent dynamic segment re-runs model', function (assert) {\n            var admins = { 1: { id: 1 }, 2: { id: 2 } },\n                adminPosts = { 1: { id: 1 }, 2: { id: 2 } };\n            routes = {\n                admin: (0, _test_helpers.createHandler)('admin', {\n                    currentModel: -1,\n                    model: function model(params) {\n                        return this.currentModel = admins[params.id];\n                    }\n                }),\n                adminPosts: (0, _test_helpers.createHandler)('adminPosts', {\n                    model: function model() {\n                        return adminPosts[routes.admin.currentModel.id];\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, '/posts/admin/1/posts');\n            assert.equal(routes.admin.context, admins[1]);\n            assert.equal(routes.adminPosts.context, adminPosts[1]);\n            (0, _test_helpers.transitionTo)(router, '/posts/admin/2/posts');\n            assert.equal(routes.admin.context, admins[2]);\n            assert.equal(routes.adminPosts.context, adminPosts[2]);\n        });\n        (0, _test_helpers.test)('Moving to a sibling route only triggers exit callbacks on the current route (when transitioned internally)', function (assert) {\n            assert.expect(8);\n            var allPosts = { posts: 'all' };\n            var showAllPostsHandler = (0, _test_helpers.createHandler)('showAllPosts', {\n                model: function model() {\n                    return allPosts;\n                },\n                setup: function setup(posts) {\n                    assert.equal(posts, allPosts, 'The correct context was passed into showAllPostsHandler#setup');\n                },\n                enter: function enter() {\n                    assert.ok(true, 'The sibling handler should be entered');\n                },\n                exit: function exit() {\n                    assert.ok(true, 'The sibling handler should be exited');\n                }\n            });\n            var filters = {};\n            var showFilteredPostsHandler = (0, _test_helpers.createHandler)('showFilteredPosts', {\n                enter: function enter() {\n                    assert.ok(true, 'The new handler was entered');\n                },\n                exit: function exit() {\n                    assert.ok(false, 'The new handler should not be exited');\n                },\n                model: function model(params) {\n                    var id = params.filter_id;\n                    if (!filters[id]) {\n                        filters[id] = { id: id };\n                    }\n                    return filters[id];\n                },\n                serialize: function serialize(filter) {\n                    assert.equal(filter.id, 'favorite', \"The filter should be 'favorite'\");\n                    return { filter_id: filter.id };\n                },\n                setup: function setup(filter) {\n                    assert.equal(filter.id, 'favorite', 'showFilteredPostsHandler#setup was called with the favorite filter');\n                }\n            });\n            var postIndexHandler = (0, _test_helpers.createHandler)('postIndex', {\n                enter: function enter() {\n                    assert.ok(true, 'The outer handler was entered only once');\n                },\n                exit: function exit() {\n                    assert.ok(false, 'The outer handler was not exited');\n                }\n            });\n            routes = {\n                postIndex: postIndexHandler,\n                showAllPosts: showAllPostsHandler,\n                showFilteredPosts: showFilteredPostsHandler\n            };\n            router.handleURL('/posts').then(function () {\n                expectedUrl = '/posts/filter/favorite';\n                return router.transitionTo('showFilteredPosts', { id: 'favorite' });\n            });\n        });\n        (0, _test_helpers.test)('Moving to a sibling route only triggers exit callbacks on the current route (when transitioned via a URL change)', function (assert) {\n            assert.expect(7);\n            var allPosts = { posts: 'all' };\n            var showAllPostsHandler = (0, _test_helpers.createHandler)('showAllPostsHandler', {\n                model: function model() {\n                    return allPosts;\n                },\n                setup: function setup(posts) {\n                    assert.equal(posts, allPosts, 'The correct context was passed into showAllPostsHandler#setup');\n                },\n                enter: function enter() {\n                    assert.ok(true, 'The sibling handler should be entered');\n                },\n                exit: function exit() {\n                    assert.ok(true, 'The sibling handler should be exited');\n                }\n            });\n            var filters = {};\n            var showFilteredPostsHandler = (0, _test_helpers.createHandler)('showFilteredPosts', {\n                enter: function enter() {\n                    assert.ok(true, 'The new handler was entered');\n                },\n                exit: function exit() {\n                    assert.ok(false, 'The new handler should not be exited');\n                },\n                model: function model(params) {\n                    assert.equal(params.filter_id, 'favorite', \"The filter should be 'favorite'\");\n                    var id = params.filter_id;\n                    if (!filters[id]) {\n                        filters[id] = { id: id };\n                    }\n                    return filters[id];\n                },\n                serialize: function serialize(filter) {\n                    return { filter_id: filter.id };\n                },\n                setup: function setup(filter) {\n                    assert.equal(filter.id, 'favorite', 'showFilteredPostsHandler#setup was called with the favorite filter');\n                }\n            });\n            var postIndexHandler = (0, _test_helpers.createHandler)('postIndex', {\n                enter: function enter() {\n                    assert.ok(true, 'The outer handler was entered only once');\n                },\n                exit: function exit() {\n                    assert.ok(false, 'The outer handler was not exited');\n                }\n            });\n            routes = {\n                postIndex: postIndexHandler,\n                showAllPosts: showAllPostsHandler,\n                showFilteredPosts: showFilteredPostsHandler\n            };\n            router.handleURL('/posts');\n            (0, _test_helpers.flushBackburner)();\n            expectedUrl = '/posts/filter/favorite';\n            router.handleURL(expectedUrl);\n        });\n        (0, _test_helpers.test)('events can be targeted at the current handler', function (assert) {\n            assert.expect(2);\n            routes = {\n                showPost: (0, _test_helpers.createHandler)('showPost', {\n                    enter: function enter() {\n                        assert.ok(true, 'The show post handler was entered');\n                    },\n                    events: {\n                        expand: function expand() {\n                            assert.equal(this, routes.showPost, 'The handler is the `this` for the event');\n                        }\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, '/posts/1');\n            router.trigger('expand');\n        });\n        (0, _test_helpers.test)('event triggering is pluggable', function (assert) {\n            routes = {\n                showPost: (0, _test_helpers.createHandler)('showPost', {\n                    enter: function enter() {\n                        assert.ok(true, 'The show post handler was entered');\n                    },\n                    actions: {\n                        expand: function expand() {\n                            assert.equal(this, routes.showPost, 'The handler is the `this` for the event');\n                        }\n                    }\n                })\n            };\n            router.triggerEvent = function (handlerInfos, ignoreFailure, name, args) {\n                if (!handlerInfos) {\n                    if (ignoreFailure) {\n                        return;\n                    }\n                    throw new Error(\"Could not trigger event '\" + name + \"'. There are no active handlers\");\n                }\n                for (var i = handlerInfos.length - 1; i >= 0; i--) {\n                    var handlerInfo = handlerInfos[i],\n                        handler = handlerInfo.route;\n                    if (handler.actions && handler.actions[name]) {\n                        if (handler.actions[name].apply(handler, args) !== true) {\n                            return;\n                        }\n                    }\n                }\n            };\n            router.handleURL('/posts/1').then(function () {\n                router.trigger('expand');\n            });\n        });\n        (0, _test_helpers.test)('Unhandled events raise an exception', function (assert) {\n            router.handleURL('/posts/1');\n            assert.throws(function () {\n                router.trigger('doesnotexist');\n            }, /doesnotexist/);\n        });\n        (0, _test_helpers.test)('events can be targeted at a parent handler', function (assert) {\n            assert.expect(3);\n            routes = {\n                postIndex: (0, _test_helpers.createHandler)('postIndex', {\n                    enter: function enter() {\n                        assert.ok(true, 'The post index handler was entered');\n                    },\n                    events: {\n                        expand: function expand() {\n                            assert.equal(this, routes.postIndex, 'The handler is the `this` in events');\n                        }\n                    }\n                }),\n                showAllPosts: (0, _test_helpers.createHandler)('showAllPosts', {\n                    enter: function enter() {\n                        assert.ok(true, 'The show all posts handler was entered');\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, '/posts');\n            router.trigger('expand');\n        });\n        (0, _test_helpers.test)('events can bubble up to a parent handler via `return true`', function (assert) {\n            assert.expect(4);\n            routes = {\n                postIndex: (0, _test_helpers.createHandler)('postIndex', {\n                    enter: function enter() {\n                        assert.ok(true, 'The post index handler was entered');\n                    },\n                    events: {\n                        expand: function expand() {\n                            assert.equal(this, routes.postIndex, 'The handler is the `this` in events');\n                        }\n                    }\n                }),\n                showAllPosts: (0, _test_helpers.createHandler)('showAllPosts', {\n                    enter: function enter() {\n                        assert.ok(true, 'The show all posts handler was entered');\n                    },\n                    events: {\n                        expand: function expand() {\n                            assert.equal(this, routes.showAllPosts, 'The handler is the `this` in events');\n                            return true;\n                        }\n                    }\n                })\n            };\n            router.handleURL('/posts').then(function () {\n                router.trigger('expand');\n            });\n        });\n        (0, _test_helpers.test)(\"handled-then-bubbled events don't throw an exception if uncaught by parent route\", function (assert) {\n            assert.expect(3);\n            routes = {\n                postIndex: (0, _test_helpers.createHandler)('postIndex', {\n                    enter: function enter() {\n                        assert.ok(true, 'The post index handler was entered');\n                    }\n                }),\n                showAllPosts: (0, _test_helpers.createHandler)('showAllPosts', {\n                    enter: function enter() {\n                        assert.ok(true, 'The show all posts handler was entered');\n                    },\n                    events: {\n                        expand: function expand() {\n                            assert.equal(this, routes.showAllPosts, 'The handler is the `this` in events');\n                            return true;\n                        }\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, '/posts');\n            router.trigger('expand');\n        });\n        (0, _test_helpers.test)('events only fire on the closest handler', function (assert) {\n            assert.expect(5);\n            routes = {\n                postIndex: (0, _test_helpers.createHandler)('postIndex', {\n                    enter: function enter() {\n                        assert.ok(true, 'The post index handler was entered');\n                    },\n                    events: {\n                        expand: function expand() {\n                            assert.ok(false, 'Should not get to the parent handler');\n                        }\n                    }\n                }),\n                showAllPosts: (0, _test_helpers.createHandler)('showAllPosts', {\n                    enter: function enter() {\n                        assert.ok(true, 'The show all posts handler was entered');\n                    },\n                    events: {\n                        expand: function expand(passedContext1, passedContext2) {\n                            assert.equal(context1, passedContext1, 'A context is passed along');\n                            assert.equal(context2, passedContext2, 'A second context is passed along');\n                            assert.equal(this, routes.showAllPosts, 'The handler is passed into events as `this`');\n                        }\n                    }\n                })\n            };\n            var context1 = {},\n                context2 = {};\n            router.handleURL('/posts').then(function () {\n                router.trigger('expand', context1, context2);\n            });\n        });\n        (0, _test_helpers.test)(\"Date params aren't treated as string/number params\", function (assert) {\n            assert.expect(1);\n            routes = {\n                showPostsForDate: (0, _test_helpers.createHandler)('showPostsForDate', {\n                    serialize: function serialize(date) {\n                        return {\n                            date: date.getFullYear() + '-' + date.getMonth() + '-' + date.getDate()\n                        };\n                    },\n                    model: function model() {\n                        assert.ok(false, \"model shouldn't be called; the date is the provided model\");\n                    }\n                })\n            };\n            if (scenario.async) {\n                serializers = {\n                    showPostsForDate: function showPostsForDate(date) {\n                        return {\n                            date: date.getFullYear() + '-' + date.getMonth() + '-' + date.getDate()\n                        };\n                    }\n                };\n            }\n            var result = router.generate('showPostsForDate', new Date(1815, 5, 18));\n            assert.equal(result, '/posts/on/1815-5-18');\n        });\n        (0, _test_helpers.test)('getSerializer takes precedence over handler.serialize', function (assert) {\n            assert.expect(2);\n            router.getSerializer = function () {\n                return function (date) {\n                    assert.ok(true, 'getSerializer called');\n                    return {\n                        date: date.getFullYear() + '-' + date.getMonth() + '-' + date.getDate()\n                    };\n                };\n            };\n            routes = {\n                showPostsForDate: (0, _test_helpers.createHandler)('showPostsForDate', {\n                    serialize: function serialize() {\n                        assert.ok(false, \"serialize method shouldn't be called\");\n                        return {};\n                    },\n                    model: function model() {\n                        assert.ok(false, \"model shouldn't be called; the date is the provided model\");\n                    }\n                })\n            };\n            assert.equal(router.generate('showPostsForDate', new Date(1815, 5, 18)), '/posts/on/1815-5-18');\n        });\n        (0, _test_helpers.test)('the serializer method is unbound', function (assert) {\n            assert.expect(1);\n            router.getSerializer = function () {\n                return function (date) {\n                    assert.equal(this, undefined);\n                    return {\n                        date: date.getFullYear() + '-' + date.getMonth() + '-' + date.getDate()\n                    };\n                };\n            };\n            router.generate('showPostsForDate', new Date(1815, 5, 18));\n        });\n        (0, _test_helpers.test)('params are known by a transition up front', function (assert) {\n            assert.expect(2);\n            routes = {\n                postIndex: (0, _test_helpers.createHandler)('postIndex', {\n                    model: function model(_params, transition) {\n                        assert.deepEqual(transition[_transition2.PARAMS_SYMBOL], {\n                            postIndex: {},\n                            showFilteredPosts: { filter_id: 'sad' }\n                        });\n                    }\n                }),\n                showFilteredPosts: (0, _test_helpers.createHandler)('showFilteredPosts', {\n                    model: function model(_params, transition) {\n                        assert.deepEqual(transition[_transition2.PARAMS_SYMBOL], {\n                            postIndex: {},\n                            showFilteredPosts: { filter_id: 'sad' }\n                        });\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, '/posts/filter/sad', 'blorg');\n        });\n        (0, _test_helpers.test)('transitionTo uses the current context if you are already in a handler with a context that is not changing', function (assert) {\n            var admin = { id: 47 },\n                adminPost = { id: 74 };\n            routes = {\n                admin: (0, _test_helpers.createHandler)('admin', {\n                    serialize: function serialize(object) {\n                        assert.equal(object.id, 47, 'The object passed to serialize is correct');\n                        return { id: 47 };\n                    },\n                    model: function model(params) {\n                        assert.equal(params.id, 47, 'The object passed to serialize is correct');\n                        return admin;\n                    }\n                }),\n                adminPost: (0, _test_helpers.createHandler)('adminPost', {\n                    serialize: function serialize(object) {\n                        return { post_id: object.id };\n                    },\n                    model: function model(params) {\n                        assert.equal(params.id, 74, 'The object passed to serialize is correct');\n                        return adminPost;\n                    }\n                })\n            };\n            expectedUrl = '/posts/admin/47/posts/74';\n            (0, _test_helpers.transitionTo)(router, 'adminPost', admin, adminPost);\n            expectedUrl = '/posts/admin/47/posts/75';\n            (0, _test_helpers.transitionTo)(router, 'adminPost', { id: 75 });\n        });\n        (0, _test_helpers.test)('check for mid-transition correctness', function (assert) {\n            var posts = {\n                1: { id: 1 },\n                2: { id: 2 },\n                3: { id: 3 }\n            };\n            var showPostHandler = (0, _test_helpers.createHandler)('showPost', {\n                serialize: function serialize(object) {\n                    return object && { id: object.id } || null;\n                },\n                model: function model(params) {\n                    var id = params.id;\n                    return posts[id];\n                }\n            });\n            routes = {\n                showPost: showPostHandler\n            };\n            // Get a reference to the transition, mid-transition.\n            router.willTransition = function () {\n                var midTransitionState = router.activeTransition[_transition2.STATE_SYMBOL];\n                // Make sure that the activeIntent doesn't match post 300.\n                var isPost300Targeted = router.isActiveIntent('showPost', [300], undefined, midTransitionState);\n                assert.notOk(isPost300Targeted, 'Post 300 should not match post 3.');\n            };\n            // Go to post 3. This triggers our test.\n            (0, _test_helpers.transitionTo)(router, '/posts/3');\n            // Clean up.\n            delete router.willTransition;\n        });\n        (0, _test_helpers.test)('tests whether arguments to transitionTo are considered active', function (assert) {\n            var admin = { id: 47 },\n                adminPost = { id: 74 },\n                posts = {\n                1: { id: 1 },\n                2: { id: 2 },\n                3: { id: 3 }\n            };\n            var adminHandler = (0, _test_helpers.createHandler)('admin', {\n                serialize: function serialize() {\n                    return { id: 47 };\n                },\n                model: function model() {\n                    return admin;\n                }\n            });\n            var adminPostHandler = (0, _test_helpers.createHandler)('adminPost', {\n                serialize: function serialize(object) {\n                    return { post_id: object.id };\n                },\n                model: function model() {\n                    return adminPost;\n                }\n            });\n            var showPostHandler = (0, _test_helpers.createHandler)('showPost', {\n                serialize: function serialize(object) {\n                    return object && { id: object.id } || null;\n                },\n                model: function model(params) {\n                    return posts[params.id];\n                }\n            });\n            routes = {\n                admin: adminHandler,\n                adminPost: adminPostHandler,\n                showPost: showPostHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/posts/1');\n            assert.ok(router.isActive('showPost'), 'The showPost handler is active');\n            assert.ok(router.isActive('showPost', posts[1]), 'The showPost handler is active with the appropriate context');\n            assert.ok(!router.isActive('showPost', posts[2]), 'The showPost handler is inactive when the context is different');\n            assert.ok(!router.isActive('adminPost'), 'The adminPost handler is inactive');\n            assert.ok(!router.isActive('showPost', null), 'The showPost handler is inactive with a null context');\n            (0, _test_helpers.transitionTo)(router, 'adminPost', admin, adminPost);\n            assert.ok(router.isActive('adminPost'), 'The adminPost handler is active');\n            assert.ok(router.isActive('adminPost', adminPost), 'The adminPost handler is active with the current context');\n            assert.ok(router.isActive('adminPost', admin, adminPost), 'The adminPost handler is active with the current and parent context');\n            assert.ok(router.isActive('admin'), 'The admin handler is active');\n            assert.ok(router.isActive('admin', admin), 'The admin handler is active with its context');\n        });\n        (0, _test_helpers.test)('calling generate on a non-dynamic route does not blow away parent contexts', function (assert) {\n            map(assert, function (match) {\n                match('/projects').to('projects', function (match) {\n                    match('/').to('projectsIndex');\n                    match('/project').to('project', function (match) {\n                        match('/').to('projectIndex');\n                    });\n                });\n            });\n            var projects = {};\n            routes = {\n                projects: (0, _test_helpers.createHandler)('projects', {\n                    model: function model() {\n                        return projects;\n                    }\n                })\n            };\n            router.handleURL('/projects').then(function () {\n                assert.equal(routes.projects.context, projects, 'projects handler has correct context');\n                router.generate('projectIndex');\n                assert.equal(routes.projects.context, projects, 'projects handler retains correct context');\n            });\n        });\n        (0, _test_helpers.test)('calling transitionTo on a dynamic parent route causes non-dynamic child context to be updated', function (assert) {\n            map(assert, function (match) {\n                match('/project/:project_id').to('project', function (match) {\n                    match('/').to('projectIndex');\n                });\n            });\n            var projectHandler = (0, _test_helpers.createHandler)('project', {\n                model: function model(params) {\n                    delete params.queryParams;\n                    return params;\n                }\n            });\n            var projectIndexHandler = (0, _test_helpers.createHandler)('projectIndex', {\n                model: function model(_params, transition) {\n                    return transition.resolvedModels.project;\n                }\n            });\n            routes = {\n                project: projectHandler,\n                projectIndex: projectIndexHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/project/1');\n            assert.deepEqual(projectHandler.context, { project_id: '1' }, 'project handler retains correct context');\n            assert.deepEqual(projectIndexHandler.context, { project_id: '1' }, 'project index handler has correct context');\n            router.generate('projectIndex', { project_id: '2' });\n            assert.deepEqual(projectHandler.context, { project_id: '1' }, 'project handler retains correct context');\n            assert.deepEqual(projectIndexHandler.context, { project_id: '1' }, 'project index handler retains correct context');\n            (0, _test_helpers.transitionTo)(router, 'projectIndex', { project_id: '2' });\n            assert.deepEqual(projectHandler.context, { project_id: '2' }, 'project handler has updated context');\n            assert.deepEqual(projectIndexHandler.context, { project_id: '2' }, 'project index handler has updated context');\n        });\n        (0, _test_helpers.test)('reset exits and clears the current and target route handlers', function (assert) {\n            var postIndexExited = false;\n            var showAllPostsExited = false;\n            var steps = 0;\n            assert.equal(++steps, 1);\n            var postIndexHandler = (0, _test_helpers.createHandler)('postIndex', {\n                exit: function exit() {\n                    postIndexExited = true;\n                    assert.equal(++steps, 4);\n                }\n            });\n            var showAllPostsHandler = (0, _test_helpers.createHandler)('showAllPosts', {\n                exit: function exit() {\n                    showAllPostsExited = true;\n                    assert.equal(++steps, 3);\n                }\n            });\n            routes = {\n                postIndex: postIndexHandler,\n                showAllPosts: showAllPostsHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/posts/all');\n            assert.equal(++steps, 2);\n            router.reset();\n            assert.ok(postIndexExited, 'Post index handler did not exit');\n            assert.ok(showAllPostsExited, 'Show all posts handler did not exit');\n            assert.equal(router.currentRouteInfos, null, 'currentHandlerInfos should be null');\n        });\n        (0, _test_helpers.test)('any of the model hooks can redirect with or without promise', function (assert) {\n            assert.expect(26);\n            var setupShouldBeEntered = false;\n            var returnPromise = false;\n            var redirectTo = void 0;\n            function redirectToAbout() {\n                if (returnPromise) {\n                    return (0, _rsvp.reject)().then(null, function () {\n                        router.transitionTo(redirectTo);\n                    });\n                } else {\n                    router.transitionTo(redirectTo);\n                }\n                return;\n            }\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    beforeModel: redirectToAbout,\n                    model: redirectToAbout,\n                    afterModel: redirectToAbout,\n                    setup: function setup() {\n                        assert.ok(setupShouldBeEntered, 'setup should be entered at this time');\n                    }\n                }),\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(true, \"about handler's setup function was called\");\n                    }\n                }),\n                borf: (0, _test_helpers.createHandler)('borf', {\n                    setup: function setup() {\n                        assert.ok(true, 'borf setup entered');\n                    }\n                })\n            };\n            function testStartup(assert, firstExpectedURL) {\n                map(assert, function (match) {\n                    match('/').to('index');\n                    match('/about').to('about');\n                    match('/foo').to('foo');\n                    match('/borf').to('borf');\n                });\n                redirectTo = 'about';\n                // Perform a redirect on startup.\n                expectedUrl = firstExpectedURL || '/about';\n                (0, _test_helpers.transitionTo)(router, '/');\n                expectedUrl = '/borf';\n                redirectTo = 'borf';\n                (0, _test_helpers.transitionTo)(router, 'index');\n            }\n            testStartup(assert);\n            returnPromise = true;\n            testStartup(assert);\n            delete routes.index.beforeModel;\n            returnPromise = false;\n            testStartup(assert);\n            returnPromise = true;\n            testStartup(assert);\n            delete routes.index.model;\n            returnPromise = false;\n            testStartup(assert);\n            returnPromise = true;\n            testStartup(assert);\n            delete routes.index.afterModel;\n            setupShouldBeEntered = true;\n            testStartup(assert, '/');\n        });\n        (0, _test_helpers.test)('transitionTo with a promise pauses the transition until resolve, passes resolved context to setup', function (assert) {\n            routes = {\n                index: (0, _test_helpers.createHandler)('index'),\n                showPost: (0, _test_helpers.createHandler)('showPost', {\n                    setup: function setup(context) {\n                        assert.deepEqual(context, { id: 1 }, 'setup receives a resolved context');\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, '/index');\n            (0, _test_helpers.transitionTo)(router, 'showPost', new _rsvp.Promise(function (resolve) {\n                resolve({ id: 1 });\n            }));\n        });\n        (0, _test_helpers.test)('error handler gets called for errors in validation hooks', function (assert) {\n            assert.expect(25);\n            var setupShouldBeEntered = false;\n            var expectedReason = { reason: 'No funciona, mon frere.' };\n            function throwAnError() {\n                return (0, _rsvp.reject)(expectedReason);\n            }\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    beforeModel: throwAnError,\n                    model: throwAnError,\n                    afterModel: throwAnError,\n                    events: {\n                        error: function error(reason) {\n                            assert.equal(reason, expectedReason, \"the value passed to the error handler is what was 'thrown' from the hook\");\n                        }\n                    },\n                    setup: function setup() {\n                        assert.ok(setupShouldBeEntered, 'setup should be entered at this time');\n                    }\n                }),\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(true, \"about handler's setup function was called\");\n                    }\n                })\n            };\n            function testStartup(assert) {\n                map(assert, function (match) {\n                    match('/').to('index');\n                    match('/about').to('about');\n                });\n                // Perform a redirect on startup.\n                return router.handleURL('/').then(null, function (reason) {\n                    assert.equal(reason, expectedReason, 'handleURL error reason is what was originally thrown');\n                    return router.transitionTo('index').then((0, _test_helpers.shouldNotHappen)(assert), function (newReason) {\n                        assert.equal(newReason, expectedReason, 'transitionTo error reason is what was originally thrown');\n                    });\n                });\n            }\n            testStartup(assert).then(function () {\n                return testStartup(assert);\n            }).then(function () {\n                delete routes.index.beforeModel;\n                return testStartup(assert);\n            }).then(function () {\n                return testStartup(assert);\n            }).then(function () {\n                delete routes.index.model;\n                return testStartup(assert);\n            }).then(function () {\n                return testStartup(assert);\n            }).then(function () {\n                delete routes.index.afterModel;\n                setupShouldBeEntered = true;\n                return testStartup(assert);\n            });\n        });\n        (0, _test_helpers.test)(\"Errors shouldn't be handled after proceeding to next child route\", function (assert) {\n            assert.expect(3);\n            map(assert, function (match) {\n                match('/parent').to('parent', function (match) {\n                    match('/articles').to('articles');\n                    match('/login').to('login');\n                });\n            });\n            routes = {\n                articles: (0, _test_helpers.createHandler)('articles', {\n                    beforeModel: function beforeModel() {\n                        assert.ok(true, 'articles beforeModel was entered');\n                        return (0, _rsvp.reject)('blorg');\n                    },\n                    events: {\n                        error: function error() {\n                            assert.ok(true, 'error handled in articles');\n                            router.transitionTo('login');\n                        }\n                    }\n                }),\n                login: (0, _test_helpers.createHandler)('login', {\n                    setup: function setup() {\n                        assert.ok(true, 'login#setup');\n                    }\n                }),\n                parent: (0, _test_helpers.createHandler)('parent', {\n                    events: {\n                        error: function error() {\n                            assert.ok(false, \"handled error shouldn't bubble up to parent route\");\n                        }\n                    }\n                })\n            };\n            router.handleURL('/parent/articles');\n        });\n        (0, _test_helpers.test)(\"Error handling shouldn't trigger for transitions that are already aborted\", function (assert) {\n            assert.expect(1);\n            map(assert, function (match) {\n                match('/slow_failure').to('slow_failure');\n                match('/good').to('good');\n            });\n            routes = {\n                slow_failure: (0, _test_helpers.createHandler)('showFailure', {\n                    model: function model() {\n                        return new _rsvp.Promise(function (_res, rej) {\n                            router.transitionTo('good');\n                            rej();\n                        });\n                    },\n                    events: {\n                        error: function error() {\n                            assert.ok(false, \"error handling shouldn't fire\");\n                        }\n                    }\n                }),\n                good: (0, _test_helpers.createHandler)('good', {\n                    setup: function setup() {\n                        assert.ok(true, 'good#setup');\n                    }\n                })\n            };\n            router.handleURL('/slow_failure');\n            (0, _test_helpers.flushBackburner)();\n        });\n        (0, _test_helpers.test)('Transitions to the same destination as the active transition just return the active transition', function (assert) {\n            assert.expect(1);\n            var transition0 = router.handleURL('/index');\n            var transition1 = router.handleURL('/index');\n            assert.equal(transition0, transition1);\n            (0, _test_helpers.flushBackburner)();\n        });\n        (0, _test_helpers.test)('can redirect from error handler', function (assert) {\n            assert.expect(4);\n            var errorCount = 0;\n            routes = {\n                index: (0, _test_helpers.createHandler)('index'),\n                showPost: (0, _test_helpers.createHandler)('showPost', {\n                    model: function model() {\n                        return (0, _rsvp.reject)('borf!');\n                    },\n                    events: {\n                        error: function error(e) {\n                            errorCount++;\n                            assert.equal(e, 'borf!', 'received error thrown from model');\n                            // Redirect to index.\n                            router.transitionTo('index').then(function () {\n                                if (errorCount === 1) {\n                                    // transition back here to test transitionTo error handling.\n                                    return router.transitionTo('showPost', (0, _rsvp.reject)('borf!')).then((0, _test_helpers.shouldNotHappen)(assert), function (e) {\n                                        assert.equal(e, 'borf!', 'got thing');\n                                    });\n                                }\n                                return;\n                            }, (0, _test_helpers.shouldNotHappen)(assert));\n                        }\n                    },\n                    setup: function setup() {\n                        assert.ok(false, 'should not get here');\n                    }\n                })\n            };\n            router.handleURL('/posts/123').then((0, _test_helpers.shouldNotHappen)(assert), function (reason) {\n                assert.equal(reason, 'borf!', 'expected reason received from first failed transition');\n            });\n        });\n        (0, _test_helpers.test)('can redirect from setup/enter', function (assert) {\n            assert.expect(5);\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    enter: function enter() {\n                        assert.ok(true, 'index#enter called');\n                        router.transitionTo('about').then(secondAttempt, (0, _test_helpers.shouldNotHappen)(assert));\n                    },\n                    setup: function setup() {\n                        assert.ok(true, 'index#setup called');\n                        router.transitionTo('/about').then(thirdAttempt, (0, _test_helpers.shouldNotHappen)(assert));\n                    },\n                    events: {\n                        error: function error() {\n                            assert.ok(false, 'redirects should not call error hook');\n                        }\n                    }\n                }),\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(true, 'about#setup was entered');\n                    }\n                })\n            };\n            router.handleURL('/index').then((0, _test_helpers.shouldNotHappen)(assert), (0, _test_helpers.assertAbort)(assert));\n            function secondAttempt() {\n                delete routes.index.enter;\n                router.transitionTo('index').then((0, _test_helpers.shouldNotHappen)(assert), (0, _test_helpers.assertAbort)(assert));\n            }\n            function thirdAttempt() {\n                delete routes.index.setup;\n                router.transitionTo('index').then(null, (0, _test_helpers.shouldNotHappen)(assert));\n            }\n        });\n        (0, _test_helpers.test)('redirecting to self from validation hooks should no-op (and not infinite loop)', function (assert) {\n            assert.expect(2);\n            var count = 0;\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    afterModel: function afterModel() {\n                        if (count++ > 10) {\n                            assert.ok(false, 'infinite loop occurring');\n                        } else {\n                            assert.ok(count <= 2, 'running index no more than twice');\n                            router.transitionTo('index');\n                        }\n                    },\n                    setup: function setup() {\n                        assert.ok(true, 'setup was called');\n                    }\n                })\n            };\n            router.handleURL('/index');\n        });\n        (0, _test_helpers.test)('Transition#method(null) prevents URLs from updating', function (assert) {\n            assert.expect(1);\n            routes = {\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(true, 'about#setup was called');\n                    }\n                })\n            };\n            router.updateURL = function () {\n                assert.ok(false, \"updateURL shouldn't have been called\");\n            };\n            // Test multiple calls to method in a row.\n            router.handleURL('/index').method(null);\n            router.handleURL('/index').method(null);\n            (0, _test_helpers.flushBackburner)();\n            router.transitionTo('about').method(null);\n            (0, _test_helpers.flushBackburner)();\n        });\n        (0, _test_helpers.test)('redirecting to self from enter hooks should no-op (and not infinite loop)', function (assert) {\n            assert.expect(1);\n            var count = 0;\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    setup: function setup() {\n                        if (count++ > 10) {\n                            assert.ok(false, 'infinite loop occurring');\n                        } else {\n                            assert.ok(true, 'setup was called');\n                            router.transitionTo('index');\n                        }\n                    }\n                })\n            };\n            router.handleURL('/index');\n        });\n        (0, _test_helpers.test)('redirecting to child handler from validation hooks should no-op (and not infinite loop)', function (assert) {\n            assert.expect(4);\n            routes = {\n                postIndex: (0, _test_helpers.createHandler)('postIndex', {\n                    beforeModel: function beforeModel() {\n                        assert.ok(true, 'postIndex beforeModel called');\n                        router.transitionTo('showAllPosts');\n                    }\n                }),\n                showAllPosts: (0, _test_helpers.createHandler)('showAllPosts', {\n                    beforeModel: function beforeModel() {\n                        assert.ok(true, 'showAllPosts beforeModel called');\n                    }\n                }),\n                showPopularPosts: (0, _test_helpers.createHandler)('showPopularPosts', {\n                    beforeModel: function beforeModel() {\n                        assert.ok(true, 'showPopularPosts beforeModel called');\n                    }\n                })\n            };\n            router.handleURL('/posts/popular').then(function () {\n                assert.ok(false, 'redirected handleURL should not succeed');\n            }, function () {\n                assert.ok(true, 'redirected handleURL should fail');\n            });\n        });\n        function startUpSetup(assert) {\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    setup: function setup() {\n                        assert.ok(true, 'index setup called');\n                    }\n                }),\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(true, 'about setup called');\n                    }\n                }),\n                faq: (0, _test_helpers.createHandler)('faq', {\n                    setup: function setup() {\n                        assert.ok(true, 'faq setup called');\n                    }\n                })\n            };\n        }\n        (0, _test_helpers.test)('transitionTo with named transition can be called at startup', function (assert) {\n            assert.expect(2);\n            startUpSetup(assert);\n            router.transitionTo('index').then(function () {\n                assert.ok(true, 'success handler called');\n            }, function () {\n                assert.ok(false, 'failure handle should not be called');\n            });\n        });\n        (0, _test_helpers.test)('transitionTo with URL transition can be called at startup', function (assert) {\n            assert.expect(2);\n            startUpSetup(assert);\n            router.transitionTo('/index').then(function () {\n                assert.ok(true, 'success handler called');\n            }, function () {\n                assert.ok(false, 'failure handle should not be called');\n            });\n        });\n        (0, _test_helpers.test)('transitions fire a didTransition event on the destination route', function (assert) {\n            assert.expect(1);\n            routes = {\n                about: (0, _test_helpers.createHandler)('about', {\n                    events: {\n                        didTransition: function didTransition() {\n                            assert.ok(true, \"index's didTransition was called\");\n                        }\n                    }\n                })\n            };\n            router.handleURL('/index').then(function () {\n                router.transitionTo('about');\n            }, (0, _test_helpers.shouldNotHappen)(assert));\n        });\n        (0, _test_helpers.test)('willTransition function fired before route change', function (assert) {\n            assert.expect(1);\n            var beforeModelNotCalled = true;\n            routes = {\n                about: (0, _test_helpers.createHandler)('about', {\n                    beforeModel: function beforeModel() {\n                        beforeModelNotCalled = false;\n                    }\n                })\n            };\n            router.willTransition = function () {\n                assert.ok(beforeModelNotCalled, 'about beforeModel hook should not be called at this time');\n            };\n            router.handleURL('/about');\n        });\n        (0, _test_helpers.test)('willTransition function fired with handler infos passed in', function (assert) {\n            assert.expect(2);\n            router.handleURL('/about').then(function () {\n                router.willTransition = function (fromInfos, toInfos) {\n                    assert.equal(routePath(fromInfos), 'about', 'first argument should be the old handler infos');\n                    assert.equal(routePath(toInfos), 'postIndex.showPopularPosts', 'second argument should be the new handler infos');\n                };\n                router.handleURL('/posts/popular');\n            });\n        });\n        (0, _test_helpers.test)('willTransition function fired with cancellable transition passed in', function (assert) {\n            assert.expect(2);\n            router.handleURL('/index').then(function () {\n                router.willTransition = function (_fromInfos, _toInfos, transition) {\n                    assert.ok(true, \"index's transitionTo was called\");\n                    transition.abort();\n                };\n                return router.transitionTo('about').then((0, _test_helpers.shouldNotHappen)(assert), (0, _test_helpers.assertAbort)(assert));\n            });\n        });\n        (0, _test_helpers.test)('transitions can be aborted in the willTransition event', function (assert) {\n            assert.expect(3);\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    setup: function setup() {\n                        assert.ok(true, 'index setup called');\n                    },\n                    events: {\n                        willTransition: function willTransition(transition) {\n                            assert.ok(true, \"index's transitionTo was called\");\n                            transition.abort();\n                        }\n                    }\n                }),\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(true, 'about setup called');\n                    }\n                })\n            };\n            router.handleURL('/index').then(function () {\n                return router.transitionTo('about').then((0, _test_helpers.shouldNotHappen)(assert), (0, _test_helpers.assertAbort)(assert));\n            });\n        });\n        (0, _test_helpers.test)('transitions can redirected in the willTransition event', function (assert) {\n            assert.expect(2);\n            var destFlag = true;\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    setup: function setup() {\n                        assert.ok(true, 'index setup called');\n                    },\n                    events: {\n                        willTransition: function willTransition() {\n                            // Router code must be careful here not to refire\n                            // `willTransition` when a transition is already\n                            // underway, else infinite loop.\n                            var dest = destFlag ? 'about' : 'faq';\n                            destFlag = !destFlag;\n                            router.transitionTo(dest);\n                        }\n                    }\n                }),\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(true, 'about setup called');\n                    }\n                }),\n                faq: (0, _test_helpers.createHandler)('faq', {\n                    setup: function setup() {\n                        assert.ok(false, 'faq setup should not be called');\n                    }\n                })\n            };\n            router.handleURL('/index').then(function () {\n                router.transitionTo('faq');\n            });\n        });\n        (0, _test_helpers.test)('transitions that abort and enter into a substate', function (assert) {\n            assert.expect(3);\n            routes = {\n                index: (0, _test_helpers.createHandler)('index'),\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(true, 'about setup called');\n                    },\n                    events: {\n                        willTransition: function willTransition(transition) {\n                            assert.ok(true, 'willTransition');\n                            transition.abort();\n                            router.intermediateTransitionTo('faq');\n                        }\n                    }\n                }),\n                faq: (0, _test_helpers.createHandler)('faq', {\n                    setup: function setup() {\n                        assert.ok(true, 'faq setup called');\n                    }\n                })\n            };\n            router.handleURL('/about').then(function () {\n                return router.transitionTo('index');\n            });\n        });\n        (0, _test_helpers.test)('aborted transitions can be saved and later retried', function (assert) {\n            assert.expect(9);\n            var shouldPrevent = true,\n                transitionToAbout = void 0,\n                lastTransition = void 0,\n                retryTransition = void 0;\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    setup: function setup() {\n                        assert.ok(true, 'index setup called');\n                    },\n                    events: {\n                        willTransition: function willTransition(transition) {\n                            assert.ok(true, \"index's willTransition was called\");\n                            if (shouldPrevent) {\n                                transition.data.foo = 'hello';\n                                transition.foo = 'hello';\n                                transition.abort();\n                                lastTransition = transition;\n                            } else {\n                                assert.ok(!transition.foo, 'no foo property exists on new transition');\n                                assert.equal(transition.data.foo, 'hello', 'values stored in data hash of old transition persist when retried');\n                            }\n                        }\n                    }\n                }),\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(true, 'about setup called');\n                    }\n                })\n            };\n            router.handleURL('/index').then(function () {\n                router.transitionTo('about').then((0, _test_helpers.shouldNotHappen)(assert), function () {\n                    assert.ok(true, 'transition was blocked');\n                    shouldPrevent = false;\n                    transitionToAbout = lastTransition;\n                    retryTransition = transitionToAbout.retry();\n                    assert.equal(retryTransition.urlMethod, 'update');\n                    return retryTransition;\n                }).then(function () {\n                    assert.ok(true, 'transition succeeded via .retry()');\n                }, (0, _test_helpers.shouldNotHappen)(assert));\n            });\n        });\n        (0, _test_helpers.test)('aborted transitions can be saved and later retried asynchronously', function (assert) {\n            assert.expect(2);\n            var abortedTransition = void 0;\n            var shouldPrevent = true;\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    events: {\n                        willTransition: function willTransition(transition) {\n                            if (shouldPrevent) {\n                                abortedTransition = transition.abort();\n                                router.intermediateTransitionTo('loading');\n                            }\n                        }\n                    }\n                }),\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(true, 'about setup called');\n                    }\n                }),\n                loading: (0, _test_helpers.createHandler)('loading', {\n                    setup: function setup() {\n                        assert.ok(true, 'loading setup called');\n                    }\n                })\n            };\n            router.handleURL('/index').then(function () {\n                return router.transitionTo('about').then((0, _test_helpers.shouldNotHappen)(assert), function () {\n                    shouldPrevent = false;\n                    return new _rsvp.Promise(function (resolve) {\n                        var transition = abortedTransition.retry();\n                        resolve(transition);\n                    });\n                }).then(function () {\n                    assert.ok(true, 'transition succeeded via .retry()');\n                }, (0, _test_helpers.shouldNotHappen)(assert)).catch((0, _test_helpers.shouldNotHappen)(assert));\n            });\n        });\n        (0, _test_helpers.test)('if an aborted transition is retried, it preserves the urlMethod of the original one', function (assert) {\n            assert.expect(9);\n            var shouldPrevent = true,\n                transitionToAbout = void 0,\n                lastTransition = void 0,\n                retryTransition = void 0;\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    setup: function setup() {\n                        assert.ok(true, 'index setup called');\n                    },\n                    events: {\n                        willTransition: function willTransition(transition) {\n                            assert.ok(true, \"index's willTransition was called\");\n                            if (shouldPrevent) {\n                                transition.data.foo = 'hello';\n                                transition.foo = 'hello';\n                                transition.abort();\n                                lastTransition = transition;\n                            } else {\n                                assert.ok(!transition.foo, 'no foo property exists on new transition');\n                                assert.equal(transition.data.foo, 'hello', 'values stored in data hash of old transition persist when retried');\n                            }\n                        }\n                    }\n                }),\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(true, 'about setup called');\n                    }\n                })\n            };\n            router.handleURL('/index').then(function () {\n                router.replaceWith('about').then((0, _test_helpers.shouldNotHappen)(assert), function () {\n                    assert.ok(true, 'transition was blocked');\n                    shouldPrevent = false;\n                    transitionToAbout = lastTransition;\n                    retryTransition = transitionToAbout.retry();\n                    assert.equal(retryTransition.urlMethod, 'replace');\n                    return transitionToAbout.retry();\n                }).then(function () {\n                    assert.ok(true, 'transition succeeded via .retry()');\n                }, (0, _test_helpers.shouldNotHappen)(assert));\n            });\n        });\n        (0, _test_helpers.test)('if an initial transition is aborted during validation phase and later retried', function (assert) {\n            assert.expect(7);\n            var shouldRedirectToLogin = true;\n            var currentURL = '/login';\n            var urlStack = [];\n            var lastTransition = void 0;\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/login').to('login');\n            });\n            router.updateURL = function (url) {\n                urlStack.push(['updateURL', url]);\n                currentURL = url;\n            };\n            router.replaceURL = function (url) {\n                urlStack.push(['replaceURL', url]);\n                currentURL = url;\n            };\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    beforeModel: function beforeModel(transition) {\n                        assert.ok(true, 'index model called');\n                        if (shouldRedirectToLogin) {\n                            lastTransition = transition;\n                            return router.transitionTo('/login');\n                        }\n                        return;\n                    }\n                }),\n                login: (0, _test_helpers.createHandler)('login', {\n                    setup: function setup() {\n                        assert.ok('login setup called');\n                    }\n                })\n            };\n            // use `handleURL` to emulate initial transition properly\n            (0, _test_helpers.handleURL)(router, '/').then((0, _test_helpers.shouldNotHappen)(assert, 'initial transition aborted'), function () {\n                assert.equal(currentURL, '/login', 'currentURL matches');\n                assert.deepEqual(urlStack, [['replaceURL', '/login']]);\n                shouldRedirectToLogin = false;\n                return lastTransition.retry();\n            }).then(function () {\n                assert.equal(currentURL, '/', 'after retry currentURL is updated');\n                assert.deepEqual(urlStack, [['replaceURL', '/login'], ['updateURL', '/']]);\n            }, (0, _test_helpers.shouldNotHappen)(assert, 'final catch'));\n        });\n        (0, _test_helpers.test)('completed transitions can be saved and later retried', function (assert) {\n            assert.expect(8);\n            var post = { id: '123' },\n                savedTransition = void 0;\n            routes = {\n                showPost: (0, _test_helpers.createHandler)('showPost', {\n                    afterModel: function afterModel(model, transition) {\n                        if (savedTransition === undefined) {\n                            assert.equal(transition.from && transition.from.localName, 'index', 'starting point');\n                        } else {\n                            assert.equal(transition.from && transition.from.localName, 'about', 'new starting point');\n                        }\n                        assert.equal(transition.to && transition.to.localName, 'showPost', 'to points at leaf');\n                        assert.equal(model, post, \"showPost's afterModel got the expected post model\");\n                        savedTransition = transition;\n                    }\n                }),\n                index: (0, _test_helpers.createHandler)('index', {\n                    model: function model(_params, transition) {\n                        assert.equal(transition.from, null);\n                    }\n                }),\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(true, 'setup was entered');\n                    }\n                })\n            };\n            router.handleURL('/index').then(function () {\n                return router.transitionTo('showPost', post);\n            }).then(function () {\n                return router.transitionTo('about');\n            }).then(function () {\n                return savedTransition.retry();\n            });\n        });\n        function setupAuthenticatedExample(assert) {\n            map(assert, function (match) {\n                match('/index').to('index');\n                match('/login').to('login');\n                match('/admin').to('admin', function (match) {\n                    match('/about').to('about');\n                    match('/posts/:post_id').to('adminPost');\n                });\n            });\n            var isLoggedIn = false,\n                lastRedirectedTransition = void 0;\n            routes = {\n                index: (0, _test_helpers.createHandler)('index'),\n                login: (0, _test_helpers.createHandler)('login', {\n                    events: {\n                        logUserIn: function logUserIn() {\n                            isLoggedIn = true;\n                            lastRedirectedTransition.retry();\n                        }\n                    }\n                }),\n                admin: (0, _test_helpers.createHandler)('admin', {\n                    beforeModel: function beforeModel(transition) {\n                        lastRedirectedTransition = transition;\n                        assert.ok(true, 'beforeModel redirect was called');\n                        if (!isLoggedIn) {\n                            router.transitionTo('login');\n                        }\n                    }\n                }),\n                about: (0, _test_helpers.createHandler)('about', {\n                    setup: function setup() {\n                        assert.ok(isLoggedIn, 'about was entered only after user logged in');\n                    }\n                }),\n                adminPost: (0, _test_helpers.createHandler)('adminPost', {\n                    model: function model(params) {\n                        assert.deepEqual(params, { post_id: '5', queryParams: {} }, 'adminPost received params previous transition attempt');\n                        return 'adminPost';\n                    },\n                    setup: function setup(model) {\n                        assert.equal(model, 'adminPost', 'adminPost was entered with correct model');\n                    }\n                })\n            };\n        }\n        (0, _test_helpers.test)('authenticated routes: starting on non-auth route', function (assert) {\n            assert.expect(8);\n            setupAuthenticatedExample(assert);\n            (0, _test_helpers.transitionTo)(router, '/index');\n            (0, _test_helpers.transitionToWithAbort)(assert, router, 'about');\n            (0, _test_helpers.transitionToWithAbort)(assert, router, 'about');\n            (0, _test_helpers.transitionToWithAbort)(assert, router, '/admin/about');\n            // Log in. This will retry the last failed transition to 'about'.\n            router.trigger('logUserIn');\n        });\n        (0, _test_helpers.test)('authenticated routes: starting on auth route', function (assert) {\n            assert.expect(8);\n            setupAuthenticatedExample(assert);\n            (0, _test_helpers.transitionToWithAbort)(assert, router, '/admin/about');\n            (0, _test_helpers.transitionToWithAbort)(assert, router, '/admin/about');\n            (0, _test_helpers.transitionToWithAbort)(assert, router, 'about');\n            // Log in. This will retry the last failed transition to 'about'.\n            router.trigger('logUserIn');\n        });\n        (0, _test_helpers.test)('authenticated routes: starting on parameterized auth route', function (assert) {\n            assert.expect(5);\n            setupAuthenticatedExample(assert);\n            (0, _test_helpers.transitionToWithAbort)(assert, router, '/admin/posts/5');\n            // Log in. This will retry the last failed transition to '/posts/5'.\n            router.trigger('logUserIn');\n        });\n        (0, _test_helpers.test)('An instantly aborted transition fires no hooks', function (assert) {\n            assert.expect(8);\n            var hooksShouldBeCalled = false;\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    beforeModel: function beforeModel(transition) {\n                        assert.equal(transition.from, null, 'from is \"null\" on initial transitions even with aborts');\n                        assert.ok(hooksShouldBeCalled, 'index beforeModel hook should be called at this time');\n                    }\n                }),\n                about: (0, _test_helpers.createHandler)('about', {\n                    beforeModel: function beforeModel() {\n                        assert.ok(hooksShouldBeCalled, 'about beforeModel hook should be called at this time');\n                    }\n                })\n            };\n            router.transitionTo('index').abort().then((0, _test_helpers.shouldNotHappen)(assert), function () {\n                assert.ok(true, 'Failure handler called for index');\n                return router.transitionTo('/index').abort();\n            }).then((0, _test_helpers.shouldNotHappen)(assert), function () {\n                assert.ok(true, 'Failure handler called for /index');\n                hooksShouldBeCalled = true;\n                return router.transitionTo('index');\n            }).then(function () {\n                assert.ok(true, 'Success handler called for index');\n                hooksShouldBeCalled = false;\n                return router.transitionTo('about').abort();\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then((0, _test_helpers.shouldNotHappen)(assert), function () {\n                assert.ok(true, 'failure handler called for about');\n                return router.transitionTo('/about').abort();\n            }).then((0, _test_helpers.shouldNotHappen)(assert), function () {\n                assert.ok(true, 'failure handler called for /about');\n                hooksShouldBeCalled = true;\n                return router.transitionTo('/about');\n            });\n        });\n        (0, _test_helpers.test)('a successful transition resolves with the target handler', function (assert) {\n            assert.expect(2);\n            // Note: this is extra convenient for Ember where you can all\n            // .transitionTo right on the route.\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', { borfIndex: true }),\n                about: (0, _test_helpers.createHandler)('about', { borfAbout: true })\n            };\n            router.handleURL('/index').then(function (route) {\n                assert.ok(route['borfIndex'], 'resolved to index handler');\n                return router.transitionTo('about');\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then(function (result) {\n                assert.ok(result.borfAbout, 'resolved to about handler');\n            });\n        });\n        (0, _test_helpers.test)('transitions have a .promise property', function (assert) {\n            assert.expect(2);\n            router.handleURL('/index').promise.then(function () {\n                var promise = router.transitionTo('about').abort().promise;\n                assert.ok(promise, 'promise exists on aborted transitions');\n                return promise;\n            }, (0, _test_helpers.shouldNotHappen)(assert)).then((0, _test_helpers.shouldNotHappen)(assert), function () {\n                assert.ok(true, 'failure handler called');\n            });\n        });\n        (0, _test_helpers.test)('the serialize function is bound to the correct object when called', function (assert) {\n            assert.expect(scenario.async ? 0 : 1);\n            routes = {\n                showPostsForDate: (0, _test_helpers.createHandler)('showPostsForDate', {\n                    serialize: function serialize(date) {\n                        assert.equal(this, routes.showPostsForDate);\n                        return {\n                            date: date.getFullYear() + '-' + date.getMonth() + '-' + date.getDate()\n                        };\n                    }\n                })\n            };\n            router.generate('showPostsForDate', new Date(1815, 5, 18));\n        });\n        (0, _test_helpers.test)('transitionTo will soak up resolved parent models of active transition', function (assert) {\n            assert.expect(5);\n            var admin = { id: 47 },\n                adminPost = { id: 74 },\n                adminSetupShouldBeEntered = false;\n            function adminPromise() {\n                return new _rsvp.Promise(function (res) {\n                    res(admin);\n                });\n            }\n            var adminHandler = (0, _test_helpers.createHandler)('admin', {\n                serialize: function serialize(object) {\n                    assert.equal(object.id, 47, 'The object passed to serialize is correct');\n                    return { id: 47 };\n                },\n                model: function model(params) {\n                    assert.equal(params.id, 47, 'The object passed to serialize is correct');\n                    return admin;\n                },\n                setup: function setup() {\n                    assert.ok(adminSetupShouldBeEntered, \"adminHandler's setup should be called at this time\");\n                }\n            });\n            var adminPostHandler = (0, _test_helpers.createHandler)('adminPost', {\n                serialize: function serialize(object) {\n                    return { post_id: object.id };\n                },\n                setup: function setup() {\n                    assert.equal(adminHandler.context, admin, 'adminPostHandler receives resolved soaked promise from previous transition');\n                },\n                model: function model() {\n                    return adminPost;\n                }\n            });\n            var adminPostsHandler = (0, _test_helpers.createHandler)('adminPosts', {\n                beforeModel: function beforeModel() {\n                    adminSetupShouldBeEntered = true;\n                    router.transitionTo('adminPost', adminPost);\n                }\n            });\n            var indexHandler = (0, _test_helpers.createHandler)('index', {\n                setup: function setup() {\n                    assert.ok(true, 'index entered');\n                }\n            });\n            routes = {\n                index: indexHandler,\n                admin: adminHandler,\n                adminPost: adminPostHandler,\n                adminPosts: adminPostsHandler\n            };\n            router.transitionTo('index').then(function () {\n                router.transitionTo('adminPosts', adminPromise()).then((0, _test_helpers.shouldNotHappen)(assert), (0, _test_helpers.assertAbort)(assert));\n            });\n        });\n        (0, _test_helpers.test)(\"transitionTo will soak up resolved all models of active transition, including present route's resolved model\", function (assert) {\n            assert.expect(2);\n            var modelCalled = 0,\n                hasRedirected = false;\n            map(assert, function (match) {\n                match('/post').to('post', function (match) {\n                    match('/').to('postIndex');\n                    match('/new').to('postNew');\n                });\n            });\n            var postHandler = (0, _test_helpers.createHandler)('post', {\n                model: function model() {\n                    assert.equal(modelCalled++, 0, \"postHandler's model should only be called once\");\n                    return { title: 'Hello world' };\n                },\n                redirect: function redirect() {\n                    if (!hasRedirected) {\n                        hasRedirected = true;\n                        router.transitionTo('postNew');\n                    }\n                }\n            });\n            routes = {\n                post: postHandler,\n                postIndex: (0, _test_helpers.createHandler)('postIndex'),\n                postNew: (0, _test_helpers.createHandler)('postNew')\n            };\n            router.transitionTo('postIndex').then((0, _test_helpers.shouldNotHappen)(assert), (0, _test_helpers.assertAbort)(assert));\n        });\n        (0, _test_helpers.test)(\"can reference leaf '/' route by leaf or parent name\", function (assert) {\n            map(assert, function (match) {\n                match('/').to('app', function (match) {\n                    match('/').to('index');\n                    match('/nest').to('nest', function (match) {\n                        match('/').to('nest.index');\n                    });\n                });\n            });\n            function assertOnRoute(name) {\n                var last = router.currentRouteInfos[router.currentRouteInfos.length - 1];\n                assert.equal(last.name, name);\n            }\n            (0, _test_helpers.transitionTo)(router, 'app');\n            assertOnRoute('index');\n            (0, _test_helpers.transitionTo)(router, 'nest');\n            assertOnRoute('nest.index');\n            (0, _test_helpers.transitionTo)(router, 'app');\n            assertOnRoute('index');\n        });\n        (0, _test_helpers.test)('resolved models can be swapped out within afterModel', function (assert) {\n            assert.expect(3);\n            var modelPre = {},\n                modelPost = {};\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    model: function model() {\n                        return modelPre;\n                    },\n                    afterModel: function afterModel(resolvedModel, transition) {\n                        assert.equal(resolvedModel, transition.resolvedModels.index, \"passed-in resolved model equals model in transition's hash\");\n                        assert.equal(resolvedModel, modelPre, 'passed-in resolved model equals model returned from `model`');\n                        transition.resolvedModels.index = modelPost;\n                    },\n                    setup: function setup(model) {\n                        assert.equal(model, modelPost, 'the model passed to `setup` is the one substituted in afterModel');\n                    }\n                })\n            };\n            router.transitionTo('index');\n        });\n        (0, _test_helpers.test)('String/number args in transitionTo are treated as url params', function (assert) {\n            assert.expect(11);\n            var adminParams = { id: '1' },\n                adminModel = { id: '1' },\n                adminPostModel = { id: '2' };\n            routes = {\n                admin: (0, _test_helpers.createHandler)('admin', {\n                    model: function model(params) {\n                        delete params.queryParams;\n                        assert.deepEqual(params, adminParams, 'admin handler gets the number passed in via transitionTo, converts to string');\n                        return adminModel;\n                    }\n                }),\n                adminPost: (0, _test_helpers.createHandler)('adminPost', {\n                    model: function model(params) {\n                        delete params.queryParams;\n                        assert.deepEqual(params, { post_id: '2' }, 'adminPost handler gets the string passed in via transitionTo');\n                        return adminPostModel;\n                    },\n                    setup: function setup() {\n                        assert.ok(true, 'adminPost setup was entered');\n                    }\n                })\n            };\n            router.handleURL('/index').then(function () {\n                expectedUrl = '/posts/admin/1/posts/2';\n                return router.transitionTo('adminPost', 1, '2');\n            }).then(function () {\n                assert.ok(router.isActive('adminPost', 1, '2'), 'adminPost is active via params');\n                assert.ok(router.isActive('adminPost', 1, adminPostModel), 'adminPost is active via contexts');\n                adminParams = { id: '0' };\n                expectedUrl = '/posts/admin/0/posts/2';\n                return router.transitionTo('adminPost', 0, '2');\n            }).then(function () {\n                assert.ok(router.isActive('adminPost', 0, '2'), 'adminPost is active via params');\n                assert.ok(router.isActive('adminPost', 0, adminPostModel), 'adminPost is active via contexts');\n            }, (0, _test_helpers.shouldNotHappen)(assert));\n        });\n        (0, _test_helpers.test)(\"Transitions returned from beforeModel/model/afterModel hooks aren't treated as pausing promises\", function (assert) {\n            assert.expect(6);\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    beforeModel: function beforeModel() {\n                        assert.ok(true, 'index beforeModel called');\n                        return router.transitionTo('index');\n                    },\n                    model: function model() {\n                        assert.ok(true, 'index model called');\n                        return router.transitionTo('index');\n                    },\n                    afterModel: function afterModel() {\n                        assert.ok(true, 'index afterModel called');\n                        return router.transitionTo('index');\n                    }\n                })\n            };\n            function testStartup(assert) {\n                map(assert, function (match) {\n                    match('/index').to('index');\n                });\n                return router.handleURL('/index');\n            }\n            testStartup(assert).then(function () {\n                delete routes.index.beforeModel;\n                return testStartup(assert);\n            }).then(function () {\n                delete routes.index.model;\n                return testStartup(assert);\n            }).then(function () {\n                delete routes.index.afterModel;\n                return testStartup(assert);\n            });\n        });\n        /* TODO: revisit this idea\n        test(\"exceptions thrown from model hooks aren't swallowed\", function(assert) {\n        assert.expect(7);\n           enableErrorHandlingDeferredActionQueue();\n           let anError = {};\n        function throwAnError() {\n          throw anError;\n        }\n           let routeWasEntered = false;\n           handlers = {\n          index: {\n            beforeModel: throwAnError,\n            model: throwAnError,\n            afterModel: throwAnError,\n            setup: function(model) {\n              routeWasEntered = true;\n            }\n          }\n        };\n           let hooks = ['beforeModel', 'model', 'afterModel'];\n           while(hooks.length) {\n          let transition = router.transitionTo('index');\n          flush(anError);\n          transition.abort();\n          assert.ok(!routeWasEntered, \"route hasn't been entered yet\");\n          delete handlers.index[hooks.shift()];\n        }\n           router.transitionTo('index');\n        flush(anError);\n           assert.ok(routeWasEntered, \"route was finally entered\");\n        });\n        */\n        (0, _test_helpers.test)('Transition#followRedirects() returns a promise that fulfills when any redirecting transitions complete', function (assert) {\n            assert.expect(3);\n            routes.about = (0, _test_helpers.createHandler)('about', {\n                redirect: function redirect() {\n                    router.transitionTo('faq').then(null, (0, _test_helpers.shouldNotHappen)(assert));\n                }\n            });\n            router.transitionTo('/index').followRedirects().then(function (handler) {\n                assert.equal(handler, routes.index, 'followRedirects works with non-redirecting transitions');\n                return router.transitionTo('about').followRedirects();\n            }).then(function (handler) {\n                assert.equal(handler, routes.faq, 'followRedirects promise resolved with redirected faq handler');\n                routes.about.beforeModel = function (transition) {\n                    transition.abort();\n                    return undefined;\n                };\n                // followRedirects should just reject for non-redirecting transitions.\n                return router.transitionTo('about').followRedirects().then((0, _test_helpers.shouldNotHappen)(assert), (0, _test_helpers.assertAbort)(assert));\n            });\n        });\n        (0, _test_helpers.test)(\"Returning a redirecting Transition from a model hook doesn't cause things to explode\", function (assert) {\n            assert.expect(2);\n            routes.index = (0, _test_helpers.createHandler)('index', {\n                beforeModel: function beforeModel() {\n                    return router.transitionTo('about');\n                }\n            });\n            routes.about = (0, _test_helpers.createHandler)('about', {\n                setup: function setup() {\n                    assert.ok(true, 'about#setup was called');\n                }\n            });\n            router.transitionTo('/index').then(null, (0, _test_helpers.assertAbort)(assert));\n        });\n        (0, _test_helpers.test)('Generate works w queryparams', function (assert) {\n            assert.equal(router.generate('index'), '/index', 'just index');\n            assert.equal(router.generate('index', { queryParams: { foo: '123' } }), '/index?foo=123', 'just index');\n            assert.equal(router.generate('index', { queryParams: { foo: '123', bar: '456' } }), '/index?bar=456&foo=123', 'just index');\n        });\n        if (scenario.async) {\n            (0, _test_helpers.test)('Generate does not invoke getHandler', function (assert) {\n                var originalGetHandler = router.getRoute;\n                router.getRoute = function () {\n                    assert.ok(false, 'getHandler should not be called');\n                    return (0, _test_helpers.createHandler)('empty');\n                };\n                assert.equal(router.generate('index'), '/index', 'just index');\n                assert.equal(router.generate('index', { queryParams: { foo: '123' } }), '/index?foo=123', 'just index');\n                assert.equal(router.generate('index', { queryParams: { foo: '123', bar: '456' } }), '/index?bar=456&foo=123', 'just index');\n                router.getRoute = originalGetHandler;\n            });\n        }\n        (0, _test_helpers.test)('errors in enter/setup hooks fire `error`', function (assert) {\n            assert.expect(4);\n            var count = 0;\n            routes = {\n                index: (0, _test_helpers.createHandler)('index', {\n                    enter: function enter() {\n                        throw 'OMG ENTER';\n                    },\n                    setup: function setup() {\n                        throw 'OMG SETUP';\n                    },\n                    events: {\n                        error: function error(e) {\n                            if (count === 0) {\n                                assert.equal(e, 'OMG ENTER', \"enter's throw value passed to error hook\");\n                            } else if (count === 1) {\n                                assert.equal(e, 'OMG SETUP', \"setup's throw value passed to error hook\");\n                            } else {\n                                assert.ok(false, 'should not happen');\n                            }\n                        }\n                    }\n                })\n            };\n            router.handleURL('/index').then((0, _test_helpers.shouldNotHappen)(assert), function (reason) {\n                assert.equal(reason, 'OMG ENTER', \"enters's error was propagated\");\n                count++;\n                delete routes.index.enter;\n                return router.handleURL('/index');\n            }).then((0, _test_helpers.shouldNotHappen)(assert), function (reason) {\n                assert.equal(reason, 'OMG SETUP', \"setup's error was propagated\");\n                delete routes.index.setup;\n            });\n        });\n        (0, _test_helpers.test)('invalidating parent model with different string/numeric parameters invalidates children', function (assert) {\n            map(assert, function (match) {\n                match('/:p').to('parent', function (match) {\n                    match('/:c').to('child');\n                });\n            });\n            assert.expect(8);\n            var count = 0;\n            routes = {\n                parent: (0, _test_helpers.createHandler)('parent', {\n                    model: function model(params) {\n                        assert.ok(true, 'parent model called');\n                        return { id: params.p };\n                    },\n                    setup: function setup(model) {\n                        if (count === 0) {\n                            assert.deepEqual(model, { id: '1' });\n                        } else {\n                            assert.deepEqual(model, { id: '2' });\n                        }\n                    }\n                }),\n                child: (0, _test_helpers.createHandler)('child', {\n                    model: function model(params) {\n                        assert.ok(true, 'child model called');\n                        return { id: params.c };\n                    },\n                    setup: function setup(model) {\n                        if (count === 0) {\n                            assert.deepEqual(model, { id: '1' });\n                        } else {\n                            assert.deepEqual(model, { id: '1' });\n                        }\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, 'child', '1', '1');\n            count = 1;\n            (0, _test_helpers.transitionTo)(router, 'child', '2', '1');\n        });\n        (0, _test_helpers.test)('intents make use of previous transition state in case not enough contexts are provided to retry a transition', function (assert) {\n            assert.expect(3);\n            map(assert, function (match) {\n                match('/').to('application', function (match) {\n                    match('/users/:user').to('user', function (match) {\n                        match('/index').to('userIndex');\n                        match('/auth').to('auth');\n                    });\n                    match('/login').to('login');\n                });\n            });\n            var hasAuthed = false,\n                savedTransition = void 0,\n                didFinish = false;\n            routes = {\n                auth: (0, _test_helpers.createHandler)('auth', {\n                    beforeModel: function beforeModel(transition) {\n                        if (!hasAuthed) {\n                            savedTransition = transition;\n                            router.transitionTo('login');\n                        }\n                    },\n                    setup: function setup() {\n                        didFinish = true;\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, 'userIndex', { user: 'machty' });\n            // Then attempt to transition into auth; this will redirect.\n            (0, _test_helpers.transitionTo)(router, 'auth');\n            assert.ok(savedTransition, 'transition was saved');\n            hasAuthed = true;\n            savedTransition.retry();\n            (0, _test_helpers.flushBackburner)();\n            assert.ok(didFinish, 'did enter auth route');\n            assert.equal(routes.user.context.user, 'machty', 'User was remembered upon retry');\n        });\n        (0, _test_helpers.test)('A failed transition calls the catch and finally callbacks', function (assert) {\n            assert.expect(2);\n            map(assert, function (match) {\n                match('/').to('application', function (match) {\n                    match('/bad').to('badRoute');\n                });\n            });\n            routes = {\n                badRoute: (0, _test_helpers.createHandler)('badRoute', {\n                    beforeModel: function beforeModel() {\n                        return new _rsvp.Promise(function (_resolve, reject) {\n                            reject('example reason');\n                        });\n                    }\n                })\n            };\n            router.handleURL('/bad').catch(function () {\n                assert.ok(true, 'catch callback was called');\n            }).finally(function () {\n                assert.ok(true, 'finally callback was called');\n            });\n            (0, _test_helpers.flushBackburner)();\n        });\n        (0, _test_helpers.test)('A successful transition calls the finally callback', function (assert) {\n            assert.expect(1);\n            map(assert, function (match) {\n                match('/').to('application', function (match) {\n                    match('/example').to('exampleRoute');\n                });\n            });\n            router.handleURL('/example').finally(function () {\n                assert.ok(true, 'finally callback was called');\n            });\n        });\n        (0, _test_helpers.test)('transition sets isActive by default', function (assert) {\n            assert.expect(2);\n            map(assert, function (match) {\n                match('/').to('application', function (match) {\n                    match('/example').to('exampleRoute');\n                });\n            });\n            var transition = router.handleURL('/example');\n            assert.equal(transition.isActive, true);\n            assert.equal(transition.isAborted, false);\n        });\n        (0, _test_helpers.test)('transition sets isActive to false when aborted', function (assert) {\n            assert.expect(4);\n            map(assert, function (match) {\n                match('/').to('application', function (match) {\n                    match('/example').to('exampleRoute');\n                });\n            });\n            var transition = router.handleURL('/example');\n            assert.equal(transition.isActive, true, 'precond');\n            assert.equal(transition.isAborted, false, 'precond');\n            transition.abort();\n            assert.equal(transition.isActive, false, 'isActive should be false after abort');\n            assert.equal(transition.isAborted, true, 'isAborted is set to true after abort');\n        });\n        if (scenario.async) {\n            (0, _test_helpers.test)('getHandler is invoked synchronously when returning Promises', function (assert) {\n                assert.expect(2);\n                var count = 0;\n                var handlerCount = 2;\n                routes = {\n                    postIndex: (0, _test_helpers.createHandler)('postIndex'),\n                    showAllPosts: (0, _test_helpers.createHandler)('showAllPosts')\n                };\n                router.getRoute = function () {\n                    count++;\n                    return scenario.getRoute.apply(null, arguments).then(function (handler) {\n                        assert.equal(count, handlerCount);\n                        return handler;\n                    });\n                };\n                router.transitionTo('/posts/all');\n            });\n        }\n        (0, _test_helpers.module)('Multiple dynamic segments per route (' + scenario.name + ')');\n        (0, _test_helpers.test)('Multiple string/number params are soaked up', function (assert) {\n            assert.expect(3);\n            map(assert, function (match) {\n                match('/:foo_id/:bar_id').to('bar');\n            });\n            routes = {\n                bar: (0, _test_helpers.createHandler)('bar', {\n                    model: function model() {\n                        return {};\n                    }\n                })\n            };\n            expectedUrl = '/omg/lol';\n            (0, _test_helpers.transitionTo)(router, 'bar', 'omg', 'lol');\n            expectedUrl = '/omg/heehee';\n            (0, _test_helpers.transitionTo)(router, 'bar', 'heehee');\n            expectedUrl = '/lol/no';\n            (0, _test_helpers.transitionTo)(router, 'bar', 'lol', 'no');\n        });\n        (0, _test_helpers.module)('isActive (' + scenario.name + ')', {\n            setup: function setup(assert) {\n                routes = {\n                    parent: (0, _test_helpers.createHandler)('parent', {\n                        serialize: function serialize(obj) {\n                            return {\n                                one: obj.one,\n                                two: obj.two\n                            };\n                        }\n                    }),\n                    child: (0, _test_helpers.createHandler)('child', {\n                        serialize: function serialize(obj) {\n                            return {\n                                three: obj.three,\n                                four: obj.four\n                            };\n                        }\n                    })\n                };\n                // When using an async getHandler serializers need to be loaded separately\n                if (scenario.async) {\n                    serializers = {\n                        parent: function parent(obj) {\n                            return {\n                                one: obj.one,\n                                two: obj.two\n                            };\n                        },\n                        child: function child(obj) {\n                            return {\n                                three: obj.three,\n                                four: obj.four\n                            };\n                        }\n                    };\n                }\n                map(assert, function (match) {\n                    match('/:one/:two').to('parent', function (match) {\n                        match('/:three/:four').to('child');\n                    });\n                });\n                expectedUrl = null;\n                (0, _test_helpers.transitionTo)(router, 'child', 'a', 'b', 'c', 'd');\n            }\n        });\n        (0, _test_helpers.test)('isActive supports multiple soaked up string/number params (via params)', function (assert) {\n            assert.ok(router.isActive('child'), 'child');\n            assert.ok(router.isActive('parent'), 'parent');\n            assert.ok(router.isActive('child', 'd'), 'child d');\n            assert.ok(router.isActive('child', 'c', 'd'), 'child c d');\n            assert.ok(router.isActive('child', 'b', 'c', 'd'), 'child b c d');\n            assert.ok(router.isActive('child', 'a', 'b', 'c', 'd'), 'child a b c d');\n            assert.ok(!router.isActive('child', 'e'), '!child e');\n            assert.ok(!router.isActive('child', 'c', 'e'), '!child c e');\n            assert.ok(!router.isActive('child', 'e', 'd'), '!child e d');\n            assert.ok(!router.isActive('child', 'x', 'x'), '!child x x');\n            assert.ok(!router.isActive('child', 'b', 'c', 'e'), '!child b c e');\n            assert.ok(!router.isActive('child', 'b', 'e', 'd'), 'child b e d');\n            assert.ok(!router.isActive('child', 'e', 'c', 'd'), 'child e c d');\n            assert.ok(!router.isActive('child', 'a', 'b', 'c', 'e'), 'child a b c e');\n            assert.ok(!router.isActive('child', 'a', 'b', 'e', 'd'), 'child a b e d');\n            assert.ok(!router.isActive('child', 'a', 'e', 'c', 'd'), 'child a e c d');\n            assert.ok(!router.isActive('child', 'e', 'b', 'c', 'd'), 'child e b c d');\n            assert.ok(router.isActive('parent', 'b'), 'parent b');\n            assert.ok(router.isActive('parent', 'a', 'b'), 'parent a b');\n            assert.ok(!router.isActive('parent', 'c'), '!parent c');\n            assert.ok(!router.isActive('parent', 'a', 'c'), '!parent a c');\n            assert.ok(!router.isActive('parent', 'c', 'b'), '!parent c b');\n            assert.ok(!router.isActive('parent', 'c', 't'), '!parent c t');\n        });\n        (0, _test_helpers.test)('isActive supports multiple soaked up string/number params (via serialized objects)', function (assert) {\n            assert.ok(router.isActive('child', { three: 'c', four: 'd' }), 'child(3:c, 4:d)');\n            assert.ok(!router.isActive('child', { three: 'e', four: 'd' }), '!child(3:e, 4:d)');\n            assert.ok(!router.isActive('child', { three: 'c', four: 'e' }), '!child(3:c, 4:e)');\n            assert.ok(!router.isActive('child', { three: 'c' }), '!child(3:c)');\n            assert.ok(!router.isActive('child', { four: 'd' }), '!child(4:d)');\n            assert.ok(!router.isActive('child', {}), '!child({})');\n            assert.ok(router.isActive('parent', { one: 'a', two: 'b' }), 'parent(1:a, 2:b)');\n            assert.ok(!router.isActive('parent', { one: 'e', two: 'b' }), '!parent(1:e, 2:b)');\n            assert.ok(!router.isActive('parent', { one: 'a', two: 'e' }), '!parent(1:a, 2:e)');\n            assert.ok(!router.isActive('parent', { one: 'a' }), '!parent(1:a)');\n            assert.ok(!router.isActive('parent', { two: 'b' }), '!parent(2:b)');\n            assert.ok(router.isActive('child', { one: 'a', two: 'b' }, { three: 'c', four: 'd' }), 'child(1:a, 2:b, 3:c, 4:d)');\n            assert.ok(!router.isActive('child', { one: 'e', two: 'b' }, { three: 'c', four: 'd' }), '!child(1:e, 2:b, 3:c, 4:d)');\n            assert.ok(!router.isActive('child', { one: 'a', two: 'b' }, { three: 'c', four: 'e' }), '!child(1:a, 2:b, 3:c, 4:e)');\n        });\n        (0, _test_helpers.test)('isActive supports multiple soaked up string/number params (mixed)', function (assert) {\n            assert.ok(router.isActive('child', 'a', 'b', { three: 'c', four: 'd' }));\n            assert.ok(router.isActive('child', 'b', { three: 'c', four: 'd' }));\n            assert.ok(!router.isActive('child', 'a', { three: 'c', four: 'd' }));\n            assert.ok(router.isActive('child', { one: 'a', two: 'b' }, 'c', 'd'));\n            assert.ok(router.isActive('child', { one: 'a', two: 'b' }, 'd'));\n            assert.ok(!router.isActive('child', { one: 'a', two: 'b' }, 'c'));\n            assert.ok(!router.isActive('child', 'a', 'b', { three: 'e', four: 'd' }));\n            assert.ok(!router.isActive('child', 'b', { three: 'e', four: 'd' }));\n            assert.ok(!router.isActive('child', { one: 'e', two: 'b' }, 'c', 'd'));\n            assert.ok(!router.isActive('child', { one: 'e', two: 'b' }, 'd'));\n        });\n        (0, _test_helpers.module)('Preservation of params between redirects (' + scenario.name + ')', {\n            setup: function setup(assert) {\n                expectedUrl = null;\n                map(assert, function (match) {\n                    match('/').to('index');\n                    match('/:foo_id').to('foo', function (match) {\n                        match('/').to('fooIndex');\n                        match('/:bar_id').to('bar', function (match) {\n                            match('/').to('barIndex');\n                        });\n                    });\n                });\n                routes = {\n                    foo: (0, _test_helpers.createHandler)('foo', {\n                        modelCount: undefined,\n                        model: function model(params) {\n                            this.modelCount = this.modelCount ? this.modelCount + 1 : 1;\n                            return { id: params.foo_id };\n                        },\n                        afterModel: function afterModel() {\n                            router.transitionTo('barIndex', '789');\n                        }\n                    }),\n                    bar: (0, _test_helpers.createHandler)('bar', {\n                        model: function model(params) {\n                            this.modelCount = this.modelCount ? this.modelCount + 1 : 1;\n                            return { id: params.bar_id };\n                        }\n                    })\n                };\n            }\n        });\n        (0, _test_helpers.test)(\"Starting on '/' root index\", function (assert) {\n            (0, _test_helpers.transitionTo)(router, '/');\n            // Should call model for foo and bar\n            expectedUrl = '/123/789';\n            (0, _test_helpers.transitionTo)(router, 'barIndex', '123', '456');\n            assert.equal(routes.foo.modelCount, 2, 'redirect in foo#afterModel should run foo#model twice (since validation failed)');\n            assert.deepEqual(routes.foo.context, { id: '123' });\n            assert.deepEqual(routes.bar.context, { id: '789' }, 'bar should have redirected to bar 789');\n            // Try setting foo's context to 200; this should redirect\n            // bar to '789' but preserve the new foo 200.\n            expectedUrl = '/200/789';\n            (0, _test_helpers.transitionTo)(router, 'fooIndex', '200');\n            assert.equal(routes.foo.modelCount, 4, 'redirect in foo#afterModel should re-run foo#model');\n            assert.deepEqual(routes.foo.context, { id: '200' });\n            assert.deepEqual(routes.bar.context, { id: '789' }, 'bar should have redirected to bar 789');\n        });\n        (0, _test_helpers.test)(\"Starting on '/' root index, using redirect\", function (assert) {\n            routes.foo.redirect = routes.foo.afterModel;\n            delete routes.foo.afterModel;\n            (0, _test_helpers.transitionTo)(router, '/');\n            // Should call model for foo and bar\n            expectedUrl = '/123/789';\n            (0, _test_helpers.transitionTo)(router, 'barIndex', '123', '456');\n            assert.equal(routes.foo.modelCount, 1, 'redirect in foo#redirect should NOT run foo#model (since validation succeeded)');\n            assert.deepEqual(routes.foo.context, { id: '123' });\n            assert.deepEqual(routes.bar.context, { id: '789' }, 'bar should have redirected to bar 789');\n            // Try setting foo's context to 200; this should redirect\n            // bar to '789' but preserve the new foo 200.\n            expectedUrl = '/200/789';\n            (0, _test_helpers.transitionTo)(router, 'fooIndex', '200');\n            assert.equal(routes.foo.modelCount, 2, 'redirect in foo#redirect should NOT foo#model');\n            assert.deepEqual(routes.foo.context, { id: '200' });\n            assert.deepEqual(routes.bar.context, { id: '789' }, 'bar should have redirected to bar 789');\n        });\n        (0, _test_helpers.test)('Starting on non root index', function (assert) {\n            (0, _test_helpers.transitionTo)(router, '/123/456');\n            assert.deepEqual(routes.foo.context, { id: '123' });\n            assert.deepEqual(routes.bar.context, { id: '789' }, 'bar should have redirected to bar 789');\n            // Try setting foo's context to 200; this should redirect\n            // bar to '789' but preserve the new foo 200.\n            expectedUrl = '/200/789';\n            (0, _test_helpers.transitionTo)(router, 'fooIndex', '200');\n            assert.deepEqual(routes.foo.context, { id: '200' });\n            assert.deepEqual(routes.bar.context, { id: '789' }, 'bar should have redirected to bar 789');\n        });\n        /* TODO revisit\n        test(\"A failed handler's setup shouldn't prevent future transitions\", function(assert) {\n        assert.expect(2);\n           enableErrorHandlingDeferredActionQueue();\n           map(assert, function(match) {\n          match(\"/parent\").to('parent', function(match) {\n            match(\"/articles\").to('articles');\n            match(\"/login\").to('login');\n          });\n        });\n           let error = new Error(\"blorg\");\n           handlers = {\n          articles: {\n            setup: function() {\n              assert.ok(true, \"articles setup was entered\");\n              throw error;\n            },\n            events: {\n              error: function() {\n                assert.ok(true, \"error handled in articles\");\n                router.transitionTo('login');\n              }\n            }\n          },\n             login: {\n            setup: function() {\n              start();\n            }\n          }\n        };\n           router.handleURL('/parent/articles');\n        flush(error);\n        });\n        */\n        (0, _test_helpers.test)(\"beforeModel shouldn't be refired with incorrect params during redirect\", function (assert) {\n            // Source: https://github.com/emberjs/ember.js/issues/3407\n            assert.expect(3);\n            map(assert, function (match) {\n                match('/').to('index');\n                match('/people/:id').to('people', function (match) {\n                    match('/').to('peopleIndex');\n                    match('/home').to('peopleHome');\n                });\n            });\n            var peopleModels = [null, {}, {}];\n            var peopleBeforeModelCalled = false;\n            routes = {\n                people: (0, _test_helpers.createHandler)('people', {\n                    beforeModel: function beforeModel() {\n                        assert.ok(!peopleBeforeModelCalled, 'people#beforeModel should only be called once');\n                        peopleBeforeModelCalled = true;\n                    },\n                    model: function model(params) {\n                        assert.ok(params.id, 'people#model called');\n                        return peopleModels[params.id];\n                    }\n                }),\n                peopleIndex: (0, _test_helpers.createHandler)('peopleIndex', {\n                    afterModel: function afterModel() {\n                        router.transitionTo('peopleHome');\n                    }\n                }),\n                peopleHome: (0, _test_helpers.createHandler)('peopleHome', {\n                    setup: function setup() {\n                        assert.ok(true, 'I was entered');\n                    }\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, '/');\n            (0, _test_helpers.transitionTo)(router, 'peopleIndex', '1');\n        });\n        (0, _test_helpers.module)('URL-less routes (' + scenario.name + ')', {\n            setup: function setup(assert) {\n                routes = {};\n                expectedUrl = null;\n                map(assert, function (match) {\n                    match('/index').to('index');\n                    match('/admin').to('admin', function (match) {\n                        match('/posts').to('adminPosts');\n                        match('/articles').to('adminArticles');\n                    });\n                });\n            }\n        });\n        (0, _test_helpers.test)(\"Transitioning into a route marked as inaccessibleByURL doesn't update the URL\", function (assert) {\n            assert.expect(1);\n            routes = {\n                adminPosts: (0, _test_helpers.createHandler)('adminPosts', {\n                    inaccessibleByURL: true\n                })\n            };\n            router.handleURL('/index').then(function () {\n                url = '/index';\n                return router.transitionTo('adminPosts');\n            }).then(function () {\n                assert.equal(url, '/index');\n            });\n        });\n        (0, _test_helpers.test)(\"Transitioning into a route with a parent route marked as inaccessibleByURL doesn't update the URL\", function (assert) {\n            assert.expect(2);\n            routes = {\n                admin: (0, _test_helpers.createHandler)('admin', {\n                    inaccessibleByURL: true\n                })\n            };\n            (0, _test_helpers.transitionTo)(router, '/index');\n            url = '/index';\n            (0, _test_helpers.transitionTo)(router, 'adminPosts');\n            assert.equal(url, '/index');\n            (0, _test_helpers.transitionTo)(router, 'adminArticles');\n            assert.equal(url, '/index');\n        });\n        (0, _test_helpers.test)('Handling a URL on a route marked as inaccessible behaves like a failed url match', function (assert) {\n            assert.expect(1);\n            routes = {\n                admin: (0, _test_helpers.createHandler)('admin', {\n                    inaccessibleByURL: true\n                })\n            };\n            router.handleURL('/index').then(function () {\n                return router.handleURL('/admin/posts');\n            }).then((0, _test_helpers.shouldNotHappen)(assert), function (e) {\n                assert.equal(e.name, 'UnrecognizedURLError', 'error.name is UnrecognizedURLError');\n            });\n        });\n        (0, _test_helpers.module)('Intermediate transitions (' + scenario.name + ')', {\n            setup: function setup(assert) {\n                routes = {};\n                expectedUrl = null;\n                map(assert, function (match) {\n                    match('/').to('application', function (match) {\n                        //match(\"/\").to(\"index\");\n                        match('/foo').to('foo');\n                        match('/loading').to('loading');\n                    });\n                });\n            }\n        });\n        (0, _test_helpers.test)('intermediateTransitionTo() has the correct RouteInfo objects', function (assert) {\n            assert.expect(5);\n            routes = {\n                application: (0, _test_helpers.createHandler)('application'),\n                foo: (0, _test_helpers.createHandler)('foo', {\n                    model: function model() {\n                        router.intermediateTransitionTo('loading');\n                        return new _rsvp.Promise(function (resolve) {\n                            resolve();\n                        });\n                    }\n                }),\n                loading: (0, _test_helpers.createHandler)('loading')\n            };\n            var enteredCount = 0;\n            router.routeWillChange = function (transition) {\n                if (enteredCount === 0) {\n                    assert.equal(transition.to.name, 'foo', 'going to');\n                    enteredCount++;\n                } else if (enteredCount === 1) {\n                    assert.equal(transition.to.name, 'loading', 'entering');\n                    enteredCount++;\n                } else {\n                    assert.equal(transition.to.name, 'foo', 'back to');\n                    enteredCount++;\n                }\n                assert.equal(transition.from, null);\n            };\n            router.routeDidChange = function (transition) {\n                if (enteredCount === 1) {\n                    assert.equal(transition.to.name, 'loading');\n                } else {\n                    assert.equal(transition.to.name, 'foo', 'landed at');\n                }\n            };\n            (0, _test_helpers.transitionTo)(router, '/foo');\n        });\n        (0, _test_helpers.test)(\"intermediateTransitionTo() forces an immediate intermediate transition that doesn't cancel currently active async transitions\", function (assert) {\n            assert.expect(11);\n            var counter = 1,\n                willResolves = void 0,\n                appModel = {},\n                fooModel = {};\n            function counterAt(expectedValue, description) {\n                assert.equal(counter, expectedValue, 'Step ' + expectedValue + ': ' + description);\n                counter++;\n            }\n            routes = {\n                application: (0, _test_helpers.createHandler)('application', {\n                    model: function model() {\n                        return appModel;\n                    },\n                    setup: function setup(obj) {\n                        counterAt(1, 'application#setup');\n                        assert.equal(obj, appModel, 'application#setup is passed the return value from model');\n                    },\n                    events: {\n                        willResolveModel: function willResolveModel(_transition, handler) {\n                            assert.equal(willResolves.shift(), handler, 'willResolveModel event fired and passed expanded handler');\n                        }\n                    }\n                }),\n                foo: (0, _test_helpers.createHandler)('foo', {\n                    model: function model() {\n                        router.intermediateTransitionTo('loading');\n                        counterAt(3, 'intermediate transition finished within foo#model');\n                        return new _rsvp.Promise(function (resolve) {\n                            counterAt(4, \"foo's model promise resolves\");\n                            resolve(fooModel);\n                        });\n                    },\n                    setup: function setup(obj) {\n                        counterAt(6, 'foo#setup');\n                        assert.equal(obj, fooModel, 'foo#setup is passed the resolve model promise');\n                    }\n                }),\n                loading: (0, _test_helpers.createHandler)('loading', {\n                    model: function model() {\n                        assert.ok(false, \"intermediate transitions don't call model hooks\");\n                    },\n                    setup: function setup() {\n                        counterAt(2, 'loading#setup');\n                    },\n                    exit: function exit() {\n                        counterAt(5, 'loading state exited');\n                    }\n                })\n            };\n            willResolves = [routes.application, routes.foo];\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            counterAt(7, 'original transition promise resolves');\n        });\n        (0, _test_helpers.test)('Calling transitionTo during initial transition in validation hook should use replaceURL', function (assert) {\n            assert.expect(4);\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                assert.ok(false, 'The url was not correctly replaced on initial transition');\n            };\n            router.replaceURL = function (replaceURL) {\n                url = replaceURL;\n                assert.ok(true, 'The url was replaced correctly on initial transition');\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                    router.transitionTo('/bar');\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                }\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            assert.equal(url, '/bar');\n            assert.equal(fooModelCount, 1);\n            assert.equal(barModelCount, 1);\n        });\n        (0, _test_helpers.test)('Calling transitionTo during initial transition in validation hook with multiple redirects should use replaceURL', function (assert) {\n            assert.expect(5);\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n                match('/baz').to('baz');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0,\n                bazModelCount = 0;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                assert.ok(false, 'The url was not correctly replaced on initial transition');\n            };\n            router.replaceURL = function (replaceURL) {\n                url = replaceURL;\n                assert.ok(true, 'The url was replaced correctly on initial transition');\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                    router.transitionTo('/bar');\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                    router.transitionTo('/baz');\n                }\n            });\n            var bazHandler = (0, _test_helpers.createHandler)('baz', {\n                model: function model() {\n                    bazModelCount++;\n                }\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler,\n                baz: bazHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            assert.equal(url, '/baz');\n            assert.equal(fooModelCount, 1);\n            assert.equal(barModelCount, 1);\n            assert.equal(bazModelCount, 1);\n        });\n        (0, _test_helpers.test)('Calling transitionTo after initial transition in validation hook should use updateUrl', function (assert) {\n            assert.expect(8);\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                assert.ok(true, 'updateURL should be used');\n            };\n            router.replaceURL = function (replaceURL) {\n                url = replaceURL;\n                assert.ok(false, 'replaceURL should not be used');\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                    router.transitionTo('/bar');\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                }\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/bar');\n            assert.equal(url, '/bar');\n            assert.equal(barModelCount, 1, 'Bar model should be called once');\n            assert.equal(fooModelCount, 0, 'Foo model should not be called');\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            assert.equal(url, '/bar');\n            assert.equal(barModelCount, 2, 'Bar model should be called twice');\n            assert.equal(fooModelCount, 1, 'Foo model should be called once');\n        });\n        (0, _test_helpers.test)('Calling transitionTo after initial transition in validation hook with multiple redirects should use updateUrl', function (assert) {\n            assert.expect(10);\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n                match('/baz').to('baz');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0,\n                bazModelCount = 0;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                assert.ok(true, 'updateURL should be used');\n            };\n            router.replaceURL = function (replaceURL) {\n                url = replaceURL;\n                assert.ok(false, 'replaceURL should not be used');\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                    router.transitionTo('/bar');\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                    router.transitionTo('/baz');\n                }\n            });\n            var bazHandler = (0, _test_helpers.createHandler)('baz', {\n                model: function model() {\n                    bazModelCount++;\n                }\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler,\n                baz: bazHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/baz');\n            assert.equal(url, '/baz');\n            assert.equal(bazModelCount, 1, 'Baz model should be called once');\n            assert.equal(fooModelCount, 0, 'Foo model should not be called');\n            assert.equal(barModelCount, 0, 'Bar model should not be called');\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            assert.equal(url, '/baz');\n            assert.equal(bazModelCount, 2, 'Baz model should be called twice');\n            assert.equal(fooModelCount, 1, 'Foo model should be called once');\n            assert.equal(barModelCount, 1, 'Bar model should be called once');\n        });\n        (0, _test_helpers.test)('Calling replaceWith during initial transition in validation hook should use replaceURL', function (assert) {\n            assert.expect(4);\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                assert.ok(false, 'The url was not correctly replaced on initial transition');\n            };\n            router.replaceURL = function (replaceURL) {\n                url = replaceURL;\n                assert.ok(true, 'The url was replaced correctly on initial transition');\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                    router.replaceWith('/bar');\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                }\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            assert.equal(url, '/bar');\n            assert.equal(fooModelCount, 1);\n            assert.equal(barModelCount, 1);\n        });\n        (0, _test_helpers.test)('Calling replaceWith during initial transition in validation hook with multiple redirects should use replaceURL', function (assert) {\n            assert.expect(5);\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n                match('/baz').to('baz');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0,\n                bazModelCount = 0;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                assert.ok(false, 'The url was not correctly replaced on initial transition');\n            };\n            router.replaceURL = function (replaceURL) {\n                url = replaceURL;\n                assert.ok(true, 'The url was replaced correctly on initial transition');\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                    router.replaceWith('/bar');\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                    router.replaceWith('/baz');\n                }\n            });\n            var bazHandler = (0, _test_helpers.createHandler)('baz', {\n                model: function model() {\n                    bazModelCount++;\n                }\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler,\n                baz: bazHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            assert.equal(url, '/baz');\n            assert.equal(fooModelCount, 1, 'should call foo model once');\n            assert.equal(barModelCount, 1, 'should call bar model once');\n            assert.equal(bazModelCount, 1, 'should call baz model once');\n        });\n        (0, _test_helpers.test)('Calling replaceWith after initial transition in validation hook should use updateUrl', function (assert) {\n            assert.expect(8);\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                assert.ok(true, 'updateURL should be used');\n            };\n            router.replaceURL = function (replaceURL) {\n                url = replaceURL;\n                assert.ok(false, 'replaceURL should not be used');\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                    router.replaceWith('/bar');\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                }\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/bar');\n            assert.equal(url, '/bar');\n            assert.equal(barModelCount, 1, 'Bar model should be called once');\n            assert.equal(fooModelCount, 0, 'Foo model should not be called');\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            assert.equal(url, '/bar');\n            assert.equal(barModelCount, 2, 'Bar model should be called twice');\n            assert.equal(fooModelCount, 1, 'Foo model should be called once');\n        });\n        (0, _test_helpers.test)('Calling replaceWith after initial transition in validation hook with multiple redirects should use updateUrl', function (assert) {\n            assert.expect(10);\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n                match('/baz').to('baz');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0,\n                bazModelCount = 0;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                assert.ok(true, 'updateURL should be used');\n            };\n            router.replaceURL = function (replaceURL) {\n                url = replaceURL;\n                assert.ok(false, 'replaceURL should not be used');\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                    router.replaceWith('/bar');\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                    router.replaceWith('/baz');\n                }\n            });\n            var bazHandler = (0, _test_helpers.createHandler)('baz', {\n                model: function model() {\n                    bazModelCount++;\n                }\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler,\n                baz: bazHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/baz');\n            assert.equal(url, '/baz');\n            assert.equal(bazModelCount, 1, 'Bar model should be called once');\n            assert.equal(fooModelCount, 0, 'Foo model should not be called');\n            assert.equal(barModelCount, 0, 'Baz model should not be called');\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            assert.equal(url, '/baz');\n            assert.equal(bazModelCount, 2, 'Baz model should be called twice');\n            assert.equal(fooModelCount, 1, 'Foo model should be called once');\n            assert.equal(barModelCount, 1, 'Bar model should be called once');\n        });\n        (0, _test_helpers.test)('Calling replaceWith after initial replace in validation hook with multiple redirects should use replaceUrl', function (assert) {\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n                match('/baz').to('baz');\n                match('/qux').to('qux');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0,\n                bazModelCount = 0,\n                history = [];\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                history.push(url);\n            };\n            router.replaceURL = function (replaceURL) {\n                url = replaceURL;\n                if (history.length === 0) {\n                    assert.ok(false, 'should not replace on initial');\n                }\n                history[history.length - 1] = url;\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                    router.replaceWith('/bar');\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                    router.replaceWith('/baz');\n                }\n            });\n            var bazHandler = (0, _test_helpers.createHandler)('baz', {\n                model: function model() {\n                    bazModelCount++;\n                }\n            });\n            var quxHandler = (0, _test_helpers.createHandler)('qux', {\n                model: function model() {}\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler,\n                baz: bazHandler,\n                qux: quxHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/qux');\n            assert.equal(history.length, 1, 'only one history item');\n            assert.equal(history[0], '/qux', 'history item is /qux');\n            (0, _test_helpers.replaceWith)(router, '/foo');\n            assert.equal(history.length, 1, 'still only one history item, replaced the previous');\n            assert.equal(history[0], '/baz', 'history item is /foo');\n            assert.equal(fooModelCount, 1, 'Foo model should be called once');\n            assert.equal(barModelCount, 1, 'Bar model should be called once');\n            assert.equal(bazModelCount, 1, 'Baz model should be called once');\n        });\n        (0, _test_helpers.test)('Mixing multiple types of redirect during initial transition should work', function (assert) {\n            assert.expect(10);\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n                match('/baz').to('baz');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0,\n                bazModelCount = 0;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                assert.ok(true, 'updateURL should be used');\n            };\n            router.replaceURL = function (replaceURL) {\n                url = replaceURL;\n                assert.ok(false, 'replaceURL should not be used');\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                    router.replaceWith('/bar');\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                    router.transitionTo('/baz');\n                }\n            });\n            var bazHandler = (0, _test_helpers.createHandler)('baz', {\n                model: function model() {\n                    bazModelCount++;\n                }\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler,\n                baz: bazHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/baz');\n            assert.equal(url, '/baz');\n            assert.equal(bazModelCount, 1, 'Bar model should be called once');\n            assert.equal(fooModelCount, 0, 'Foo model should not be called');\n            assert.equal(barModelCount, 0, 'Baz model should not be called');\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            assert.equal(url, '/baz');\n            assert.equal(bazModelCount, 2, 'Baz model should be called twice');\n            assert.equal(fooModelCount, 1, 'Foo model should be called once');\n            assert.equal(barModelCount, 1, 'Bar model should be called once');\n        });\n        (0, _test_helpers.test)('Mixing multiple types of redirects after initial transition should work', function (assert) {\n            assert.expect(12);\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n                match('/baz').to('baz');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0,\n                bazModelCount = 0,\n                updateUrlCount = 0,\n                replaceUrlCount = 0;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                updateUrlCount++;\n            };\n            router.replaceURL = function (replaceURL) {\n                url = replaceURL;\n                replaceUrlCount++;\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                    router.replaceWith('/bar');\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                    router.transitionTo('/baz');\n                }\n            });\n            var bazHandler = (0, _test_helpers.createHandler)('baz', {\n                model: function model() {\n                    bazModelCount++;\n                }\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler,\n                baz: bazHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/baz');\n            // actually replaceURL probably makes more sense here, but it's an initial\n            // transition to a route that the page loaded on, so it's a no-op and doesn't\n            // cause a problem\n            assert.equal(replaceUrlCount, 0, 'replaceURL should not be used');\n            assert.equal(updateUrlCount, 1, 'updateURL should be used for initial transition');\n            assert.equal(url, '/baz');\n            assert.equal(bazModelCount, 1, 'Baz model should be called once');\n            assert.equal(fooModelCount, 0, 'Foo model should not be called');\n            assert.equal(barModelCount, 0, 'Bar model should not be called');\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            assert.equal(replaceUrlCount, 0, 'replaceURL should not be used');\n            assert.equal(updateUrlCount, 2, 'updateURL should be used for subsequent transition');\n            assert.equal(url, '/baz');\n            assert.equal(bazModelCount, 2, 'Baz model should be called twice');\n            assert.equal(fooModelCount, 1, 'Foo model should be called once');\n            assert.equal(barModelCount, 1, 'Bar model should be called once');\n        });\n        (0, _test_helpers.test)('Calling replaceWith after initial transition outside validation hook should use replaceURL', function (assert) {\n            assert.expect(7);\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                assert.equal(updateUrl, '/foo', 'incorrect url for updateURL');\n            };\n            router.replaceURL = function (replaceUrl) {\n                url = replaceUrl;\n                assert.equal(replaceUrl, '/bar', 'incorrect url for replaceURL');\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                }\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            assert.equal(url, '/foo', 'failed initial transition');\n            assert.equal(fooModelCount, 1, 'Foo model should be called once');\n            assert.equal(barModelCount, 0, 'Bar model should not be called');\n            router.replaceWith('/bar');\n            (0, _test_helpers.flushBackburner)();\n            assert.equal(fooModelCount, 1, 'Foo model should be called once');\n            assert.equal(barModelCount, 1, 'Bar model should be called once');\n        });\n        (0, _test_helpers.test)('Calling transitionTo after initial transition outside validation hook should use updateUrl', function (assert) {\n            assert.expect(7);\n            map(assert, function (match) {\n                match('/foo').to('foo');\n                match('/bar').to('bar');\n            });\n            var fooModelCount = 0,\n                barModelCount = 0;\n            router.updateURL = function (updateUrl) {\n                url = updateUrl;\n                assert.ok(true, 'updateURL is used');\n            };\n            router.replaceURL = function (replaceURL) {\n                url = replaceURL;\n                assert.ok(false, 'replaceURL should not be used');\n            };\n            var fooHandler = (0, _test_helpers.createHandler)('foo', {\n                model: function model() {\n                    fooModelCount++;\n                }\n            });\n            var barHandler = (0, _test_helpers.createHandler)('bar', {\n                model: function model() {\n                    barModelCount++;\n                }\n            });\n            routes = {\n                foo: fooHandler,\n                bar: barHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/foo');\n            assert.equal(url, '/foo', 'failed initial transition');\n            assert.equal(fooModelCount, 1, 'Foo model should be called once');\n            assert.equal(barModelCount, 0, 'Bar model should not be called');\n            (0, _test_helpers.transitionTo)(router, '/bar');\n            assert.equal(fooModelCount, 1, 'Foo model should be called once');\n            assert.equal(barModelCount, 1, 'Bar model should be called once');\n        });\n        (0, _test_helpers.test)('transitioning to the same route with different context should not reenter the route', function (assert) {\n            map(assert, function (match) {\n                match('/project/:project_id').to('project');\n            });\n            var projectEnterCount = 0;\n            var projectSetupCount = 0;\n            var projectHandler = (0, _test_helpers.createHandler)('project', {\n                model: function model(params) {\n                    delete params.queryParams;\n                    return params;\n                },\n                enter: function enter() {\n                    projectEnterCount++;\n                },\n                setup: function setup() {\n                    projectSetupCount++;\n                }\n            });\n            routes = {\n                project: projectHandler\n            };\n            (0, _test_helpers.transitionTo)(router, '/project/1');\n            assert.equal(projectEnterCount, 1, 'project handler should have been entered once');\n            assert.equal(projectSetupCount, 1, 'project handler should have been setup once');\n            (0, _test_helpers.transitionTo)(router, '/project/2');\n            assert.equal(projectEnterCount, 1, 'project handler should still have been entered only once');\n            assert.equal(projectSetupCount, 2, 'project handler should have been setup twice');\n        });\n        (0, _test_helpers.test)('synchronous transition errors can be detected synchronously', function (assert) {\n            map(assert, function (match) {\n                match('/').to('root');\n            });\n            router.getRoute = function () {\n                throw new Error('boom!');\n            };\n            assert.equal((0, _test_helpers.transitionTo)(router, '/').error.message, 'boom!');\n        });\n    });\n    //# sourceMappingURL=router_test.js.map\n});","define('tests/test_helpers', ['exports', 'backburner', 'router', 'router/route-info', 'router/transition', 'router/transition-aborted-error', 'rsvp'], function (exports, _backburner, _router, _routeInfo, _transition2, _transitionAbortedError, _rsvp) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.TestRouter = exports.assertAbort = exports.stubbedHandlerInfoFactory = exports.shouldNotHappen = exports.replaceWith = exports.transitionToWithAbort = exports.transitionTo = exports.handleURL = exports.flushBackburner = exports.test = exports.module = undefined;\n    exports.isExiting = isExiting;\n    exports.createHandler = createHandler;\n    exports.createHandlerInfo = createHandlerInfo;\n    exports.trigger = trigger;\n\n    var _backburner2 = _interopRequireDefault(_backburner);\n\n    var _router2 = _interopRequireDefault(_router);\n\n    var _routeInfo2 = _interopRequireDefault(_routeInfo);\n\n    var _transitionAbortedError2 = _interopRequireDefault(_transitionAbortedError);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    function _possibleConstructorReturn(self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    QUnit.config.testTimeout = 1000;\n    var bb = new _backburner2.default(['promises']);\n    function customAsync(callback, promise) {\n        bb.defer('promises', promise, callback, promise);\n    }\n    function flushBackburner() {\n        bb.end();\n        bb.begin();\n    }\n    var test = QUnit.test;\n    function _module(name, options) {\n        options = options || {};\n        QUnit.module(name, {\n            beforeEach: function beforeEach() {\n                (0, _rsvp.configure)('async', customAsync);\n                bb.begin();\n                if (options.setup) {\n                    options.setup.apply(this, arguments);\n                }\n            },\n            afterEach: function afterEach() {\n                bb.end();\n                if (options.teardown) {\n                    options.teardown.apply(this, arguments);\n                }\n            }\n        });\n    }\n    function assertAbort(assert) {\n        return function _assertAbort(e) {\n            assert.ok(e instanceof _transitionAbortedError2.default, 'transition was redirected/aborted');\n        };\n    }\n    // Helper method that performs a transition and flushes\n    // the backburner queue. Helpful for when you want to write\n    // tests that avoid .then callbacks.\n    function transitionTo(router, path) {\n        for (var _len = arguments.length, context = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n            context[_key - 2] = arguments[_key];\n        }\n\n        var result = router.transitionTo.apply(router, [path].concat(context));\n        flushBackburner();\n        return result;\n    }\n    function transitionToWithAbort(assert, router, path) {\n        var args = [path];\n        router.transitionTo.apply(router, args).then(shouldNotHappen, assertAbort(assert));\n        flushBackburner();\n    }\n    function replaceWith(router, path) {\n        var result = router.transitionTo.apply(router, [path]).method('replace');\n        flushBackburner();\n        return result;\n    }\n    function handleURL(router, url) {\n        var result = router.handleURL.apply(router, [url]);\n        flushBackburner();\n        return result;\n    }\n    function shouldNotHappen(assert, _message) {\n        var message = _message || 'this .then handler should not be called';\n        return function _shouldNotHappen(error) {\n            console.error(error.stack); // eslint-disable-line\n            assert.ok(false, message);\n            return error;\n        };\n    }\n    function isExiting(route, routeInfos) {\n        for (var i = 0, len = routeInfos.length; i < len; ++i) {\n            var routeInfo = routeInfos[i];\n            if (routeInfo.name === route || routeInfo.route === route) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function stubbedHandlerInfoFactory(name, props) {\n        var obj = Object.create(props);\n        obj._handlerInfoType = name;\n        return obj;\n    }\n    _module('backburner sanity test');\n    test('backburnerized testing works as expected', function (assert) {\n        assert.expect(1);\n        (0, _rsvp.resolve)('hello').then(function (word) {\n            assert.equal(word, 'hello', 'backburner flush in teardown resolved this promise');\n        });\n    });\n    exports.module = _module;\n    exports.test = test;\n    exports.flushBackburner = flushBackburner;\n    exports.handleURL = handleURL;\n    exports.transitionTo = transitionTo;\n    exports.transitionToWithAbort = transitionToWithAbort;\n    exports.replaceWith = replaceWith;\n    exports.shouldNotHappen = shouldNotHappen;\n    exports.stubbedHandlerInfoFactory = stubbedHandlerInfoFactory;\n    exports.assertAbort = assertAbort;\n    function createHandler(name, options) {\n        return Object.assign({ name: name, routeName: name, context: undefined, names: [], handler: name, _internalName: name }, options);\n    }\n\n    var TestRouter = exports.TestRouter = function (_Router) {\n        _inherits(TestRouter, _Router);\n\n        function TestRouter() {\n            _classCallCheck(this, TestRouter);\n\n            return _possibleConstructorReturn(this, (TestRouter.__proto__ || Object.getPrototypeOf(TestRouter)).apply(this, arguments));\n        }\n\n        _createClass(TestRouter, [{\n            key: 'didTransition',\n            value: function didTransition() {}\n        }, {\n            key: 'willTransition',\n            value: function willTransition() {}\n        }, {\n            key: 'updateURL',\n            value: function updateURL(_url) {}\n        }, {\n            key: 'replaceURL',\n            value: function replaceURL(_url) {}\n        }, {\n            key: 'triggerEvent',\n            value: function triggerEvent(_handlerInfos, _ignoreFailure, _name, _args) {}\n        }, {\n            key: 'routeDidChange',\n            value: function routeDidChange() {}\n        }, {\n            key: 'routeWillChange',\n            value: function routeWillChange() {}\n        }, {\n            key: 'transitionDidError',\n            value: function transitionDidError(error, transition) {\n                if (error.wasAborted || transition.isAborted) {\n                    return (0, _transition2.logAbort)(transition);\n                } else {\n                    transition.trigger(false, 'error', error.error, this, error.route);\n                    transition.abort();\n                    return error.error;\n                }\n            }\n        }, {\n            key: 'getRoute',\n            value: function getRoute(_name) {\n                return {};\n            }\n        }, {\n            key: 'getSerializer',\n            value: function getSerializer(_name) {\n                return function () {};\n            }\n        }]);\n\n        return TestRouter;\n    }(_router2.default);\n\n    function createHandlerInfo(name) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        var Stub = function (_RouteInfo) {\n            _inherits(Stub, _RouteInfo);\n\n            function Stub(name, router, handler) {\n                _classCallCheck(this, Stub);\n\n                return _possibleConstructorReturn(this, (Stub.__proto__ || Object.getPrototypeOf(Stub)).call(this, router, name, [], handler));\n            }\n\n            _createClass(Stub, [{\n                key: 'getModel',\n                value: function getModel(_transition) {\n                    return {};\n                }\n            }, {\n                key: 'getUnresolved',\n                value: function getUnresolved() {\n                    return new _routeInfo.UnresolvedRouteInfoByParam(this.router, 'empty', [], {});\n                }\n            }]);\n\n            return Stub;\n        }(_routeInfo2.default);\n\n        var handler = options.handler || createHandler('foo');\n        delete options.handler;\n        Object.assign(Stub.prototype, options);\n        var stub = new Stub(name, new TestRouter(), handler);\n        return stub;\n    }\n    function trigger(handlerInfos, ignoreFailure, name) {\n        for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n            args[_key2 - 3] = arguments[_key2];\n        }\n\n        if (!handlerInfos) {\n            if (ignoreFailure) {\n                return;\n            }\n            throw new Error(\"Could not trigger event '\" + name + \"'. There are no active handlers\");\n        }\n        var eventWasHandled = false;\n        for (var i = handlerInfos.length - 1; i >= 0; i--) {\n            var currentHandlerInfo = handlerInfos[i],\n                currentHandler = currentHandlerInfo.route;\n            // If there is no handler, it means the handler hasn't resolved yet which\n            // means that we should trigger the event later when the handler is available\n            if (!currentHandler) {\n                currentHandlerInfo.routePromise.then(function (resolvedHandler) {\n                    resolvedHandler.events[name].apply(resolvedHandler, args);\n                });\n                continue;\n            }\n            if (currentHandler.events && currentHandler.events[name]) {\n                if (currentHandler.events[name].apply(currentHandler, args) === true) {\n                    eventWasHandled = true;\n                } else {\n                    return;\n                }\n            }\n        }\n        // In the case that we got an UnrecognizedURLError as an event with no handler,\n        // let it bubble up\n        if (name === 'error' && args[0].name === 'UnrecognizedURLError') {\n            throw args[0];\n        } else if (!eventWasHandled && !ignoreFailure) {\n            throw new Error(\"Nothing handled the event '\" + name + \"'.\");\n        }\n    }\n    //# sourceMappingURL=test_helpers.js.map\n});","define('tests/transition-aborted-error_test', ['router/transition-aborted-error', 'tests/test_helpers'], function (_transitionAbortedError, _test_helpers) {\n    'use strict';\n\n    var _transitionAbortedError2 = _interopRequireDefault(_transitionAbortedError);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    (0, _test_helpers.module)('transition-aborted-error');\n    (0, _test_helpers.test)('correct inheritance and name', function (assert) {\n        var error = void 0;\n        try {\n            throw new _transitionAbortedError2.default('Message');\n        } catch (e) {\n            error = e;\n        }\n        // it would be more correct with TransitionAbortedError, but other libraries may rely on this name\n        assert.equal(error.name, 'TransitionAborted', \"TransitionAbortedError has the name 'TransitionAborted'\");\n        assert.ok(error instanceof _transitionAbortedError2.default);\n        assert.ok(error instanceof Error);\n    });\n    //# sourceMappingURL=transition-aborted-error_test.js.map\n});","define('tests/transition_intent_test', ['router/transition-intent/named-transition-intent', 'router/transition-intent/url-transition-intent', 'router/transition-state', 'tests/test_helpers', 'router/route-info', 'rsvp'], function (_namedTransitionIntent, _urlTransitionIntent, _transitionState, _test_helpers, _routeInfo, _rsvp) {\n    'use strict';\n\n    var _namedTransitionIntent2 = _interopRequireDefault(_namedTransitionIntent);\n\n    var _urlTransitionIntent2 = _interopRequireDefault(_urlTransitionIntent);\n\n    var _transitionState2 = _interopRequireDefault(_transitionState);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    function _possibleConstructorReturn(self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    var handlers = void 0,\n        recognizer = void 0;\n    var scenarios = [{\n        name: 'Sync Get Handler',\n        async: false,\n        getHandler: function getHandler(name) {\n            return handlers[name] || (handlers[name] = (0, _test_helpers.createHandler)(name));\n        }\n    }, {\n        name: 'Async Get Handler',\n        async: true,\n        getHandler: function getHandler(name) {\n            return _rsvp.Promise.resolve(handlers[name] || (handlers[name] = (0, _test_helpers.createHandler)(name)));\n        }\n    }];\n    scenarios.forEach(function (scenario) {\n        var TransitionRouter = function (_TestRouter) {\n            _inherits(TransitionRouter, _TestRouter);\n\n            function TransitionRouter() {\n                _classCallCheck(this, TransitionRouter);\n\n                return _possibleConstructorReturn(this, (TransitionRouter.__proto__ || Object.getPrototypeOf(TransitionRouter)).apply(this, arguments));\n            }\n\n            _createClass(TransitionRouter, [{\n                key: 'getRoute',\n                value: function getRoute(name) {\n                    return scenario.getHandler(name);\n                }\n            }]);\n\n            return TransitionRouter;\n        }(_test_helpers.TestRouter);\n\n        var router = void 0;\n        // Asserts that a handler from a handlerInfo equals an expected valued.\n        // Returns a promise during async scenarios to wait until the handler is ready.\n        function assertHandlerEquals(assert, handlerInfo, expected) {\n            if (!scenario.async) {\n                return assert.equal(handlerInfo.route, expected);\n            } else {\n                assert.equal(handlerInfo.route, undefined);\n                return handlerInfo.routePromise.then(function (handler) {\n                    assert.equal(handler, expected);\n                });\n            }\n        }\n        // TODO: remove repetition, DRY in to test_helpers.\n        (0, _test_helpers.module)('TransitionIntent (' + scenario.name + ')', {\n            setup: function setup() {\n                handlers = {};\n                handlers.foo = (0, _test_helpers.createHandler)('foo');\n                handlers.bar = (0, _test_helpers.createHandler)('bar');\n                handlers.articles = (0, _test_helpers.createHandler)('articles');\n                handlers.comments = (0, _test_helpers.createHandler)('comments');\n                recognizer = {\n                    handlersFor: function handlersFor(name) {\n                        if (name === 'comments') {\n                            return [{\n                                handler: 'articles',\n                                names: ['article_id']\n                            }, {\n                                handler: 'comments',\n                                names: ['comment_id']\n                            }];\n                        }\n                        return;\n                    },\n                    hasRoute: function hasRoute(name) {\n                        return name === 'comments';\n                    },\n                    recognize: function recognize(url) {\n                        if (url === '/foo/bar') {\n                            return [{\n                                handler: 'foo',\n                                isDynamic: false,\n                                params: {}\n                            }, {\n                                handler: 'bar',\n                                isDynamic: false,\n                                params: {}\n                            }];\n                        } else if (url === '/articles/123/comments/456') {\n                            return [{\n                                handler: 'articles',\n                                isDynamic: true,\n                                params: { article_id: '123' }\n                            }, {\n                                handler: 'comments',\n                                isDynamic: true,\n                                params: { comment_id: '456' }\n                            }];\n                        }\n                        return;\n                    }\n                };\n                router = new TransitionRouter();\n                router.recognizer = recognizer;\n            }\n        });\n        (0, _test_helpers.test)('URLTransitionIntent can be applied to an empty state', function (assert) {\n            var state = new _transitionState2.default();\n            var intent = new _urlTransitionIntent2.default(router, '/foo/bar');\n            var newState = intent.applyToState(state);\n            var handlerInfos = newState.routeInfos;\n            assert.equal(handlerInfos.length, 2);\n            assert.notOk(handlerInfos[0].isResolved, 'generated state consists of unresolved handler info, 1');\n            assert.notOk(handlerInfos[1].isResolved, 'generated state consists of unresolved handler info, 2');\n            _rsvp.Promise.all([assertHandlerEquals(assert, handlerInfos[0], handlers.foo), assertHandlerEquals(assert, handlerInfos[1], handlers.bar)]);\n        });\n        (0, _test_helpers.test)('URLTransitionIntent applied to single unresolved URL handlerInfo', function (assert) {\n            var state = new _transitionState2.default();\n            var startingHandlerInfo = new _routeInfo.UnresolvedRouteInfoByParam(router, 'foo', [], {}, handlers.foo);\n            // This single unresolved handler info will be preserved\n            // in the new array of handlerInfos.\n            // Reason: if it were resolved, we wouldn't want to replace it.\n            // So we only want to replace if it's actually known to be\n            // different.\n            state.routeInfos = [startingHandlerInfo];\n            var intent = new _urlTransitionIntent2.default(router, '/foo/bar');\n            var newState = intent.applyToState(state);\n            var handlerInfos = newState.routeInfos;\n            assert.equal(handlerInfos.length, 2);\n            assert.equal(handlerInfos[0], startingHandlerInfo, \"The starting foo handlerInfo wasn't overridden because the new one wasn't any different\");\n            assert.ok(handlerInfos[1] instanceof _routeInfo.UnresolvedRouteInfoByParam, 'generated state consists of UnresolvedHandlerInfoByParam, 2');\n            assertHandlerEquals(assert, handlerInfos[1], handlers.bar);\n        });\n        (0, _test_helpers.test)('URLTransitionIntent applied to an already-resolved handlerInfo', function (assert) {\n            var state = new _transitionState2.default();\n            var startingHandlerInfo = new _routeInfo.ResolvedRouteInfo(router, 'foo', [], {}, handlers.foo);\n            state.routeInfos = [startingHandlerInfo];\n            var intent = new _urlTransitionIntent2.default(router, '/foo/bar');\n            var newState = intent.applyToState(state);\n            var handlerInfos = newState.routeInfos;\n            assert.equal(handlerInfos.length, 2);\n            assert.equal(handlerInfos[0], startingHandlerInfo, \"The starting foo resolved handlerInfo wasn't overridden because the new one wasn't any different\");\n            assert.ok(handlerInfos[1] instanceof _routeInfo.UnresolvedRouteInfoByParam, 'generated state consists of UnresolvedHandlerInfoByParam, 2');\n            assertHandlerEquals(assert, handlerInfos[1], handlers.bar);\n        });\n        (0, _test_helpers.test)('URLTransitionIntent applied to an already-resolved handlerInfo (non-empty params)', function (assert) {\n            var state = new _transitionState2.default();\n            var article = {};\n            var startingHandlerInfo = new _routeInfo.ResolvedRouteInfo(router, 'articles', [], { article_id: 'some-other-id' }, (0, _test_helpers.createHandler)('articles'), article);\n            state.routeInfos = [startingHandlerInfo];\n            var intent = new _urlTransitionIntent2.default(router, '/articles/123/comments/456');\n            var newState = intent.applyToState(state);\n            var handlerInfos = newState.routeInfos;\n            assert.equal(handlerInfos.length, 2);\n            assert.ok(handlerInfos[0] !== startingHandlerInfo, 'The starting foo resolved handlerInfo was overridden because the new had different params');\n            assert.ok(handlerInfos[1] instanceof _routeInfo.UnresolvedRouteInfoByParam, 'generated state consists of UnresolvedHandlerInfoByParam, 2');\n            assertHandlerEquals(assert, handlerInfos[1], handlers.comments);\n        });\n        (0, _test_helpers.test)('URLTransitionIntent applied to an already-resolved handlerInfo of different route', function (assert) {\n            var state = new _transitionState2.default();\n            var startingHandlerInfo = new _routeInfo.ResolvedRouteInfo(router, 'alex', [], {}, handlers.foo);\n            state.routeInfos = [startingHandlerInfo];\n            var intent = new _urlTransitionIntent2.default(router, '/foo/bar');\n            var newState = intent.applyToState(state);\n            var handlerInfos = newState.routeInfos;\n            assert.equal(handlerInfos.length, 2);\n            assert.ok(handlerInfos[0] !== startingHandlerInfo, 'The starting foo resolved handlerInfo gets overridden because the new one has a different name');\n            assert.ok(handlerInfos[1] instanceof _routeInfo.UnresolvedRouteInfoByParam, 'generated state consists of UnresolvedHandlerInfoByParam, 2');\n            assertHandlerEquals(assert, handlerInfos[1], handlers.bar);\n        });\n        (0, _test_helpers.test)('NamedTransitionIntent applied to an already-resolved handlerInfo (non-empty params)', function (assert) {\n            var state = new _transitionState2.default();\n            var article = {};\n            var comment = {};\n            var startingHandlerInfo = new _routeInfo.ResolvedRouteInfo(router, 'articles', [], { article_id: 'some-other-id' }, (0, _test_helpers.createHandler)('articles'), article);\n            state.routeInfos = [startingHandlerInfo];\n            var intent = new _namedTransitionIntent2.default(router, 'comments', undefined, [article, comment]);\n            var newState = intent.applyToState(state, false);\n            var handlerInfos = newState.routeInfos;\n            assert.equal(handlerInfos.length, 2);\n            assert.equal(handlerInfos[0], startingHandlerInfo);\n            assert.equal(handlerInfos[0].context, article);\n            assert.ok(handlerInfos[1] instanceof _routeInfo.UnresolvedRouteInfoByObject, 'generated state consists of UnresolvedHandlerInfoByObject, 2');\n            assert.equal(handlerInfos[1].context, comment);\n            assertHandlerEquals(assert, handlerInfos[1], handlers.comments);\n        });\n    });\n    //# sourceMappingURL=transition_intent_test.js.map\n});","define('tests/transition_state_test', ['router/route-info', 'router/transition-state', 'rsvp', 'tests/test_helpers'], function (_routeInfo, _transitionState, _rsvp, _test_helpers) {\n    'use strict';\n\n    var _transitionState2 = _interopRequireDefault(_transitionState);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    (0, _test_helpers.module)('TransitionState');\n    (0, _test_helpers.test)('it starts off with default state', function (assert) {\n        var state = new _transitionState2.default();\n        assert.deepEqual(state.routeInfos, [], 'it has an array of handlerInfos');\n    });\n    (0, _test_helpers.test)(\"#resolve delegates to handleInfo objects' resolve()\", function (assert) {\n        assert.expect(7);\n        var state = new _transitionState2.default();\n        var counter = 0;\n        var resolvedHandlerInfos = [{}, {}];\n        state.routeInfos = [(0, _test_helpers.createHandlerInfo)('one', {\n            resolve: function resolve(shouldContinue) {\n                ++counter;\n                assert.equal(counter, 1);\n                shouldContinue();\n                return (0, _rsvp.resolve)(resolvedHandlerInfos[0]);\n            }\n        }), (0, _test_helpers.createHandlerInfo)('two', {\n            resolve: function resolve(shouldContinue) {\n                ++counter;\n                assert.equal(counter, 2);\n                shouldContinue();\n                return (0, _rsvp.resolve)(resolvedHandlerInfos[1]);\n            }\n        })];\n        function keepGoing() {\n            assert.ok(true, 'continuation function was called');\n            return _rsvp.Promise.resolve(false);\n        }\n        state.resolve(keepGoing, {}).then(function (result) {\n            assert.deepEqual(result.routeInfos, resolvedHandlerInfos);\n        });\n    });\n    (0, _test_helpers.test)('State resolution can be halted', function (assert) {\n        assert.expect(2);\n        var state = new _transitionState2.default();\n        state.routeInfos = [(0, _test_helpers.createHandlerInfo)('one', {\n            resolve: function resolve(shouldContinue) {\n                return shouldContinue();\n            }\n        }), (0, _test_helpers.createHandlerInfo)('two', {\n            resolve: function resolve() {\n                assert.ok(false, 'I should not be entered because we threw an error in shouldContinue');\n            }\n        })];\n        function keepGoing() {\n            return (0, _rsvp.reject)('NOPE');\n        }\n        state.resolve(keepGoing, {}).catch(function (reason) {\n            assert.equal(reason.error, 'NOPE');\n            assert.ok(reason.wasAborted, 'state resolution was correctly marked as aborted');\n        });\n        (0, _test_helpers.flushBackburner)();\n    });\n    (0, _test_helpers.test)('Integration w/ HandlerInfos', function (assert) {\n        assert.expect(4);\n        var state = new _transitionState2.default();\n        var router = new _test_helpers.TestRouter();\n        var fooModel = {};\n        var barModel = {};\n        var transition = {};\n        state.routeInfos = [new _routeInfo.UnresolvedRouteInfoByParam(router, 'foo', ['foo_id'], { foo_id: '123' }, (0, _test_helpers.createHandler)('foo', {\n            model: function model(params, payload) {\n                assert.equal(payload, transition);\n                assert.equal(params.foo_id, '123', 'foo#model received expected params');\n                return (0, _rsvp.resolve)(fooModel);\n            }\n        })), new _routeInfo.UnresolvedRouteInfoByObject(router, 'bar', ['bar_id'], (0, _rsvp.resolve)(barModel))];\n        function noop() {\n            return _rsvp.Promise.resolve(false);\n        }\n        state.resolve(noop, transition).then(function (result) {\n            var models = [];\n            for (var i = 0; i < result.routeInfos.length; i++) {\n                models.push(result.routeInfos[i].context);\n            }\n            assert.equal(models[0], fooModel);\n            assert.equal(models[1], barModel);\n            return _rsvp.Promise.resolve(new _transitionState2.default());\n        }).catch(function (error) {\n            assert.ok(false, 'Caught error: ' + error);\n        });\n    });\n    //# sourceMappingURL=transition_state_test.js.map\n});","define('tests/unrecognized-url-error_test', ['router/unrecognized-url-error', 'tests/test_helpers'], function (_unrecognizedUrlError, _test_helpers) {\n    'use strict';\n\n    var _unrecognizedUrlError2 = _interopRequireDefault(_unrecognizedUrlError);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    (0, _test_helpers.module)('unrecognized-url-error');\n    (0, _test_helpers.test)('correct inheritance', function (assert) {\n        var error = void 0;\n        try {\n            throw new _unrecognizedUrlError2.default('Message');\n        } catch (e) {\n            error = e;\n        }\n        assert.ok(error instanceof _unrecognizedUrlError2.default);\n        assert.ok(error instanceof Error);\n    });\n    //# sourceMappingURL=unrecognized-url-error_test.js.map\n});","define('tests/utils_test', ['router/utils', 'tests/test_helpers'], function (_utils, _test_helpers) {\n    'use strict';\n\n    (0, _test_helpers.module)('utils');\n    (0, _test_helpers.test)('getChangelist', function (assert) {\n        var result = (0, _utils.getChangelist)({}, { foo: '123' });\n        assert.deepEqual(result, {\n            all: { foo: '123' },\n            changed: { foo: '123' },\n            removed: {}\n        });\n        result = (0, _utils.getChangelist)({ foo: '123' }, { foo: '123' });\n        assert.notOk(result);\n        result = (0, _utils.getChangelist)({ foo: '123' }, {});\n        assert.deepEqual(result, { all: {}, changed: {}, removed: { foo: '123' } });\n        result = (0, _utils.getChangelist)({ foo: '123', bar: '456' }, { foo: '123' });\n        assert.deepEqual(result, {\n            all: { foo: '123' },\n            changed: {},\n            removed: { bar: '456' }\n        });\n        result = (0, _utils.getChangelist)({ foo: '123', bar: '456' }, { foo: '456' });\n        assert.deepEqual(result, {\n            all: { foo: '456' },\n            changed: { foo: '456' },\n            removed: { bar: '456' }\n        });\n    });\n    //# sourceMappingURL=utils_test.js.map\n});"],"names":[],"mappings":"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACviBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACt1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;","file":"tests.js"}