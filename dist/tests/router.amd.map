{"version":3,"sources":["router/core.js","router/index.js","router/route-info.js","router/router.js","router/transition-aborted-error.js","router/transition-intent.js","router/transition-intent/named-transition-intent.js","router/transition-intent/url-transition-intent.js","router/transition-state.js","router/transition.js","router/unrecognized-url-error.js","router/utils.js"],"sourcesContent":["//# sourceMappingURL=core.js.map\ndefine(\"router/core\", [], function () {\n  \"use strict\";\n});","define('router/index', ['exports', 'router/router', 'router/transition', 'router/transition-state', 'router/route-info'], function (exports, _router, _transition, _transitionState, _routeInfo) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  Object.defineProperty(exports, 'default', {\n    enumerable: true,\n    get: function () {\n      return _interopRequireDefault(_router).default;\n    }\n  });\n  Object.defineProperty(exports, 'InternalTransition', {\n    enumerable: true,\n    get: function () {\n      return _interopRequireDefault(_transition).default;\n    }\n  });\n  Object.defineProperty(exports, 'logAbort', {\n    enumerable: true,\n    get: function () {\n      return _transition.logAbort;\n    }\n  });\n  Object.defineProperty(exports, 'STATE_SYMBOL', {\n    enumerable: true,\n    get: function () {\n      return _transition.STATE_SYMBOL;\n    }\n  });\n  Object.defineProperty(exports, 'PARAMS_SYMBOL', {\n    enumerable: true,\n    get: function () {\n      return _transition.PARAMS_SYMBOL;\n    }\n  });\n  Object.defineProperty(exports, 'QUERY_PARAMS_SYMBOL', {\n    enumerable: true,\n    get: function () {\n      return _transition.QUERY_PARAMS_SYMBOL;\n    }\n  });\n  Object.defineProperty(exports, 'TransitionState', {\n    enumerable: true,\n    get: function () {\n      return _interopRequireDefault(_transitionState).default;\n    }\n  });\n  Object.defineProperty(exports, 'TransitionError', {\n    enumerable: true,\n    get: function () {\n      return _transitionState.TransitionError;\n    }\n  });\n  Object.defineProperty(exports, 'InternalRouteInfo', {\n    enumerable: true,\n    get: function () {\n      return _interopRequireDefault(_routeInfo).default;\n    }\n  });\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n});","define('router/route-info', ['exports', 'rsvp', 'router/transition', 'router/utils'], function (exports, _rsvp, _transition2, _utils) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.UnresolvedRouteInfoByObject = exports.UnresolvedRouteInfoByParam = exports.ResolvedRouteInfo = undefined;\n    exports.toReadOnlyRouteInfo = toReadOnlyRouteInfo;\n\n    var _get = function get(object, property, receiver) {\n        if (object === null) object = Function.prototype;\n        var desc = Object.getOwnPropertyDescriptor(object, property);\n\n        if (desc === undefined) {\n            var parent = Object.getPrototypeOf(object);\n\n            if (parent === null) {\n                return undefined;\n            } else {\n                return get(parent, property, receiver);\n            }\n        } else if (\"value\" in desc) {\n            return desc.value;\n        } else {\n            var getter = desc.get;\n\n            if (getter === undefined) {\n                return undefined;\n            }\n\n            return getter.call(receiver);\n        }\n    };\n\n    function _possibleConstructorReturn(self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    var ROUTE_INFOS = new WeakMap();\n    function toReadOnlyRouteInfo(routeInfos) {\n        var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var includeAttributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        return routeInfos.map(function (info, i) {\n            var name = info.name,\n                params = info.params,\n                paramNames = info.paramNames,\n                context = info.context,\n                route = info.route;\n\n            if (ROUTE_INFOS.has(info) && includeAttributes) {\n                var _routeInfo = ROUTE_INFOS.get(info);\n                _routeInfo = attachMetadata(route, _routeInfo);\n                var routeInfoWithAttribute = createRouteInfoWithAttributes(_routeInfo, context);\n                ROUTE_INFOS.set(info, routeInfoWithAttribute);\n                return routeInfoWithAttribute;\n            }\n            var routeInfo = {\n                find: function find(predicate, thisArg) {\n                    var publicInfo = void 0;\n                    var arr = [];\n                    if (predicate.length === 3) {\n                        arr = routeInfos.map(function (info) {\n                            return ROUTE_INFOS.get(info);\n                        });\n                    }\n                    for (var _i = 0; routeInfos.length > _i; _i++) {\n                        publicInfo = ROUTE_INFOS.get(routeInfos[_i]);\n                        if (predicate.call(thisArg, publicInfo, _i, arr)) {\n                            return publicInfo;\n                        }\n                    }\n                    return undefined;\n                },\n\n                get name() {\n                    return name;\n                },\n                get paramNames() {\n                    return paramNames;\n                },\n                get metadata() {\n                    return buildRouteInfoMetadata(info.route);\n                },\n                get parent() {\n                    var parent = routeInfos[i - 1];\n                    if (parent === undefined) {\n                        return null;\n                    }\n                    return ROUTE_INFOS.get(parent);\n                },\n                get child() {\n                    var child = routeInfos[i + 1];\n                    if (child === undefined) {\n                        return null;\n                    }\n                    return ROUTE_INFOS.get(child);\n                },\n                get localName() {\n                    var parts = this.name.split('.');\n                    return parts[parts.length - 1];\n                },\n                get params() {\n                    return params;\n                },\n                get queryParams() {\n                    return queryParams;\n                }\n            };\n            if (includeAttributes) {\n                routeInfo = createRouteInfoWithAttributes(routeInfo, context);\n            }\n            ROUTE_INFOS.set(info, routeInfo);\n            return routeInfo;\n        });\n    }\n    function createRouteInfoWithAttributes(routeInfo, context) {\n        var attributes = {\n            get attributes() {\n                return context;\n            }\n        };\n        if (!Object.isExtensible(routeInfo) || routeInfo.hasOwnProperty('attributes')) {\n            return Object.freeze(Object.assign({}, routeInfo, attributes));\n        }\n        return Object.assign(routeInfo, attributes);\n    }\n    function buildRouteInfoMetadata(route) {\n        if (route !== undefined && route !== null && route.buildRouteInfoMetadata !== undefined) {\n            return route.buildRouteInfoMetadata();\n        }\n        return null;\n    }\n    function attachMetadata(route, routeInfo) {\n        var metadata = {\n            get metadata() {\n                return buildRouteInfoMetadata(route);\n            }\n        };\n        if (!Object.isExtensible(routeInfo) || routeInfo.hasOwnProperty('metadata')) {\n            return Object.freeze(Object.assign({}, routeInfo, metadata));\n        }\n        return Object.assign(routeInfo, metadata);\n    }\n\n    var InternalRouteInfo = function () {\n        function InternalRouteInfo(router, name, paramNames, route) {\n            _classCallCheck(this, InternalRouteInfo);\n\n            this._routePromise = undefined;\n            this._route = null;\n            this.params = {};\n            this.isResolved = false;\n            this.name = name;\n            this.paramNames = paramNames;\n            this.router = router;\n            if (route) {\n                this._processRoute(route);\n            }\n        }\n\n        _createClass(InternalRouteInfo, [{\n            key: 'getModel',\n            value: function getModel(_transition) {\n                return _rsvp.Promise.resolve(this.context);\n            }\n        }, {\n            key: 'serialize',\n            value: function serialize(_context) {\n                return this.params || {};\n            }\n        }, {\n            key: 'resolve',\n            value: function resolve(shouldContinue, transition) {\n                var _this = this;\n\n                return _rsvp.Promise.resolve(this.routePromise).then(function (route) {\n                    return _this.checkForAbort(shouldContinue, route);\n                }).then(function () {\n                    return _this.runBeforeModelHook(transition);\n                }).then(function () {\n                    return _this.checkForAbort(shouldContinue, null);\n                }).then(function () {\n                    return _this.getModel(transition);\n                }).then(function (resolvedModel) {\n                    return _this.checkForAbort(shouldContinue, resolvedModel);\n                }).then(function (resolvedModel) {\n                    return _this.runAfterModelHook(transition, resolvedModel);\n                }).then(function (resolvedModel) {\n                    return _this.becomeResolved(transition, resolvedModel);\n                });\n            }\n        }, {\n            key: 'becomeResolved',\n            value: function becomeResolved(transition, resolvedContext) {\n                var params = this.serialize(resolvedContext);\n                if (transition) {\n                    this.stashResolvedModel(transition, resolvedContext);\n                    transition[_transition2.PARAMS_SYMBOL] = transition[_transition2.PARAMS_SYMBOL] || {};\n                    transition[_transition2.PARAMS_SYMBOL][this.name] = params;\n                }\n                var context = void 0;\n                var contextsMatch = resolvedContext === this.context;\n                if ('context' in this || !contextsMatch) {\n                    context = resolvedContext;\n                }\n                var cached = ROUTE_INFOS.get(this);\n                var resolved = new ResolvedRouteInfo(this.router, this.name, this.paramNames, params, this.route, context);\n                if (cached !== undefined) {\n                    ROUTE_INFOS.set(resolved, cached);\n                }\n                return resolved;\n            }\n        }, {\n            key: 'shouldSupercede',\n            value: function shouldSupercede(routeInfo) {\n                // Prefer this newer routeInfo over `other` if:\n                // 1) The other one doesn't exist\n                // 2) The names don't match\n                // 3) This route has a context that doesn't match\n                //    the other one (or the other one doesn't have one).\n                // 4) This route has parameters that don't match the other.\n                if (!routeInfo) {\n                    return true;\n                }\n                var contextsMatch = routeInfo.context === this.context;\n                return routeInfo.name !== this.name || 'context' in this && !contextsMatch || this.hasOwnProperty('params') && !paramsMatch(this.params, routeInfo.params);\n            }\n        }, {\n            key: 'log',\n            value: function log(transition, message) {\n                if (transition.log) {\n                    transition.log(this.name + ': ' + message);\n                }\n            }\n        }, {\n            key: 'updateRoute',\n            value: function updateRoute(route) {\n                route._internalName = this.name;\n                return this.route = route;\n            }\n        }, {\n            key: 'runBeforeModelHook',\n            value: function runBeforeModelHook(transition) {\n                if (transition.trigger) {\n                    transition.trigger(true, 'willResolveModel', transition, this.route);\n                }\n                var result = void 0;\n                if (this.route) {\n                    if (this.route.beforeModel !== undefined) {\n                        result = this.route.beforeModel(transition);\n                    }\n                }\n                if ((0, _transition2.isTransition)(result)) {\n                    result = null;\n                }\n                return _rsvp.Promise.resolve(result);\n            }\n        }, {\n            key: 'runAfterModelHook',\n            value: function runAfterModelHook(transition, resolvedModel) {\n                // Stash the resolved model on the payload.\n                // This makes it possible for users to swap out\n                // the resolved model in afterModel.\n                var name = this.name;\n                this.stashResolvedModel(transition, resolvedModel);\n                var result = void 0;\n                if (this.route !== undefined) {\n                    if (this.route.afterModel !== undefined) {\n                        result = this.route.afterModel(resolvedModel, transition);\n                    }\n                }\n                result = (0, _transition2.prepareResult)(result);\n                return _rsvp.Promise.resolve(result).then(function () {\n                    // Ignore the fulfilled value returned from afterModel.\n                    // Return the value stashed in resolvedModels, which\n                    // might have been swapped out in afterModel.\n                    return transition.resolvedModels[name];\n                });\n            }\n        }, {\n            key: 'checkForAbort',\n            value: function checkForAbort(shouldContinue, value) {\n                return _rsvp.Promise.resolve(shouldContinue()).then(function () {\n                    // We don't care about shouldContinue's resolve value;\n                    // pass along the original value passed to this fn.\n                    return value;\n                }, null);\n            }\n        }, {\n            key: 'stashResolvedModel',\n            value: function stashResolvedModel(transition, resolvedModel) {\n                transition.resolvedModels = transition.resolvedModels || {};\n                transition.resolvedModels[this.name] = resolvedModel;\n            }\n        }, {\n            key: 'fetchRoute',\n            value: function fetchRoute() {\n                var route = this.router.getRoute(this.name);\n                return this._processRoute(route);\n            }\n        }, {\n            key: '_processRoute',\n            value: function _processRoute(route) {\n                var _this2 = this;\n\n                // Setup a routePromise so that we can wait for asynchronously loaded routes\n                this.routePromise = _rsvp.Promise.resolve(route);\n                // Wait until the 'route' property has been updated when chaining to a route\n                // that is a promise\n                if ((0, _utils.isPromise)(route)) {\n                    this.routePromise = this.routePromise.then(function (r) {\n                        return _this2.updateRoute(r);\n                    });\n                    // set to undefined to avoid recursive loop in the route getter\n                    return this.route = undefined;\n                } else if (route) {\n                    return this.updateRoute(route);\n                }\n                return undefined;\n            }\n        }, {\n            key: 'route',\n            get: function get() {\n                // _route could be set to either a route object or undefined, so we\n                // compare against null to know when it's been set\n                if (this._route !== null) {\n                    return this._route;\n                }\n                return this.fetchRoute();\n            },\n            set: function set(route) {\n                this._route = route;\n            }\n        }, {\n            key: 'routePromise',\n            get: function get() {\n                if (this._routePromise) {\n                    return this._routePromise;\n                }\n                this.fetchRoute();\n                return this._routePromise;\n            },\n            set: function set(routePromise) {\n                this._routePromise = routePromise;\n            }\n        }]);\n\n        return InternalRouteInfo;\n    }();\n\n    exports.default = InternalRouteInfo;\n\n    var ResolvedRouteInfo = exports.ResolvedRouteInfo = function (_InternalRouteInfo) {\n        _inherits(ResolvedRouteInfo, _InternalRouteInfo);\n\n        function ResolvedRouteInfo(router, name, paramNames, params, route, context) {\n            _classCallCheck(this, ResolvedRouteInfo);\n\n            var _this3 = _possibleConstructorReturn(this, (ResolvedRouteInfo.__proto__ || Object.getPrototypeOf(ResolvedRouteInfo)).call(this, router, name, paramNames, route));\n\n            _this3.params = params;\n            _this3.isResolved = true;\n            _this3.context = context;\n            return _this3;\n        }\n\n        _createClass(ResolvedRouteInfo, [{\n            key: 'resolve',\n            value: function resolve(_shouldContinue, transition) {\n                // A ResolvedRouteInfo just resolved with itself.\n                if (transition && transition.resolvedModels) {\n                    transition.resolvedModels[this.name] = this.context;\n                }\n                return _rsvp.Promise.resolve(this);\n            }\n        }]);\n\n        return ResolvedRouteInfo;\n    }(InternalRouteInfo);\n\n    var UnresolvedRouteInfoByParam = exports.UnresolvedRouteInfoByParam = function (_InternalRouteInfo2) {\n        _inherits(UnresolvedRouteInfoByParam, _InternalRouteInfo2);\n\n        function UnresolvedRouteInfoByParam(router, name, paramNames, params, route) {\n            _classCallCheck(this, UnresolvedRouteInfoByParam);\n\n            var _this4 = _possibleConstructorReturn(this, (UnresolvedRouteInfoByParam.__proto__ || Object.getPrototypeOf(UnresolvedRouteInfoByParam)).call(this, router, name, paramNames, route));\n\n            _this4.params = {};\n            _this4.params = params;\n            return _this4;\n        }\n\n        _createClass(UnresolvedRouteInfoByParam, [{\n            key: 'getModel',\n            value: function getModel(transition) {\n                var fullParams = this.params;\n                if (transition && transition[_transition2.QUERY_PARAMS_SYMBOL]) {\n                    fullParams = {};\n                    (0, _utils.merge)(fullParams, this.params);\n                    fullParams.queryParams = transition[_transition2.QUERY_PARAMS_SYMBOL];\n                }\n                var route = this.route;\n                var result = undefined;\n                if (route.deserialize) {\n                    result = route.deserialize(fullParams, transition);\n                } else if (route.model) {\n                    result = route.model(fullParams, transition);\n                }\n                if (result && (0, _transition2.isTransition)(result)) {\n                    result = undefined;\n                }\n                return _rsvp.Promise.resolve(result);\n            }\n        }]);\n\n        return UnresolvedRouteInfoByParam;\n    }(InternalRouteInfo);\n\n    var UnresolvedRouteInfoByObject = exports.UnresolvedRouteInfoByObject = function (_InternalRouteInfo3) {\n        _inherits(UnresolvedRouteInfoByObject, _InternalRouteInfo3);\n\n        function UnresolvedRouteInfoByObject(router, name, paramNames, context) {\n            _classCallCheck(this, UnresolvedRouteInfoByObject);\n\n            var _this5 = _possibleConstructorReturn(this, (UnresolvedRouteInfoByObject.__proto__ || Object.getPrototypeOf(UnresolvedRouteInfoByObject)).call(this, router, name, paramNames));\n\n            _this5.context = context;\n            _this5.serializer = _this5.router.getSerializer(name);\n            return _this5;\n        }\n\n        _createClass(UnresolvedRouteInfoByObject, [{\n            key: 'getModel',\n            value: function getModel(transition) {\n                if (this.router.log !== undefined) {\n                    this.router.log(this.name + ': resolving provided model');\n                }\n                return _get(UnresolvedRouteInfoByObject.prototype.__proto__ || Object.getPrototypeOf(UnresolvedRouteInfoByObject.prototype), 'getModel', this).call(this, transition);\n            }\n            /**\n              @private\n                 Serializes a route using its custom `serialize` method or\n              by a default that looks up the expected property name from\n              the dynamic segment.\n                 @param {Object} model the model to be serialized for this route\n            */\n\n        }, {\n            key: 'serialize',\n            value: function serialize(model) {\n                var paramNames = this.paramNames,\n                    context = this.context;\n\n                if (!model) {\n                    model = context;\n                }\n                var object = {};\n                if ((0, _utils.isParam)(model)) {\n                    object[paramNames[0]] = model;\n                    return object;\n                }\n                // Use custom serialize if it exists.\n                if (this.serializer) {\n                    // invoke this.serializer unbound (getSerializer returns a stateless function)\n                    return this.serializer.call(null, model, paramNames);\n                } else if (this.route !== undefined) {\n                    if (this.route.serialize) {\n                        return this.route.serialize(model, paramNames);\n                    }\n                }\n                if (paramNames.length !== 1) {\n                    return;\n                }\n                var name = paramNames[0];\n                if (/_id$/.test(name)) {\n                    object[name] = model.id;\n                } else {\n                    object[name] = model;\n                }\n                return object;\n            }\n        }]);\n\n        return UnresolvedRouteInfoByObject;\n    }(InternalRouteInfo);\n\n    function paramsMatch(a, b) {\n        if (!a !== !b) {\n            // Only one is null.\n            return false;\n        }\n        if (!a) {\n            // Both must be null.\n            return true;\n        }\n        // Note: this assumes that both params have the same\n        // number of keys, but since we're comparing the\n        // same routes, they should.\n        for (var k in a) {\n            if (a.hasOwnProperty(k) && a[k] !== b[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //# sourceMappingURL=route-info.js.map\n});","define('router/router', ['exports', 'route-recognizer', 'rsvp', 'router/route-info', 'router/transition', 'router/transition-aborted-error', 'router/transition-intent/named-transition-intent', 'router/transition-intent/url-transition-intent', 'router/transition-state', 'router/utils'], function (exports, _routeRecognizer, _rsvp, _routeInfo, _transition, _transitionAbortedError, _namedTransitionIntent, _urlTransitionIntent, _transitionState, _utils) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n\n    var _routeRecognizer2 = _interopRequireDefault(_routeRecognizer);\n\n    var _transition2 = _interopRequireDefault(_transition);\n\n    var _transitionAbortedError2 = _interopRequireDefault(_transitionAbortedError);\n\n    var _namedTransitionIntent2 = _interopRequireDefault(_namedTransitionIntent);\n\n    var _urlTransitionIntent2 = _interopRequireDefault(_urlTransitionIntent);\n\n    var _transitionState2 = _interopRequireDefault(_transitionState);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n    } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    var Router = function () {\n        function Router(logger) {\n            _classCallCheck(this, Router);\n\n            this._lastQueryParams = {};\n            this.state = undefined;\n            this.oldState = undefined;\n            this.activeTransition = undefined;\n            this.currentRouteInfos = undefined;\n            this._changedQueryParams = undefined;\n            this.currentSequence = 0;\n            this.log = logger;\n            this.recognizer = new _routeRecognizer2.default();\n            this.reset();\n        }\n        /**\n          The main entry point into the router. The API is essentially\n          the same as the `map` method in `route-recognizer`.\n             This method extracts the String handler at the last `.to()`\n          call and uses it as the name of the whole route.\n             @param {Function} callback\n        */\n\n\n        _createClass(Router, [{\n            key: 'map',\n            value: function map(callback) {\n                this.recognizer.map(callback, function (recognizer, routes) {\n                    for (var i = routes.length - 1, proceed = true; i >= 0 && proceed; --i) {\n                        var route = routes[i];\n                        var handler = route.handler;\n                        recognizer.add(routes, { as: handler });\n                        proceed = route.path === '/' || route.path === '' || handler.slice(-6) === '.index';\n                    }\n                });\n            }\n        }, {\n            key: 'hasRoute',\n            value: function hasRoute(route) {\n                return this.recognizer.hasRoute(route);\n            }\n        }, {\n            key: 'queryParamsTransition',\n            value: function queryParamsTransition(changelist, wasTransitioning, oldState, newState) {\n                var _this = this;\n\n                this.fireQueryParamDidChange(newState, changelist);\n                if (!wasTransitioning && this.activeTransition) {\n                    // One of the routes in queryParamsDidChange\n                    // caused a transition. Just return that transition.\n                    return this.activeTransition;\n                } else {\n                    // Running queryParamsDidChange didn't change anything.\n                    // Just update query params and be on our way.\n                    // We have to return a noop transition that will\n                    // perform a URL update at the end. This gives\n                    // the user the ability to set the url update\n                    // method (default is replaceState).\n                    var newTransition = new _transition2.default(this, undefined, newState);\n                    newTransition.queryParamsOnly = true;\n                    this.setupContexts(newState, newTransition);\n                    oldState.queryParams = this.finalizeQueryParamChange(newState.routeInfos, newState.queryParams, newTransition);\n                    newTransition[_transition.QUERY_PARAMS_SYMBOL] = newState.queryParams;\n                    this.toReadOnlyInfos(newTransition, newState);\n                    this.routeWillChange(newTransition);\n                    newTransition.promise = newTransition.promise.then(function (result) {\n                        if (!newTransition.isAborted) {\n                            _this._updateURL(newTransition, oldState);\n                            _this.didTransition(_this.currentRouteInfos);\n                            _this.toInfos(newTransition, newState.routeInfos, true);\n                            _this.routeDidChange(newTransition);\n                        }\n                        return result;\n                    }, null, (0, _utils.promiseLabel)('Transition complete'));\n                    return newTransition;\n                }\n            }\n        }, {\n            key: 'transitionByIntent',\n            value: function transitionByIntent(intent, isIntermediate) {\n                try {\n                    return this.getTransitionByIntent(intent, isIntermediate);\n                } catch (e) {\n                    return new _transition2.default(this, intent, undefined, e, undefined);\n                }\n            }\n        }, {\n            key: 'recognize',\n            value: function recognize(url) {\n                var intent = new _urlTransitionIntent2.default(this, url);\n                var newState = this.generateNewState(intent);\n                if (newState === null) {\n                    return newState;\n                }\n                var readonlyInfos = (0, _routeInfo.toReadOnlyRouteInfo)(newState.routeInfos, newState.queryParams);\n                return readonlyInfos[readonlyInfos.length - 1];\n            }\n        }, {\n            key: 'recognizeAndLoad',\n            value: function recognizeAndLoad(url) {\n                var intent = new _urlTransitionIntent2.default(this, url);\n                var newState = this.generateNewState(intent);\n                if (newState === null) {\n                    return _rsvp.Promise.reject('URL ' + url + ' was not recognized');\n                }\n                var newTransition = new _transition2.default(this, intent, newState, undefined);\n                return newTransition.then(function () {\n                    var routeInfosWithAttributes = (0, _routeInfo.toReadOnlyRouteInfo)(newState.routeInfos, newTransition[_transition.QUERY_PARAMS_SYMBOL], true);\n                    return routeInfosWithAttributes[routeInfosWithAttributes.length - 1];\n                });\n            }\n        }, {\n            key: 'generateNewState',\n            value: function generateNewState(intent) {\n                try {\n                    return intent.applyToState(this.state, false);\n                } catch (e) {\n                    return null;\n                }\n            }\n        }, {\n            key: 'getTransitionByIntent',\n            value: function getTransitionByIntent(intent, isIntermediate) {\n                var _this2 = this;\n\n                var wasTransitioning = !!this.activeTransition;\n                var oldState = wasTransitioning ? this.activeTransition[_transition.STATE_SYMBOL] : this.state;\n                var newTransition = void 0;\n                var newState = intent.applyToState(oldState, isIntermediate);\n                var queryParamChangelist = (0, _utils.getChangelist)(oldState.queryParams, newState.queryParams);\n                if (routeInfosEqual(newState.routeInfos, oldState.routeInfos)) {\n                    // This is a no-op transition. See if query params changed.\n                    if (queryParamChangelist) {\n                        var _newTransition = this.queryParamsTransition(queryParamChangelist, wasTransitioning, oldState, newState);\n                        _newTransition.queryParamsOnly = true;\n                        return _newTransition;\n                    }\n                    // No-op. No need to create a new transition.\n                    return this.activeTransition || new _transition2.default(this, undefined, undefined);\n                }\n                if (isIntermediate) {\n                    newState.queryParams = oldState.queryParams;\n                    var transition = new _transition2.default(this, undefined, newState);\n                    this.toReadOnlyInfos(transition, newState);\n                    this.setupContexts(newState, transition);\n                    this.routeWillChange(transition);\n                    return this.activeTransition;\n                }\n                // Create a new transition to the destination route.\n                newTransition = new _transition2.default(this, intent, newState, undefined, this.activeTransition);\n                // transition is to same route with same params, only query params differ.\n                // not caught above probably because refresh() has been used\n                if (routeInfosSameExceptQueryParams(newState.routeInfos, oldState.routeInfos)) {\n                    newTransition.queryParamsOnly = true;\n                }\n                this.toReadOnlyInfos(newTransition, newState);\n                // Abort and usurp any previously active transition.\n                if (this.activeTransition) {\n                    this.activeTransition.redirect(newTransition);\n                }\n                this.activeTransition = newTransition;\n                // Transition promises by default resolve with resolved state.\n                // For our purposes, swap out the promise to resolve\n                // after the transition has been finalized.\n                newTransition.promise = newTransition.promise.then(function (result) {\n                    return _this2.finalizeTransition(newTransition, result);\n                }, null, (0, _utils.promiseLabel)('Settle transition promise when transition is finalized'));\n                if (!wasTransitioning) {\n                    this.notifyExistingHandlers(newState, newTransition);\n                }\n                this.fireQueryParamDidChange(newState, queryParamChangelist);\n                return newTransition;\n            }\n        }, {\n            key: 'doTransition',\n            value: function doTransition(name) {\n                var modelsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n                var isIntermediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n                var lastArg = modelsArray[modelsArray.length - 1];\n                var queryParams = {};\n                if (lastArg !== undefined && lastArg.hasOwnProperty('queryParams')) {\n                    queryParams = modelsArray.pop().queryParams;\n                }\n                var intent = void 0;\n                if (name === undefined) {\n                    (0, _utils.log)(this, 'Updating query params');\n                    // A query param update is really just a transition\n                    // into the route you're already on.\n                    var routeInfos = this.state.routeInfos;\n\n                    intent = new _namedTransitionIntent2.default(this, routeInfos[routeInfos.length - 1].name, undefined, [], queryParams);\n                } else if (name.charAt(0) === '/') {\n                    (0, _utils.log)(this, 'Attempting URL transition to ' + name);\n                    intent = new _urlTransitionIntent2.default(this, name);\n                } else {\n                    (0, _utils.log)(this, 'Attempting transition to ' + name);\n                    intent = new _namedTransitionIntent2.default(this, name, undefined, modelsArray, queryParams);\n                }\n                return this.transitionByIntent(intent, isIntermediate);\n            }\n        }, {\n            key: 'finalizeTransition',\n            value: function finalizeTransition(transition, newState) {\n                try {\n                    (0, _utils.log)(transition.router, transition.sequence, 'Resolved all models on destination route; finalizing transition.');\n                    var routeInfos = newState.routeInfos;\n                    // Run all the necessary enter/setup/exit hooks\n                    this.setupContexts(newState, transition);\n                    // Check if a redirect occurred in enter/setup\n                    if (transition.isAborted) {\n                        // TODO: cleaner way? distinguish b/w targetRouteInfos?\n                        this.state.routeInfos = this.currentRouteInfos;\n                        return _rsvp.Promise.reject((0, _transition.logAbort)(transition));\n                    }\n                    this._updateURL(transition, newState);\n                    transition.isActive = false;\n                    this.activeTransition = undefined;\n                    this.triggerEvent(this.currentRouteInfos, true, 'didTransition', []);\n                    this.didTransition(this.currentRouteInfos);\n                    this.toInfos(transition, newState.routeInfos, true);\n                    this.routeDidChange(transition);\n                    (0, _utils.log)(this, transition.sequence, 'TRANSITION COMPLETE.');\n                    // Resolve with the final route.\n                    return routeInfos[routeInfos.length - 1].route;\n                } catch (e) {\n                    if (!(e instanceof _transitionAbortedError2.default)) {\n                        var infos = transition[_transition.STATE_SYMBOL].routeInfos;\n                        transition.trigger(true, 'error', e, transition, infos[infos.length - 1].route);\n                        transition.abort();\n                    }\n                    throw e;\n                }\n            }\n        }, {\n            key: 'setupContexts',\n            value: function setupContexts(newState, transition) {\n                var partition = this.partitionRoutes(this.state, newState);\n                var i = void 0,\n                    l = void 0,\n                    route = void 0;\n                for (i = 0, l = partition.exited.length; i < l; i++) {\n                    route = partition.exited[i].route;\n                    delete route.context;\n                    if (route !== undefined) {\n                        if (route._internalReset !== undefined) {\n                            route._internalReset(true, transition);\n                        }\n                        if (route.exit !== undefined) {\n                            route.exit(transition);\n                        }\n                    }\n                }\n                var oldState = this.oldState = this.state;\n                this.state = newState;\n                var currentRouteInfos = this.currentRouteInfos = partition.unchanged.slice();\n                try {\n                    for (i = 0, l = partition.reset.length; i < l; i++) {\n                        route = partition.reset[i].route;\n                        if (route !== undefined) {\n                            if (route._internalReset !== undefined) {\n                                route._internalReset(false, transition);\n                            }\n                        }\n                    }\n                    for (i = 0, l = partition.updatedContext.length; i < l; i++) {\n                        this.routeEnteredOrUpdated(currentRouteInfos, partition.updatedContext[i], false, transition);\n                    }\n                    for (i = 0, l = partition.entered.length; i < l; i++) {\n                        this.routeEnteredOrUpdated(currentRouteInfos, partition.entered[i], true, transition);\n                    }\n                } catch (e) {\n                    this.state = oldState;\n                    this.currentRouteInfos = oldState.routeInfos;\n                    throw e;\n                }\n                this.state.queryParams = this.finalizeQueryParamChange(currentRouteInfos, newState.queryParams, transition);\n            }\n        }, {\n            key: 'fireQueryParamDidChange',\n            value: function fireQueryParamDidChange(newState, queryParamChangelist) {\n                // If queryParams changed trigger event\n                if (queryParamChangelist) {\n                    // This is a little hacky but we need some way of storing\n                    // changed query params given that no activeTransition\n                    // is guaranteed to have occurred.\n                    this._changedQueryParams = queryParamChangelist.all;\n                    this.triggerEvent(newState.routeInfos, true, 'queryParamsDidChange', [queryParamChangelist.changed, queryParamChangelist.all, queryParamChangelist.removed]);\n                    this._changedQueryParams = undefined;\n                }\n            }\n        }, {\n            key: 'routeEnteredOrUpdated',\n            value: function routeEnteredOrUpdated(currentRouteInfos, routeInfo, enter, transition) {\n                var route = routeInfo.route,\n                    context = routeInfo.context;\n                function _routeEnteredOrUpdated(route) {\n                    if (enter) {\n                        if (route.enter !== undefined) {\n                            route.enter(transition);\n                        }\n                    }\n                    if (transition && transition.isAborted) {\n                        throw new _transitionAbortedError2.default();\n                    }\n                    route.context = context;\n                    if (route.contextDidChange !== undefined) {\n                        route.contextDidChange();\n                    }\n                    if (route.setup !== undefined) {\n                        route.setup(context, transition);\n                    }\n                    if (transition && transition.isAborted) {\n                        throw new _transitionAbortedError2.default();\n                    }\n                    currentRouteInfos.push(routeInfo);\n                    return route;\n                }\n                // If the route doesn't exist, it means we haven't resolved the route promise yet\n                if (route === undefined) {\n                    routeInfo.routePromise = routeInfo.routePromise.then(_routeEnteredOrUpdated);\n                } else {\n                    _routeEnteredOrUpdated(route);\n                }\n                return true;\n            }\n        }, {\n            key: 'partitionRoutes',\n            value: function partitionRoutes(oldState, newState) {\n                var oldRouteInfos = oldState.routeInfos;\n                var newRouteInfos = newState.routeInfos;\n                var routes = {\n                    updatedContext: [],\n                    exited: [],\n                    entered: [],\n                    unchanged: [],\n                    reset: []\n                };\n                var routeChanged = void 0,\n                    contextChanged = false,\n                    i = void 0,\n                    l = void 0;\n                for (i = 0, l = newRouteInfos.length; i < l; i++) {\n                    var oldRouteInfo = oldRouteInfos[i],\n                        newRouteInfo = newRouteInfos[i];\n                    if (!oldRouteInfo || oldRouteInfo.route !== newRouteInfo.route) {\n                        routeChanged = true;\n                    }\n                    if (routeChanged) {\n                        routes.entered.push(newRouteInfo);\n                        if (oldRouteInfo) {\n                            routes.exited.unshift(oldRouteInfo);\n                        }\n                    } else if (contextChanged || oldRouteInfo.context !== newRouteInfo.context) {\n                        contextChanged = true;\n                        routes.updatedContext.push(newRouteInfo);\n                    } else {\n                        routes.unchanged.push(oldRouteInfo);\n                    }\n                }\n                for (i = newRouteInfos.length, l = oldRouteInfos.length; i < l; i++) {\n                    routes.exited.unshift(oldRouteInfos[i]);\n                }\n                routes.reset = routes.updatedContext.slice();\n                routes.reset.reverse();\n                return routes;\n            }\n        }, {\n            key: '_updateURL',\n            value: function _updateURL(transition, state) {\n                var urlMethod = transition.urlMethod;\n                if (!urlMethod) {\n                    return;\n                }\n                var routeInfos = state.routeInfos;\n                var routeName = routeInfos[routeInfos.length - 1].name;\n\n                var params = {};\n                for (var i = routeInfos.length - 1; i >= 0; --i) {\n                    var routeInfo = routeInfos[i];\n                    (0, _utils.merge)(params, routeInfo.params);\n                    if (routeInfo.route.inaccessibleByURL) {\n                        urlMethod = null;\n                    }\n                }\n                if (urlMethod) {\n                    params.queryParams = transition._visibleQueryParams || state.queryParams;\n                    var url = this.recognizer.generate(routeName, params);\n                    // transitions during the initial transition must always use replaceURL.\n                    // When the app boots, you are at a url, e.g. /foo. If some route\n                    // redirects to bar as part of the initial transition, you don't want to\n                    // add a history entry for /foo. If you do, pressing back will immediately\n                    // hit the redirect again and take you back to /bar, thus killing the back\n                    // button\n                    var initial = transition.isCausedByInitialTransition;\n                    // say you are at / and you click a link to route /foo. In /foo's\n                    // route, the transition is aborted using replacewith('/bar').\n                    // Because the current url is still /, the history entry for / is\n                    // removed from the history. Clicking back will take you to the page\n                    // you were on before /, which is often not even the app, thus killing\n                    // the back button. That's why updateURL is always correct for an\n                    // aborting transition that's not the initial transition\n                    var replaceAndNotAborting = urlMethod === 'replace' && !transition.isCausedByAbortingTransition;\n                    // because calling refresh causes an aborted transition, this needs to be\n                    // special cased - if the initial transition is a replace transition, the\n                    // urlMethod should be honored here.\n                    var isQueryParamsRefreshTransition = transition.queryParamsOnly && urlMethod === 'replace';\n                    // say you are at / and you a `replaceWith(/foo)` is called. Then, that\n                    // transition is aborted with `replaceWith(/bar)`. At the end, we should\n                    // end up with /bar replacing /. We are replacing the replace. We only\n                    // will replace the initial route if all subsequent aborts are also\n                    // replaces. However, there is some ambiguity around the correct behavior\n                    // here.\n                    var replacingReplace = urlMethod === 'replace' && transition.isCausedByAbortingReplaceTransition;\n                    if (initial || replaceAndNotAborting || isQueryParamsRefreshTransition || replacingReplace) {\n                        this.replaceURL(url);\n                    } else {\n                        this.updateURL(url);\n                    }\n                }\n            }\n        }, {\n            key: 'finalizeQueryParamChange',\n            value: function finalizeQueryParamChange(resolvedHandlers, newQueryParams, transition) {\n                // We fire a finalizeQueryParamChange event which\n                // gives the new route hierarchy a chance to tell\n                // us which query params it's consuming and what\n                // their final values are. If a query param is\n                // no longer consumed in the final route hierarchy,\n                // its serialized segment will be removed\n                // from the URL.\n                for (var k in newQueryParams) {\n                    if (newQueryParams.hasOwnProperty(k) && newQueryParams[k] === null) {\n                        delete newQueryParams[k];\n                    }\n                }\n                var finalQueryParamsArray = [];\n                this.triggerEvent(resolvedHandlers, true, 'finalizeQueryParamChange', [newQueryParams, finalQueryParamsArray, transition]);\n                if (transition) {\n                    transition._visibleQueryParams = {};\n                }\n                var finalQueryParams = {};\n                for (var i = 0, len = finalQueryParamsArray.length; i < len; ++i) {\n                    var qp = finalQueryParamsArray[i];\n                    finalQueryParams[qp.key] = qp.value;\n                    if (transition && qp.visible !== false) {\n                        transition._visibleQueryParams[qp.key] = qp.value;\n                    }\n                }\n                return finalQueryParams;\n            }\n        }, {\n            key: 'toReadOnlyInfos',\n            value: function toReadOnlyInfos(newTransition, newState) {\n                var oldRouteInfos = this.state.routeInfos;\n                this.fromInfos(newTransition, oldRouteInfos);\n                this.toInfos(newTransition, newState.routeInfos);\n                this._lastQueryParams = newState.queryParams;\n            }\n        }, {\n            key: 'fromInfos',\n            value: function fromInfos(newTransition, oldRouteInfos) {\n                if (newTransition !== undefined && oldRouteInfos.length > 0) {\n                    var fromInfos = (0, _routeInfo.toReadOnlyRouteInfo)(oldRouteInfos, Object.assign({}, this._lastQueryParams), true);\n                    newTransition.from = fromInfos[fromInfos.length - 1] || null;\n                }\n            }\n        }, {\n            key: 'toInfos',\n            value: function toInfos(newTransition, newRouteInfos) {\n                var includeAttributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n                if (newTransition !== undefined && newRouteInfos.length > 0) {\n                    var toInfos = (0, _routeInfo.toReadOnlyRouteInfo)(newRouteInfos, Object.assign({}, newTransition[_transition.QUERY_PARAMS_SYMBOL]), includeAttributes);\n                    newTransition.to = toInfos[toInfos.length - 1] || null;\n                }\n            }\n        }, {\n            key: 'notifyExistingHandlers',\n            value: function notifyExistingHandlers(newState, newTransition) {\n                var oldRouteInfos = this.state.routeInfos,\n                    changing = [],\n                    i = void 0,\n                    oldRouteInfoLen = void 0,\n                    oldHandler = void 0,\n                    newRouteInfo = void 0;\n                oldRouteInfoLen = oldRouteInfos.length;\n                for (i = 0; i < oldRouteInfoLen; i++) {\n                    oldHandler = oldRouteInfos[i];\n                    newRouteInfo = newState.routeInfos[i];\n                    if (!newRouteInfo || oldHandler.name !== newRouteInfo.name) {\n                        break;\n                    }\n                    if (!newRouteInfo.isResolved) {\n                        changing.push(oldHandler);\n                    }\n                }\n                this.triggerEvent(oldRouteInfos, true, 'willTransition', [newTransition]);\n                this.routeWillChange(newTransition);\n                this.willTransition(oldRouteInfos, newState.routeInfos, newTransition);\n            }\n        }, {\n            key: 'reset',\n            value: function reset() {\n                if (this.state) {\n                    (0, _utils.forEach)(this.state.routeInfos.slice().reverse(), function (routeInfo) {\n                        var route = routeInfo.route;\n                        if (route !== undefined) {\n                            if (route.exit !== undefined) {\n                                route.exit();\n                            }\n                        }\n                        return true;\n                    });\n                }\n                this.oldState = undefined;\n                this.state = new _transitionState2.default();\n                this.currentRouteInfos = undefined;\n            }\n        }, {\n            key: 'handleURL',\n            value: function handleURL(url) {\n                // Perform a URL-based transition, but don't change\n                // the URL afterward, since it already happened.\n                if (url.charAt(0) !== '/') {\n                    url = '/' + url;\n                }\n                return this.doTransition(url).method(null);\n            }\n        }, {\n            key: 'transitionTo',\n            value: function transitionTo(name) {\n                for (var _len = arguments.length, contexts = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                    contexts[_key - 1] = arguments[_key];\n                }\n\n                if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n                    contexts.push(name);\n                    return this.doTransition(undefined, contexts, false);\n                }\n                return this.doTransition(name, contexts);\n            }\n        }, {\n            key: 'intermediateTransitionTo',\n            value: function intermediateTransitionTo(name) {\n                for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                    args[_key2 - 1] = arguments[_key2];\n                }\n\n                return this.doTransition(name, args, true);\n            }\n        }, {\n            key: 'refresh',\n            value: function refresh(pivotRoute) {\n                var previousTransition = this.activeTransition;\n                var state = previousTransition ? previousTransition[_transition.STATE_SYMBOL] : this.state;\n                var routeInfos = state.routeInfos;\n                if (pivotRoute === undefined) {\n                    pivotRoute = routeInfos[0].route;\n                }\n                (0, _utils.log)(this, 'Starting a refresh transition');\n                var name = routeInfos[routeInfos.length - 1].name;\n                var intent = new _namedTransitionIntent2.default(this, name, pivotRoute, [], this._changedQueryParams || state.queryParams);\n                var newTransition = this.transitionByIntent(intent, false);\n                // if the previous transition is a replace transition, that needs to be preserved\n                if (previousTransition && previousTransition.urlMethod === 'replace') {\n                    newTransition.method(previousTransition.urlMethod);\n                }\n                return newTransition;\n            }\n        }, {\n            key: 'replaceWith',\n            value: function replaceWith(name) {\n                return this.doTransition(name).method('replace');\n            }\n        }, {\n            key: 'generate',\n            value: function generate(routeName) {\n                for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                    args[_key3 - 1] = arguments[_key3];\n                }\n\n                var partitionedArgs = (0, _utils.extractQueryParams)(args),\n                    suppliedParams = partitionedArgs[0],\n                    queryParams = partitionedArgs[1];\n                // Construct a TransitionIntent with the provided params\n                // and apply it to the present state of the router.\n                var intent = new _namedTransitionIntent2.default(this, routeName, undefined, suppliedParams);\n                var state = intent.applyToState(this.state, false);\n                var params = {};\n                for (var i = 0, len = state.routeInfos.length; i < len; ++i) {\n                    var routeInfo = state.routeInfos[i];\n                    var routeParams = routeInfo.serialize();\n                    (0, _utils.merge)(params, routeParams);\n                }\n                params.queryParams = queryParams;\n                return this.recognizer.generate(routeName, params);\n            }\n        }, {\n            key: 'applyIntent',\n            value: function applyIntent(routeName, contexts) {\n                var intent = new _namedTransitionIntent2.default(this, routeName, undefined, contexts);\n                var state = this.activeTransition && this.activeTransition[_transition.STATE_SYMBOL] || this.state;\n                return intent.applyToState(state, false);\n            }\n        }, {\n            key: 'isActiveIntent',\n            value: function isActiveIntent(routeName, contexts, queryParams, _state) {\n                var state = _state || this.state,\n                    targetRouteInfos = state.routeInfos,\n                    routeInfo = void 0,\n                    len = void 0;\n                if (!targetRouteInfos.length) {\n                    return false;\n                }\n                var targetHandler = targetRouteInfos[targetRouteInfos.length - 1].name;\n                var recogHandlers = this.recognizer.handlersFor(targetHandler);\n                var index = 0;\n                for (len = recogHandlers.length; index < len; ++index) {\n                    routeInfo = targetRouteInfos[index];\n                    if (routeInfo.name === routeName) {\n                        break;\n                    }\n                }\n                if (index === recogHandlers.length) {\n                    // The provided route name isn't even in the route hierarchy.\n                    return false;\n                }\n                var testState = new _transitionState2.default();\n                testState.routeInfos = targetRouteInfos.slice(0, index + 1);\n                recogHandlers = recogHandlers.slice(0, index + 1);\n                var intent = new _namedTransitionIntent2.default(this, targetHandler, undefined, contexts);\n                var newState = intent.applyToHandlers(testState, recogHandlers, targetHandler, true, true);\n                var routesEqual = routeInfosEqual(newState.routeInfos, testState.routeInfos);\n                if (!queryParams || !routesEqual) {\n                    return routesEqual;\n                }\n                // Get a hash of QPs that will still be active on new route\n                var activeQPsOnNewHandler = {};\n                (0, _utils.merge)(activeQPsOnNewHandler, queryParams);\n                var activeQueryParams = state.queryParams;\n                for (var key in activeQueryParams) {\n                    if (activeQueryParams.hasOwnProperty(key) && activeQPsOnNewHandler.hasOwnProperty(key)) {\n                        activeQPsOnNewHandler[key] = activeQueryParams[key];\n                    }\n                }\n                return routesEqual && !(0, _utils.getChangelist)(activeQPsOnNewHandler, queryParams);\n            }\n        }, {\n            key: 'isActive',\n            value: function isActive(routeName) {\n                for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n                    args[_key4 - 1] = arguments[_key4];\n                }\n\n                var partitionedArgs = (0, _utils.extractQueryParams)(args);\n                return this.isActiveIntent(routeName, partitionedArgs[0], partitionedArgs[1]);\n            }\n        }, {\n            key: 'trigger',\n            value: function trigger(name) {\n                for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                    args[_key5 - 1] = arguments[_key5];\n                }\n\n                this.triggerEvent(this.currentRouteInfos, false, name, args);\n            }\n        }]);\n\n        return Router;\n    }();\n\n    exports.default = Router;\n\n    function routeInfosEqual(routeInfos, otherRouteInfos) {\n        if (routeInfos.length !== otherRouteInfos.length) {\n            return false;\n        }\n        for (var i = 0, len = routeInfos.length; i < len; ++i) {\n            if (routeInfos[i] !== otherRouteInfos[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function routeInfosSameExceptQueryParams(routeInfos, otherRouteInfos) {\n        if (routeInfos.length !== otherRouteInfos.length) {\n            return false;\n        }\n        for (var i = 0, len = routeInfos.length; i < len; ++i) {\n            if (routeInfos[i].name !== otherRouteInfos[i].name) {\n                return false;\n            }\n            if (!paramsEqual(routeInfos[i].params, otherRouteInfos[i].params)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function paramsEqual(params, otherParams) {\n        if (!params && !otherParams) {\n            return true;\n        } else if (!params && !!otherParams || !!params && !otherParams) {\n            // one is falsy but other is not;\n            return false;\n        }\n        var keys = Object.keys(params);\n        var otherKeys = Object.keys(otherParams);\n        if (keys.length !== otherKeys.length) {\n            return false;\n        }\n        for (var i = 0, len = keys.length; i < len; ++i) {\n            var key = keys[i];\n            if (params[key] !== otherParams[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //# sourceMappingURL=router.js.map\n});","define('router/transition-aborted-error', ['exports'], function (exports) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    var TransitionAbortedError = function () {\n        TransitionAbortedError.prototype = Object.create(Error.prototype);\n        TransitionAbortedError.prototype.constructor = TransitionAbortedError;\n        function TransitionAbortedError(message) {\n            var error = Error.call(this, message);\n            this.name = 'TransitionAborted';\n            this.message = message || 'TransitionAborted';\n            if (Error.captureStackTrace) {\n                Error.captureStackTrace(this, TransitionAbortedError);\n            } else {\n                this.stack = error.stack;\n            }\n        }\n        return TransitionAbortedError;\n    }();\n    exports.default = TransitionAbortedError;\n});","define(\"router/transition-intent\", [\"exports\"], function (exports) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var TransitionIntent = exports.TransitionIntent = function TransitionIntent(router) {\n        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, TransitionIntent);\n\n        this.router = router;\n        this.data = data;\n    };\n});","define('router/transition-intent/named-transition-intent', ['exports', 'router/route-info', 'router/transition-intent', 'router/transition-state', 'router/utils'], function (exports, _routeInfo, _transitionIntent, _transitionState, _utils) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n\n    var _transitionState2 = _interopRequireDefault(_transitionState);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    function _possibleConstructorReturn(self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    var NamedTransitionIntent = function (_TransitionIntent) {\n        _inherits(NamedTransitionIntent, _TransitionIntent);\n\n        function NamedTransitionIntent(router, name, pivotHandler) {\n            var contexts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n            var queryParams = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n            var data = arguments[5];\n\n            _classCallCheck(this, NamedTransitionIntent);\n\n            var _this = _possibleConstructorReturn(this, (NamedTransitionIntent.__proto__ || Object.getPrototypeOf(NamedTransitionIntent)).call(this, router, data));\n\n            _this.preTransitionState = undefined;\n            _this.name = name;\n            _this.pivotHandler = pivotHandler;\n            _this.contexts = contexts;\n            _this.queryParams = queryParams;\n            return _this;\n        }\n\n        _createClass(NamedTransitionIntent, [{\n            key: 'applyToState',\n            value: function applyToState(oldState, isIntermediate) {\n                // TODO: WTF fix me\n                var partitionedArgs = (0, _utils.extractQueryParams)([this.name].concat(this.contexts)),\n                    pureArgs = partitionedArgs[0],\n                    handlers = this.router.recognizer.handlersFor(pureArgs[0]);\n                var targetRouteName = handlers[handlers.length - 1].handler;\n                return this.applyToHandlers(oldState, handlers, targetRouteName, isIntermediate, false);\n            }\n        }, {\n            key: 'applyToHandlers',\n            value: function applyToHandlers(oldState, parsedHandlers, targetRouteName, isIntermediate, checkingIfActive) {\n                var i = void 0,\n                    len = void 0;\n                var newState = new _transitionState2.default();\n                var objects = this.contexts.slice(0);\n                var invalidateIndex = parsedHandlers.length;\n                // Pivot handlers are provided for refresh transitions\n                if (this.pivotHandler) {\n                    for (i = 0, len = parsedHandlers.length; i < len; ++i) {\n                        if (parsedHandlers[i].handler === this.pivotHandler._internalName) {\n                            invalidateIndex = i;\n                            break;\n                        }\n                    }\n                }\n                for (i = parsedHandlers.length - 1; i >= 0; --i) {\n                    var result = parsedHandlers[i];\n                    var name = result.handler;\n                    var oldHandlerInfo = oldState.routeInfos[i];\n                    var newHandlerInfo = null;\n                    if (result.names.length > 0) {\n                        if (i >= invalidateIndex) {\n                            newHandlerInfo = this.createParamHandlerInfo(name, result.names, objects, oldHandlerInfo);\n                        } else {\n                            newHandlerInfo = this.getHandlerInfoForDynamicSegment(name, result.names, objects, oldHandlerInfo, targetRouteName, i);\n                        }\n                    } else {\n                        // This route has no dynamic segment.\n                        // Therefore treat as a param-based handlerInfo\n                        // with empty params. This will cause the `model`\n                        // hook to be called with empty params, which is desirable.\n                        newHandlerInfo = this.createParamHandlerInfo(name, result.names, objects, oldHandlerInfo);\n                    }\n                    if (checkingIfActive) {\n                        // If we're performing an isActive check, we want to\n                        // serialize URL params with the provided context, but\n                        // ignore mismatches between old and new context.\n                        newHandlerInfo = newHandlerInfo.becomeResolved(null, newHandlerInfo.context);\n                        var oldContext = oldHandlerInfo && oldHandlerInfo.context;\n                        if (result.names.length > 0 && oldHandlerInfo.context !== undefined && newHandlerInfo.context === oldContext) {\n                            // If contexts match in isActive test, assume params also match.\n                            // This allows for flexibility in not requiring that every last\n                            // handler provide a `serialize` method\n                            newHandlerInfo.params = oldHandlerInfo && oldHandlerInfo.params;\n                        }\n                        newHandlerInfo.context = oldContext;\n                    }\n                    var handlerToUse = oldHandlerInfo;\n                    if (i >= invalidateIndex || newHandlerInfo.shouldSupercede(oldHandlerInfo)) {\n                        invalidateIndex = Math.min(i, invalidateIndex);\n                        handlerToUse = newHandlerInfo;\n                    }\n                    if (isIntermediate && !checkingIfActive) {\n                        handlerToUse = handlerToUse.becomeResolved(null, handlerToUse.context);\n                    }\n                    newState.routeInfos.unshift(handlerToUse);\n                }\n                if (objects.length > 0) {\n                    throw new Error('More context objects were passed than there are dynamic segments for the route: ' + targetRouteName);\n                }\n                if (!isIntermediate) {\n                    this.invalidateChildren(newState.routeInfos, invalidateIndex);\n                }\n                (0, _utils.merge)(newState.queryParams, this.queryParams || {});\n                return newState;\n            }\n        }, {\n            key: 'invalidateChildren',\n            value: function invalidateChildren(handlerInfos, invalidateIndex) {\n                for (var i = invalidateIndex, l = handlerInfos.length; i < l; ++i) {\n                    var handlerInfo = handlerInfos[i];\n                    if (handlerInfo.isResolved) {\n                        var _handlerInfos$i = handlerInfos[i],\n                            name = _handlerInfos$i.name,\n                            params = _handlerInfos$i.params,\n                            route = _handlerInfos$i.route,\n                            paramNames = _handlerInfos$i.paramNames;\n\n                        handlerInfos[i] = new _routeInfo.UnresolvedRouteInfoByParam(this.router, name, paramNames, params, route);\n                    }\n                }\n            }\n        }, {\n            key: 'getHandlerInfoForDynamicSegment',\n            value: function getHandlerInfoForDynamicSegment(name, names, objects, oldHandlerInfo, _targetRouteName, i) {\n                var objectToUse = void 0;\n                if (objects.length > 0) {\n                    // Use the objects provided for this transition.\n                    objectToUse = objects[objects.length - 1];\n                    if ((0, _utils.isParam)(objectToUse)) {\n                        return this.createParamHandlerInfo(name, names, objects, oldHandlerInfo);\n                    } else {\n                        objects.pop();\n                    }\n                } else if (oldHandlerInfo && oldHandlerInfo.name === name) {\n                    // Reuse the matching oldHandlerInfo\n                    return oldHandlerInfo;\n                } else {\n                    if (this.preTransitionState) {\n                        var preTransitionHandlerInfo = this.preTransitionState.routeInfos[i];\n                        objectToUse = preTransitionHandlerInfo && preTransitionHandlerInfo.context;\n                    } else {\n                        // Ideally we should throw this error to provide maximal\n                        // information to the user that not enough context objects\n                        // were provided, but this proves too cumbersome in Ember\n                        // in cases where inner template helpers are evaluated\n                        // before parent helpers un-render, in which cases this\n                        // error somewhat prematurely fires.\n                        //throw new Error(\"Not enough context objects were provided to complete a transition to \" + targetRouteName + \". Specifically, the \" + name + \" route needs an object that can be serialized into its dynamic URL segments [\" + names.join(', ') + \"]\");\n                        return oldHandlerInfo;\n                    }\n                }\n                return new _routeInfo.UnresolvedRouteInfoByObject(this.router, name, names, objectToUse);\n            }\n        }, {\n            key: 'createParamHandlerInfo',\n            value: function createParamHandlerInfo(name, names, objects, oldHandlerInfo) {\n                var params = {};\n                // Soak up all the provided string/numbers\n                var numNames = names.length;\n                var missingParams = [];\n                while (numNames--) {\n                    // Only use old params if the names match with the new handler\n                    var oldParams = oldHandlerInfo && name === oldHandlerInfo.name && oldHandlerInfo.params || {};\n                    var peek = objects[objects.length - 1];\n                    var paramName = names[numNames];\n                    if ((0, _utils.isParam)(peek)) {\n                        params[paramName] = '' + objects.pop();\n                    } else {\n                        // If we're here, this means only some of the params\n                        // were string/number params, so try and use a param\n                        // value from a previous handler.\n                        if (oldParams.hasOwnProperty(paramName)) {\n                            params[paramName] = oldParams[paramName];\n                        } else {\n                            missingParams.push(paramName);\n                        }\n                    }\n                }\n                if (missingParams.length > 0) {\n                    throw new Error('You didn\\'t provide enough string/numeric parameters to satisfy all of the dynamic segments for route ' + name + '.' + (' Missing params: ' + missingParams));\n                }\n                return new _routeInfo.UnresolvedRouteInfoByParam(this.router, name, names, params);\n            }\n        }]);\n\n        return NamedTransitionIntent;\n    }(_transitionIntent.TransitionIntent);\n\n    exports.default = NamedTransitionIntent;\n});","define('router/transition-intent/url-transition-intent', ['exports', 'router/route-info', 'router/transition-intent', 'router/transition-state', 'router/unrecognized-url-error', 'router/utils'], function (exports, _routeInfo, _transitionIntent, _transitionState, _unrecognizedUrlError, _utils) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n\n    var _transitionState2 = _interopRequireDefault(_transitionState);\n\n    var _unrecognizedUrlError2 = _interopRequireDefault(_unrecognizedUrlError);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    function _possibleConstructorReturn(self, call) {\n        if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    var URLTransitionIntent = function (_TransitionIntent) {\n        _inherits(URLTransitionIntent, _TransitionIntent);\n\n        function URLTransitionIntent(router, url, data) {\n            _classCallCheck(this, URLTransitionIntent);\n\n            var _this = _possibleConstructorReturn(this, (URLTransitionIntent.__proto__ || Object.getPrototypeOf(URLTransitionIntent)).call(this, router, data));\n\n            _this.url = url;\n            _this.preTransitionState = undefined;\n            return _this;\n        }\n\n        _createClass(URLTransitionIntent, [{\n            key: 'applyToState',\n            value: function applyToState(oldState) {\n                var newState = new _transitionState2.default();\n                var results = this.router.recognizer.recognize(this.url),\n                    i = void 0,\n                    len = void 0;\n                if (!results) {\n                    throw new _unrecognizedUrlError2.default(this.url);\n                }\n                var statesDiffer = false;\n                var _url = this.url;\n                // Checks if a handler is accessible by URL. If it is not, an error is thrown.\n                // For the case where the handler is loaded asynchronously, the error will be\n                // thrown once it is loaded.\n                function checkHandlerAccessibility(handler) {\n                    if (handler && handler.inaccessibleByURL) {\n                        throw new _unrecognizedUrlError2.default(_url);\n                    }\n                    return handler;\n                }\n                for (i = 0, len = results.length; i < len; ++i) {\n                    var result = results[i];\n                    var name = result.handler;\n                    var paramNames = [];\n                    if (this.router.recognizer.hasRoute(name)) {\n                        paramNames = this.router.recognizer.handlersFor(name)[i].names;\n                    }\n                    var newRouteInfo = new _routeInfo.UnresolvedRouteInfoByParam(this.router, name, paramNames, result.params);\n                    var route = newRouteInfo.route;\n                    if (route) {\n                        checkHandlerAccessibility(route);\n                    } else {\n                        // If the hanlder is being loaded asynchronously, check if we can\n                        // access it after it has resolved\n                        newRouteInfo.routePromise = newRouteInfo.routePromise.then(checkHandlerAccessibility);\n                    }\n                    var oldRouteInfo = oldState.routeInfos[i];\n                    if (statesDiffer || newRouteInfo.shouldSupercede(oldRouteInfo)) {\n                        statesDiffer = true;\n                        newState.routeInfos[i] = newRouteInfo;\n                    } else {\n                        newState.routeInfos[i] = oldRouteInfo;\n                    }\n                }\n                (0, _utils.merge)(newState.queryParams, results.queryParams);\n                return newState;\n            }\n        }]);\n\n        return URLTransitionIntent;\n    }(_transitionIntent.TransitionIntent);\n\n    exports.default = URLTransitionIntent;\n});","define('router/transition-state', ['exports', 'rsvp', 'router/utils'], function (exports, _rsvp, _utils) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.TransitionError = undefined;\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    var TransitionState = function () {\n        function TransitionState() {\n            _classCallCheck(this, TransitionState);\n\n            this.routeInfos = [];\n            this.queryParams = {};\n            this.params = {};\n        }\n\n        _createClass(TransitionState, [{\n            key: 'promiseLabel',\n            value: function promiseLabel(label) {\n                var targetName = '';\n                (0, _utils.forEach)(this.routeInfos, function (routeInfo) {\n                    if (targetName !== '') {\n                        targetName += '.';\n                    }\n                    targetName += routeInfo.name;\n                    return true;\n                });\n                return (0, _utils.promiseLabel)(\"'\" + targetName + \"': \" + label);\n            }\n        }, {\n            key: 'resolve',\n            value: function resolve(shouldContinue, transition) {\n                // First, calculate params for this state. This is useful\n                // information to provide to the various route hooks.\n                var params = this.params;\n                (0, _utils.forEach)(this.routeInfos, function (routeInfo) {\n                    params[routeInfo.name] = routeInfo.params || {};\n                    return true;\n                });\n                transition.resolveIndex = 0;\n                var currentState = this;\n                var wasAborted = false;\n                // The prelude RSVP.resolve() asyncs us into the promise land.\n                return _rsvp.Promise.resolve(null, this.promiseLabel('Start transition')).then(resolveOneRouteInfo, null, this.promiseLabel('Resolve route')).catch(handleError, this.promiseLabel('Handle error'));\n                function innerShouldContinue() {\n                    return _rsvp.Promise.resolve(shouldContinue(), currentState.promiseLabel('Check if should continue')).catch(function (reason) {\n                        // We distinguish between errors that occurred\n                        // during resolution (e.g. before\"Model/model/afterModel),\n                        // and aborts due to a rejecting promise from shouldContinue().\n                        wasAborted = true;\n                        return _rsvp.Promise.reject(reason);\n                    }, currentState.promiseLabel('Handle abort'));\n                }\n                function handleError(error) {\n                    // This is the only possible\n                    // reject value of TransitionState#resolve\n                    var routeInfos = currentState.routeInfos;\n                    var errorHandlerIndex = transition.resolveIndex >= routeInfos.length ? routeInfos.length - 1 : transition.resolveIndex;\n                    return _rsvp.Promise.reject(new TransitionError(error, currentState.routeInfos[errorHandlerIndex].route, wasAborted, currentState));\n                }\n                function proceed(resolvedRouteInfo) {\n                    var wasAlreadyResolved = currentState.routeInfos[transition.resolveIndex].isResolved;\n                    // Swap the previously unresolved routeInfo with\n                    // the resolved routeInfo\n                    currentState.routeInfos[transition.resolveIndex++] = resolvedRouteInfo;\n                    if (!wasAlreadyResolved) {\n                        var route = resolvedRouteInfo.route;\n\n                        if (route !== undefined) {\n                            if (route.redirect) {\n                                route.redirect(resolvedRouteInfo.context, transition);\n                            }\n                        }\n                    }\n                    // Proceed after ensuring that the redirect hook\n                    // didn't abort this transition by transitioning elsewhere.\n                    return innerShouldContinue().then(resolveOneRouteInfo, null, currentState.promiseLabel('Resolve route'));\n                }\n                function resolveOneRouteInfo() {\n                    if (transition.resolveIndex === currentState.routeInfos.length) {\n                        // This is is the only possible\n                        // fulfill value of TransitionState#resolve\n                        return currentState;\n                    }\n                    var routeInfo = currentState.routeInfos[transition.resolveIndex];\n                    return routeInfo.resolve(innerShouldContinue, transition).then(proceed, null, currentState.promiseLabel('Proceed'));\n                }\n            }\n        }]);\n\n        return TransitionState;\n    }();\n\n    exports.default = TransitionState;\n\n    var TransitionError = exports.TransitionError = function TransitionError(error, route, wasAborted, state) {\n        _classCallCheck(this, TransitionError);\n\n        this.error = error;\n        this.route = route;\n        this.wasAborted = wasAborted;\n        this.state = state;\n    };\n});","define('router/transition', ['exports', 'rsvp', 'router/transition-aborted-error', 'router/utils'], function (exports, _rsvp, _transitionAbortedError, _utils) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.QUERY_PARAMS_SYMBOL = exports.PARAMS_SYMBOL = exports.STATE_SYMBOL = undefined;\n    exports.logAbort = logAbort;\n    exports.isTransition = isTransition;\n    exports.prepareResult = prepareResult;\n\n    var _transitionAbortedError2 = _interopRequireDefault(_transitionAbortedError);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n    } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n\n    var _createClass = function () {\n        function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n        };\n    }();\n\n    var STATE_SYMBOL = exports.STATE_SYMBOL = '__STATE__-2619860001345920-3322w3';\n    var PARAMS_SYMBOL = exports.PARAMS_SYMBOL = '__PARAMS__-261986232992830203-23323';\n    var QUERY_PARAMS_SYMBOL = exports.QUERY_PARAMS_SYMBOL = '__QPS__-2619863929824844-32323';\n    /**\n      A Transition is a thennable (a promise-like object) that represents\n      an attempt to transition to another route. It can be aborted, either\n      explicitly via `abort` or by attempting another transition while a\n      previous one is still underway. An aborted transition can also\n      be `retry()`d later.\n    \n      @class Transition\n      @constructor\n      @param {Object} router\n      @param {Object} intent\n      @param {Object} state\n      @param {Object} error\n      @private\n     */\n\n    var Transition = function () {\n        function Transition(router, intent, state) {\n            var _this = this;\n\n            var error = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n            var previousTransition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n\n            _classCallCheck(this, Transition);\n\n            this.from = null;\n            this.to = undefined;\n            this.isAborted = false;\n            this.isActive = true;\n            this.urlMethod = 'update';\n            this.resolveIndex = 0;\n            this.queryParamsOnly = false;\n            this.isTransition = true;\n            this.isCausedByAbortingTransition = false;\n            this.isCausedByInitialTransition = false;\n            this.isCausedByAbortingReplaceTransition = false;\n            this._visibleQueryParams = {};\n            this[STATE_SYMBOL] = state || router.state;\n            this.intent = intent;\n            this.router = router;\n            this.data = intent && intent.data || {};\n            this.resolvedModels = {};\n            this[QUERY_PARAMS_SYMBOL] = {};\n            this.promise = undefined;\n            this.error = undefined;\n            this[PARAMS_SYMBOL] = {};\n            this.routeInfos = [];\n            this.targetName = undefined;\n            this.pivotHandler = undefined;\n            this.sequence = -1;\n            if (error) {\n                this.promise = _rsvp.Promise.reject(error);\n                this.error = error;\n                return;\n            }\n            // if you're doing multiple redirects, need the new transition to know if it\n            // is actually part of the first transition or not. Any further redirects\n            // in the initial transition also need to know if they are part of the\n            // initial transition\n            this.isCausedByAbortingTransition = !!previousTransition;\n            this.isCausedByInitialTransition = !!previousTransition && (previousTransition.isCausedByInitialTransition || previousTransition.sequence === 0);\n            // Every transition in the chain is a replace\n            this.isCausedByAbortingReplaceTransition = !!previousTransition && previousTransition.urlMethod === 'replace' && (!previousTransition.isCausedByAbortingTransition || previousTransition.isCausedByAbortingReplaceTransition);\n            if (state) {\n                this[PARAMS_SYMBOL] = state.params;\n                this[QUERY_PARAMS_SYMBOL] = state.queryParams;\n                this.routeInfos = state.routeInfos;\n                var len = state.routeInfos.length;\n                if (len) {\n                    this.targetName = state.routeInfos[len - 1].name;\n                }\n                for (var i = 0; i < len; ++i) {\n                    var handlerInfo = state.routeInfos[i];\n                    // TODO: this all seems hacky\n                    if (!handlerInfo.isResolved) {\n                        break;\n                    }\n                    this.pivotHandler = handlerInfo.route;\n                }\n                this.sequence = router.currentSequence++;\n                this.promise = state.resolve(function () {\n                    if (_this.isAborted) {\n                        return _rsvp.Promise.reject(false, (0, _utils.promiseLabel)('Transition aborted - reject'));\n                    }\n                    return _rsvp.Promise.resolve(true);\n                }, this).catch(function (result) {\n                    return _rsvp.Promise.reject(_this.router.transitionDidError(result, _this));\n                }, (0, _utils.promiseLabel)('Handle Abort'));\n            } else {\n                this.promise = _rsvp.Promise.resolve(this[STATE_SYMBOL]);\n                this[PARAMS_SYMBOL] = {};\n            }\n        }\n        /**\n          The Transition's internal promise. Calling `.then` on this property\n          is that same as calling `.then` on the Transition object itself, but\n          this property is exposed for when you want to pass around a\n          Transition's promise, but not the Transition object itself, since\n          Transition object can be externally `abort`ed, while the promise\n          cannot.\n             @property promise\n          @type {Object}\n          @public\n         */\n        /**\n          Custom state can be stored on a Transition's `data` object.\n          This can be useful for decorating a Transition within an earlier\n          hook and shared with a later hook. Properties set on `data` will\n          be copied to new transitions generated by calling `retry` on this\n          transition.\n             @property data\n          @type {Object}\n          @public\n         */\n        /**\n          A standard promise hook that resolves if the transition\n          succeeds and rejects if it fails/redirects/aborts.\n             Forwards to the internal `promise` property which you can\n          use in situations where you want to pass around a thennable,\n          but not the Transition itself.\n             @method then\n          @param {Function} onFulfilled\n          @param {Function} onRejected\n          @param {String} label optional string for labeling the promise.\n          Useful for tooling.\n          @return {Promise}\n          @public\n         */\n\n\n        _createClass(Transition, [{\n            key: 'then',\n            value: function then(onFulfilled, onRejected, label) {\n                return this.promise.then(onFulfilled, onRejected, label);\n            }\n        }, {\n            key: 'catch',\n            value: function _catch(onRejection, label) {\n                return this.promise.catch(onRejection, label);\n            }\n        }, {\n            key: 'finally',\n            value: function _finally(callback, label) {\n                return this.promise.finally(callback, label);\n            }\n        }, {\n            key: 'abort',\n            value: function abort() {\n                this.rollback();\n                var transition = new Transition(this.router, undefined, undefined, undefined);\n                transition.to = this.from;\n                transition.from = this.from;\n                transition.isAborted = true;\n                this.router.routeWillChange(transition);\n                this.router.routeDidChange(transition);\n                return this;\n            }\n        }, {\n            key: 'rollback',\n            value: function rollback() {\n                if (!this.isAborted) {\n                    (0, _utils.log)(this.router, this.sequence, this.targetName + ': transition was aborted');\n                    if (this.intent !== undefined && this.intent !== null) {\n                        this.intent.preTransitionState = this.router.state;\n                    }\n                    this.isAborted = true;\n                    this.isActive = false;\n                    this.router.activeTransition = undefined;\n                }\n            }\n        }, {\n            key: 'redirect',\n            value: function redirect(newTransition) {\n                this.rollback();\n                this.router.routeWillChange(newTransition);\n            }\n        }, {\n            key: 'retry',\n            value: function retry() {\n                // TODO: add tests for merged state retry()s\n                this.abort();\n                var newTransition = this.router.transitionByIntent(this.intent, false);\n                // inheriting a `null` urlMethod is not valid\n                // the urlMethod is only set to `null` when\n                // the transition is initiated *after* the url\n                // has been updated (i.e. `router.handleURL`)\n                //\n                // in that scenario, the url method cannot be\n                // inherited for a new transition because then\n                // the url would not update even though it should\n                if (this.urlMethod !== null) {\n                    newTransition.method(this.urlMethod);\n                }\n                return newTransition;\n            }\n        }, {\n            key: 'method',\n            value: function method(_method) {\n                this.urlMethod = _method;\n                return this;\n            }\n        }, {\n            key: 'send',\n            value: function send() {\n                var ignoreFailure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n                var _name = arguments[1];\n                var err = arguments[2];\n                var transition = arguments[3];\n                var handler = arguments[4];\n\n                this.trigger(ignoreFailure, _name, err, transition, handler);\n            }\n        }, {\n            key: 'trigger',\n            value: function trigger() {\n                var ignoreFailure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n                var name = arguments[1];\n\n                // TODO: Deprecate the current signature\n                if (typeof ignoreFailure === 'string') {\n                    name = ignoreFailure;\n                    ignoreFailure = false;\n                }\n\n                for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n                    args[_key - 2] = arguments[_key];\n                }\n\n                this.router.triggerEvent(this[STATE_SYMBOL].routeInfos.slice(0, this.resolveIndex + 1), ignoreFailure, name, args);\n            }\n        }, {\n            key: 'followRedirects',\n            value: function followRedirects() {\n                var router = this.router;\n                return this.promise.catch(function (reason) {\n                    if (router.activeTransition) {\n                        return router.activeTransition.followRedirects();\n                    }\n                    return _rsvp.Promise.reject(reason);\n                });\n            }\n        }, {\n            key: 'toString',\n            value: function toString() {\n                return 'Transition (sequence ' + this.sequence + ')';\n            }\n        }, {\n            key: 'log',\n            value: function log(message) {\n                (0, _utils.log)(this.router, this.sequence, message);\n            }\n        }]);\n\n        return Transition;\n    }();\n\n    exports.default = Transition;\n\n    /**\n      @private\n    \n      Logs and returns an instance of TransitionAborted.\n     */\n    function logAbort(transition) {\n        (0, _utils.log)(transition.router, transition.sequence, 'detected abort.');\n        return new _transitionAbortedError2.default();\n    }\n    function isTransition(obj) {\n        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj instanceof Transition && obj.isTransition;\n    }\n    function prepareResult(obj) {\n        if (isTransition(obj)) {\n            return null;\n        }\n        return obj;\n    }\n    //# sourceMappingURL=transition.js.map\n});","define('router/unrecognized-url-error', ['exports'], function (exports) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    var UnrecognizedURLError = function () {\n        UnrecognizedURLError.prototype = Object.create(Error.prototype);\n        UnrecognizedURLError.prototype.constructor = UnrecognizedURLError;\n        function UnrecognizedURLError(message) {\n            var error = Error.call(this, message);\n            this.name = 'UnrecognizedURLError';\n            this.message = message || 'UnrecognizedURL';\n            if (Error.captureStackTrace) {\n                Error.captureStackTrace(this, UnrecognizedURLError);\n            } else {\n                this.stack = error.stack;\n            }\n        }\n        return UnrecognizedURLError;\n    }();\n    exports.default = UnrecognizedURLError;\n});","define('router/utils', ['exports'], function (exports) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.isPromise = isPromise;\n    exports.merge = merge;\n    exports.extractQueryParams = extractQueryParams;\n    exports.coerceQueryParamsToString = coerceQueryParamsToString;\n    exports.log = log;\n    exports.isParam = isParam;\n    exports.forEach = forEach;\n    exports.getChangelist = getChangelist;\n    exports.promiseLabel = promiseLabel;\n\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n    } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    var slice = exports.slice = Array.prototype.slice;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    /**\n      Determines if an object is Promise by checking if it is \"thenable\".\n    **/\n    function isPromise(p) {\n        return p !== null && (typeof p === 'undefined' ? 'undefined' : _typeof(p)) === 'object' && typeof p.then === 'function';\n    }\n    function merge(hash, other) {\n        for (var prop in other) {\n            if (hasOwnProperty.call(other, prop)) {\n                hash[prop] = other[prop];\n            }\n        }\n    }\n    /**\n      @private\n    \n      Extracts query params from the end of an array\n    **/\n    function extractQueryParams(array) {\n        var len = array && array.length,\n            head = void 0,\n            queryParams = void 0;\n        if (len && len > 0) {\n            var obj = array[len - 1];\n            if (isQueryParams(obj)) {\n                queryParams = obj.queryParams;\n                head = slice.call(array, 0, len - 1);\n                return [head, queryParams];\n            }\n        }\n        return [array, null];\n    }\n    function isQueryParams(obj) {\n        return obj && hasOwnProperty.call(obj, 'queryParams');\n    }\n    /**\n      @private\n    \n      Coerces query param properties and array elements into strings.\n    **/\n    function coerceQueryParamsToString(queryParams) {\n        for (var key in queryParams) {\n            var val = queryParams[key];\n            if (typeof val === 'number') {\n                queryParams[key] = '' + val;\n            } else if (Array.isArray(val)) {\n                for (var i = 0, l = val.length; i < l; i++) {\n                    val[i] = '' + val[i];\n                }\n            }\n        }\n    }\n    /**\n      @private\n     */\n    function log(router) {\n        if (!router.log) {\n            return;\n        }\n\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n        }\n\n        if (args.length === 2) {\n            var sequence = args[0],\n                msg = args[1];\n\n            router.log('Transition #' + sequence + ': ' + msg);\n        } else {\n            var _msg = args[0];\n\n            router.log(_msg);\n        }\n    }\n    function isParam(object) {\n        return typeof object === 'string' || object instanceof String || typeof object === 'number' || object instanceof Number;\n    }\n    function forEach(array, callback) {\n        for (var i = 0, l = array.length; i < l && callback(array[i]) !== false; i++) {\n            // empty intentionally\n        }\n    }\n    function getChangelist(oldObject, newObject) {\n        var key = void 0;\n        var results = {\n            all: {},\n            changed: {},\n            removed: {}\n        };\n        merge(results.all, newObject);\n        var didChange = false;\n        coerceQueryParamsToString(oldObject);\n        coerceQueryParamsToString(newObject);\n        // Calculate removals\n        for (key in oldObject) {\n            if (hasOwnProperty.call(oldObject, key)) {\n                if (!hasOwnProperty.call(newObject, key)) {\n                    didChange = true;\n                    results.removed[key] = oldObject[key];\n                }\n            }\n        }\n        // Calculate changes\n        for (key in newObject) {\n            if (hasOwnProperty.call(newObject, key)) {\n                var oldElement = oldObject[key];\n                var newElement = newObject[key];\n                if (isArray(oldElement) && isArray(newElement)) {\n                    if (oldElement.length !== newElement.length) {\n                        results.changed[key] = newObject[key];\n                        didChange = true;\n                    } else {\n                        for (var i = 0, l = oldElement.length; i < l; i++) {\n                            if (oldElement[i] !== newElement[i]) {\n                                results.changed[key] = newObject[key];\n                                didChange = true;\n                            }\n                        }\n                    }\n                } else if (oldObject[key] !== newObject[key]) {\n                    results.changed[key] = newObject[key];\n                    didChange = true;\n                }\n            }\n        }\n        return didChange ? results : undefined;\n    }\n    function isArray(obj) {\n        return Array.isArray(obj);\n    }\n    function promiseLabel(label) {\n        return 'Router: ' + label;\n    }\n    //# sourceMappingURL=utils.js.map\n});"],"names":[],"mappings":"AAAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACviBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;","file":"router.amd.js"}